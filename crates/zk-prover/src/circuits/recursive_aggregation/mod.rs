// SPDX-License-Identifier: LGPL-3.0-only
//
// This file is provided WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.

//! Proof aggregation for recursive circuits.
//!
//! Aggregates proofs by executing a wrapper circuit (e.g. dkg pk) that verifies
//! inner proofs and produces a non-ZK aggregated proof.

mod utils;
mod vk;

use crate::circuits::utils::inputs_json_to_input_map;
use crate::error::ZkError;
use crate::prover::ZkProver;
use crate::witness::{CompiledCircuit, WitnessGenerator};
use e3_events::Proof;

use self::utils::bytes_to_field_strings;

/// Full input for the recursive wrapper circuit.
struct WrapperInput {
    verification_key: Vec<String>,
    proofs: Vec<Vec<String>>,
    public_inputs: Vec<Vec<String>>,
    key_hash: String,
}

impl WrapperInput {
    fn to_json(&self) -> Result<serde_json::Value, ZkError> {
        serde_json::to_value(self).map_err(|e| ZkError::SerializationError(e.to_string()))
    }
}

impl serde::Serialize for WrapperInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeMap;
        let mut map = serializer.serialize_map(Some(4))?;
        map.serialize_entry("verification_key", &self.verification_key)?;
        map.serialize_entry("proofs", &self.proofs)?;
        map.serialize_entry("public_inputs", &self.public_inputs)?;
        map.serialize_entry("key_hash", &self.key_hash)?;
        map.end()
    }
}

/// Generates a wrapper proof by executing the recursive wrapper circuit.
/// Loads verification_key and key_hash from the inner circuit (via `{circuit}.vk` and `{circuit}.vk_hash`).
///
/// # Arguments
/// * `prover` - ZK prover with bb and circuits configured
/// * `proofs` - 1 or 2 proofs to aggregate (must share the same circuit)
/// * `e3_id` - Job identifier for work dir
///
/// # Notes
/// The wrapper circuit lives at `recursive_aggregation/wrapper/{group}/{name}`.
/// Requires `{circuit}.vk` and `{circuit}.vk_hash` in the inner circuit dir (generated by build script).
pub fn generate_wrapper_proof(
    prover: &ZkProver,
    proofs: &[Proof],
    e3_id: &str,
) -> Result<Proof, ZkError> {
    let (proof_fields, public_inputs) = match proofs {
        [p] => (
            vec![bytes_to_field_strings(&p.data)?],
            vec![bytes_to_field_strings(&p.public_signals)?],
        ),
        [a, b] => {
            if a.circuit != b.circuit {
                return Err(ZkError::InvalidInput(
                    "all proofs must share the same circuit".into(),
                ));
            }
            (
                vec![
                    bytes_to_field_strings(&a.data)?,
                    bytes_to_field_strings(&b.data)?,
                ],
                vec![
                    bytes_to_field_strings(&a.public_signals)?,
                    bytes_to_field_strings(&b.public_signals)?,
                ],
            )
        }
        _ => {
            return Err(ZkError::InvalidInput(
                "wrapper circuit requires 1 or 2 proofs".into(),
            ))
        }
    };
    let circuit = proofs[0].circuit;

    let vk_artifacts = vk::load_vk_artifacts(prover.circuits_dir(), circuit)?;

    let full_input = WrapperInput {
        verification_key: vk_artifacts.verification_key,
        proofs: proof_fields,
        public_inputs,
        key_hash: vk_artifacts.key_hash,
    };

    let dir_path = circuit.wrapper_dir_path();
    let circuit_path = prover
        .circuits_dir()
        .join(&dir_path)
        .join(format!("{}.json", circuit.as_str()));
    let compiled = CompiledCircuit::from_file(&circuit_path)?;

    let json = full_input.to_json()?;
    let input_map = inputs_json_to_input_map(&json)?;

    let witness_gen = WitnessGenerator::new();
    let witness = witness_gen.generate_witness(&compiled, input_map)?;

    prover.generate_wrapper_proof(circuit, &witness, e3_id)
}

#[cfg(all(test, feature = "integration-tests"))]
mod tests {
    use super::*;
    use crate::prover::ZkProver;
    use crate::test_utils::get_tempdir;
    use crate::traits::Provable;
    use e3_config::BBPath;
    use e3_fhe_params::BfvPreset;
    use e3_zk_helpers::circuits::dkg::pk::circuit::{PkCircuit, PkCircuitData};
    use std::env;
    use std::path::PathBuf;

    fn test_backend(temp_path: &std::path::Path) -> crate::backend::ZkBackend {
        let noir_dir = temp_path.join("noir");
        let bb_binary = match env::var("E3_CUSTOM_BB") {
            Ok(path) => BBPath::Custom(PathBuf::from(path)),
            Err(_) => BBPath::Default(noir_dir.join("bin").join("bb")),
        };
        let circuits_dir = noir_dir.join("circuits");
        let work_dir = noir_dir.join("work").join("test_node");
        crate::backend::ZkBackend::with_config(
            bb_binary,
            circuits_dir,
            work_dir,
            crate::config::ZkConfig::default(),
        )
    }

    fn dist_circuits_path() -> PathBuf {
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("..")
            .join("..")
            .join("dist")
            .join("circuits")
    }

    #[tokio::test]
    async fn test_generate_and_verify_wrapper_proof() {
        let temp = get_tempdir().unwrap();
        let mut backend = test_backend(temp.path());

        backend.ensure_installed().await.expect("ensure_installed");

        let dist = dist_circuits_path();
        let wrapper_src = dist
            .join("recursive_aggregation")
            .join("wrapper")
            .join("dkg")
            .join("pk");
        if wrapper_src.join("pk.json").exists() && wrapper_src.join("pk.vk").exists() {
            // Use dist entirely so inner + wrapper circuits match (same build).
            backend.circuits_dir = dist.clone();
        }

        let prover = ZkProver::new(&backend);

        let wrapper_dir = backend
            .circuits_dir
            .join("recursive_aggregation")
            .join("wrapper")
            .join("dkg")
            .join("pk");
        if !wrapper_dir.join("pk.json").exists() || !wrapper_dir.join("pk.vk").exists() {
            panic!(
                "wrapper circuit not found at {} â€” run pnpm build:circuits and set circuits_dir to dist/circuits, or ensure the release includes recursive_aggregation",
                wrapper_dir.display()
            );
        }

        let preset = BfvPreset::InsecureThreshold512;
        let sample =
            PkCircuitData::generate_sample(preset).expect("sample data generation should succeed");

        let e3_id = "aggregation-test-wrapper";
        let inner_proof = PkCircuit
            .prove_for_recursion(&prover, &preset, &sample, e3_id)
            .expect("inner proof generation should succeed");

        let wrapper_proof = generate_wrapper_proof(&prover, &[inner_proof], e3_id)
            .expect("wrapper proof generation should succeed");

        assert!(!wrapper_proof.data.is_empty());
        assert!(!wrapper_proof.public_signals.is_empty());

        let verified = prover
            .verify_wrapper_proof(&wrapper_proof, e3_id, 0)
            .expect("verification should not error");
        assert!(verified, "wrapper proof should verify successfully");

        prover.cleanup(e3_id).unwrap();
    }
}
