// SPDX-License-Identifier: LGPL-3.0-only
//
// This file is provided WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.

//! Proof aggregation for recursive circuits.
//!
//! Aggregates proofs by executing a wrapper circuit (e.g. dkg pk) that verifies
//! inner proofs and produces a non-ZK aggregated proof.

mod utils;
mod vk;

use crate::circuits::utils::inputs_json_to_input_map;
use crate::error::ZkError;
use crate::prover::ZkProver;
use crate::witness::{CompiledCircuit, WitnessGenerator};
use e3_events::{CircuitName, Proof};

use self::utils::bytes_to_field_strings;

/// Full input for the recursive wrapper circuit.
struct WrapperInput {
    verification_key: Vec<String>,
    proofs: Vec<Vec<String>>,
    public_inputs: Vec<Vec<String>>,
    key_hash: String,
}

impl WrapperInput {
    fn to_json(&self) -> Result<serde_json::Value, ZkError> {
        serde_json::to_value(self).map_err(|e| ZkError::SerializationError(e.to_string()))
    }
}

impl serde::Serialize for WrapperInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeMap;
        let mut map = serializer.serialize_map(Some(4))?;
        map.serialize_entry("verification_key", &self.verification_key)?;
        map.serialize_entry("proofs", &self.proofs)?;
        map.serialize_entry("public_inputs", &self.public_inputs)?;
        map.serialize_entry("key_hash", &self.key_hash)?;
        map.end()
    }
}

/// Generates a wrapper proof by executing the recursive wrapper circuit.
/// Loads verification_key and key_hash from the inner circuit (via `{circuit}.vk` and `{circuit}.vk_hash`).
///
/// # Arguments
/// * `prover` - ZK prover with bb and circuits configured
/// * `proofs` - 1 or 2 proofs to aggregate (must share the same circuit)
/// * `e3_id` - Job identifier for work dir
///
/// # Notes
/// The wrapper circuit lives at `recursive_aggregation/wrapper/{group}/{name}`.
/// Requires `{circuit}.vk` and `{circuit}.vk_hash` in the inner circuit dir (generated by build script).
pub fn generate_wrapper_proof(
    prover: &ZkProver,
    proofs: &[Proof],
    e3_id: &str,
) -> Result<Proof, ZkError> {
    let (proof_fields, public_inputs) = match proofs {
        [p] => (
            vec![bytes_to_field_strings(&p.data)?],
            vec![bytes_to_field_strings(&p.public_signals)?],
        ),
        [a, b] => {
            if a.circuit != b.circuit {
                return Err(ZkError::InvalidInput(
                    "all proofs must share the same circuit".into(),
                ));
            }

            (
                vec![
                    bytes_to_field_strings(&a.data)?,
                    bytes_to_field_strings(&b.data)?,
                ],
                vec![
                    bytes_to_field_strings(&a.public_signals)?,
                    bytes_to_field_strings(&b.public_signals)?,
                ],
            )
        }
        _ => {
            return Err(ZkError::InvalidInput(
                "wrapper circuit requires 1 or 2 proofs".into(),
            ))
        }
    };
    let circuit = proofs[0].circuit;

    let vk_artifacts = vk::load_vk_artifacts(prover.circuits_dir(), circuit)?;

    let full_input = WrapperInput {
        verification_key: vk_artifacts.verification_key,
        proofs: proof_fields,
        public_inputs,
        key_hash: vk_artifacts.key_hash,
    };

    let dir_path = circuit.wrapper_dir_path();
    let circuit_path = prover
        .circuits_dir()
        .join(&dir_path)
        .join(format!("{}.json", circuit.as_str()));
    let compiled = CompiledCircuit::from_file(&circuit_path)?;

    let json = full_input.to_json()?;
    let input_map = inputs_json_to_input_map(&json)?;

    let witness_gen = WitnessGenerator::new();
    let witness = witness_gen.generate_witness(&compiled, input_map)?;

    prover.generate_wrapper_proof(circuit, &witness, e3_id)
}

/// Full input for the fold circuit (recursive_aggregation/fold).
/// Generic names for two proofs, each with its own VK.
struct FoldInput {
    proof1_verification_key: Vec<String>,
    proof1_proof: Vec<String>,
    proof1_commitment: String,
    proof1_key_hash: String,
    proof2_verification_key: Vec<String>,
    proof2_proof: Vec<String>,
    proof2_commitment: String,
    proof2_key_hash: String,
}

impl FoldInput {
    fn to_json(&self) -> Result<serde_json::Value, ZkError> {
        serde_json::to_value(self).map_err(|e| ZkError::SerializationError(e.to_string()))
    }
}

impl serde::Serialize for FoldInput {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeMap;
        let mut map = serializer.serialize_map(Some(8))?;
        map.serialize_entry("proof1_verification_key", &self.proof1_verification_key)?;
        map.serialize_entry("proof1_proof", &self.proof1_proof)?;
        map.serialize_entry("proof1_commitment", &self.proof1_commitment)?;
        map.serialize_entry("proof1_key_hash", &self.proof1_key_hash)?;
        map.serialize_entry("proof2_verification_key", &self.proof2_verification_key)?;
        map.serialize_entry("proof2_proof", &self.proof2_proof)?;
        map.serialize_entry("proof2_commitment", &self.proof2_commitment)?;
        map.serialize_entry("proof2_key_hash", &self.proof2_key_hash)?;
        map.end()
    }
}

/// Generates the fold proof by folding two proofs.
/// VK path is chosen by circuit type: Fold uses dir_path, wrappers use wrapper_dir_path.
pub fn generate_fold_proof(
    prover: &ZkProver,
    proof1: &Proof,
    proof2: &Proof,
    e3_id: &str,
) -> Result<Proof, ZkError> {
    let vk1 = vk::load_vk_for_fold_input(prover.circuits_dir(), proof1.circuit)?;
    let vk2 = vk::load_vk_for_fold_input(prover.circuits_dir(), proof2.circuit)?;

    let commitment1 = bytes_to_field_strings(&proof1.public_signals)?
        .into_iter()
        .last()
        .ok_or_else(|| ZkError::InvalidInput("proof1 public_signals is empty".into()))?;
    let commitment2 = bytes_to_field_strings(&proof2.public_signals)?
        .into_iter()
        .last()
        .ok_or_else(|| ZkError::InvalidInput("proof2 public_signals is empty".into()))?;

    let full_input = FoldInput {
        proof1_verification_key: vk1.verification_key,
        proof1_proof: bytes_to_field_strings(&proof1.data)?,
        proof1_commitment: commitment1,
        proof1_key_hash: vk1.key_hash,
        proof2_verification_key: vk2.verification_key,
        proof2_proof: bytes_to_field_strings(&proof2.data)?,
        proof2_commitment: commitment2,
        proof2_key_hash: vk2.key_hash,
    };

    let dir_path = CircuitName::Fold.dir_path();
    let circuit_path = prover
        .circuits_dir()
        .join(&dir_path)
        .join(format!("{}.json", CircuitName::Fold.as_str()));
    let compiled = CompiledCircuit::from_file(&circuit_path)?;

    let json = full_input.to_json()?;
    let input_map = inputs_json_to_input_map(&json)?;

    let witness_gen = WitnessGenerator::new();
    let witness = witness_gen.generate_witness(&compiled, input_map)?;

    prover.generate_fold_proof(&witness, e3_id)
}

#[cfg(all(test, feature = "integration-tests"))]
mod tests {
    use super::*;
    use crate::prover::ZkProver;
    use crate::test_utils::get_tempdir;
    use crate::traits::Provable;
    use e3_config::BBPath;
    use e3_fhe_params::BfvPreset;
    use e3_zk_helpers::circuits::dkg::pk::circuit::{PkCircuit, PkCircuitData};
    use e3_zk_helpers::circuits::dkg::share_decryption::{
        ShareDecryptionCircuit, ShareDecryptionCircuitData,
    };
    use e3_zk_helpers::computation::DkgInputType;
    use e3_zk_helpers::dkg::share_encryption::{
        ShareEncryptionCircuit, ShareEncryptionCircuitData,
    };
    use e3_zk_helpers::CiphernodesCommitteeSize;
    use std::env;
    use std::path::PathBuf;

    fn test_backend(temp_path: &std::path::Path) -> crate::backend::ZkBackend {
        let noir_dir = temp_path.join("noir");
        let bb_binary = match env::var("E3_CUSTOM_BB") {
            Ok(path) => BBPath::Custom(PathBuf::from(path)),
            Err(_) => BBPath::Default(noir_dir.join("bin").join("bb")),
        };
        let circuits_dir = {
            let dist = dist_circuits_path();
            let version_file = dist.parent().map(|p| p.join("version.json"));
            if dist.exists() && version_file.as_ref().is_some_and(|f| f.exists()) {
                dist
            } else {
                noir_dir.join("circuits")
            }
        };
        let work_dir = noir_dir.join("work").join("test_node");
        crate::backend::ZkBackend::with_config(
            bb_binary,
            circuits_dir,
            work_dir,
            crate::config::ZkConfig::default(),
        )
    }

    fn dist_circuits_path() -> PathBuf {
        PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("..")
            .join("..")
            .join("dist")
            .join("circuits")
    }

    #[tokio::test]
    async fn test_generate_and_verify_wrapper_proof() {
        let temp = get_tempdir().unwrap();
        let mut backend = test_backend(temp.path());

        backend.ensure_installed().await.expect("ensure_installed");

        let dist = dist_circuits_path();
        let wrapper_src = dist
            .join("recursive_aggregation")
            .join("wrapper")
            .join("dkg")
            .join("pk");
        if wrapper_src.join("pk.json").exists() && wrapper_src.join("pk.vk").exists() {
            // Use dist entirely so inner + wrapper circuits match (same build).
            backend.circuits_dir = dist.clone();
        }

        let prover = ZkProver::new(&backend);

        let wrapper_dir = backend
            .circuits_dir
            .join("recursive_aggregation")
            .join("wrapper")
            .join("dkg")
            .join("pk");
        if !wrapper_dir.join("pk.json").exists() || !wrapper_dir.join("pk.vk").exists() {
            panic!(
                "wrapper circuit not found at {} — run pnpm build:circuits and set circuits_dir to dist/circuits, or ensure the release includes recursive_aggregation",
                wrapper_dir.display()
            );
        }

        let preset = BfvPreset::InsecureThreshold512;
        let sample =
            PkCircuitData::generate_sample(preset).expect("sample data generation should succeed");

        let e3_id = "aggregation-test-wrapper";
        let start = std::time::Instant::now();
        let wrapper_proof = PkCircuit
            .aggregate_proof(&prover, &preset, &[sample], None, e3_id)
            .expect("aggregate_proof (1 input) should succeed");
        let elapsed = start.elapsed();
        eprintln!("1-proof wrapper generation: {:?}", elapsed);

        assert!(!wrapper_proof.data.is_empty());
        assert!(!wrapper_proof.public_signals.is_empty());

        let verified = prover
            .verify_wrapper_proof(&wrapper_proof, e3_id, 0)
            .expect("verification should not error");
        assert!(verified, "wrapper proof should verify successfully");

        prover.cleanup(&format!("{}_inner_0", e3_id)).unwrap();
        prover.cleanup(e3_id).unwrap();
    }

    #[tokio::test]
    async fn test_generate_and_verify_wrapper_proof_2_proofs() {
        let temp = get_tempdir().unwrap();
        let mut backend = test_backend(temp.path());

        backend.ensure_installed().await.expect("ensure_installed");

        let dist = dist_circuits_path();
        let wrapper_src = dist
            .join("recursive_aggregation")
            .join("wrapper")
            .join("dkg")
            .join("share_decryption");
        if wrapper_src.join("share_decryption.json").exists()
            && wrapper_src.join("share_decryption.vk_recursive").exists()
        {
            backend.circuits_dir = dist.clone();
        }

        let prover = ZkProver::new(&backend);

        let wrapper_dir = backend
            .circuits_dir
            .join("recursive_aggregation")
            .join("wrapper")
            .join("dkg")
            .join("share_decryption");
        if !wrapper_dir.join("share_decryption.json").exists()
            || !wrapper_dir.join("share_decryption.vk_recursive").exists()
        {
            panic!(
                "2-proof wrapper circuit not found at {} — run pnpm build:circuits and set circuits_dir to dist/circuits",
                wrapper_dir.display()
            );
        }

        let preset = BfvPreset::InsecureThreshold512;
        let committee = CiphernodesCommitteeSize::Small.values();
        let sample_a = ShareDecryptionCircuitData::generate_sample(
            preset,
            committee.clone(),
            DkgInputType::SecretKey,
        )
        .expect("sample A generation should succeed");
        let sample_b =
            ShareDecryptionCircuitData::generate_sample(preset, committee, DkgInputType::SecretKey)
                .expect("sample B generation should succeed");

        let e3_id = "aggregation-2proof-wrapper";
        let start = std::time::Instant::now();
        let wrapper_proof = ShareDecryptionCircuit
            .aggregate_proof(&prover, &preset, &[sample_a, sample_b], None, e3_id)
            .expect("aggregate_proof (2 inputs) should succeed");
        let elapsed = start.elapsed();
        eprintln!("2-proof wrapper generation: {:?}", elapsed);

        assert!(!wrapper_proof.data.is_empty());
        assert!(!wrapper_proof.public_signals.is_empty());

        let verified = prover
            .verify_wrapper_proof(&wrapper_proof, e3_id, 0)
            .expect("verification should not error");
        assert!(verified, "2-proof wrapper should verify successfully");

        prover
            .cleanup("aggregation-2proof-wrapper_inner_0")
            .unwrap();
        prover
            .cleanup("aggregation-2proof-wrapper_inner_1")
            .unwrap();
        prover.cleanup(e3_id).unwrap();
    }

    #[tokio::test]
    async fn test_generate_and_verify_fold_proof() {
        let temp = get_tempdir().unwrap();
        let mut backend = test_backend(temp.path());

        backend.ensure_installed().await.expect("ensure_installed");

        let dist = dist_circuits_path();
        let pk_wrapper = dist
            .join("recursive_aggregation")
            .join("wrapper")
            .join("dkg")
            .join("pk");
        let share_enc_wrapper = dist
            .join("recursive_aggregation")
            .join("wrapper")
            .join("dkg")
            .join("share_encryption");
        let fold_dir = dist.join("recursive_aggregation").join("fold");
        if pk_wrapper.join("pk.json").exists()
            && pk_wrapper.join("pk.vk_recursive").exists()
            && share_enc_wrapper.join("share_encryption.json").exists()
            && share_enc_wrapper
                .join("share_encryption.vk_recursive")
                .exists()
            && fold_dir.join("fold.json").exists()
            && fold_dir.join("fold.vk_recursive").exists()
        {
            backend.circuits_dir = dist.clone();
        }

        let prover = ZkProver::new(&backend);

        if !pk_wrapper.join("pk.json").exists()
            || !pk_wrapper.join("pk.vk_recursive").exists()
            || !share_enc_wrapper.join("share_encryption.json").exists()
            || !share_enc_wrapper
                .join("share_encryption.vk_recursive")
                .exists()
        {
            panic!(
                "wrapper circuits not found — run pnpm build:circuits and ensure dist/circuits includes recursive_aggregation wrappers for pk and share_encryption",
            );
        }
        if !fold_dir.join("fold.json").exists() || !fold_dir.join("fold.vk_recursive").exists() {
            panic!(
                "fold circuit not found at {} — run pnpm build:circuits",
                fold_dir.display()
            );
        }

        let preset = BfvPreset::InsecureThreshold512;
        let committee = CiphernodesCommitteeSize::Small.values();
        let sd = preset.search_defaults().expect("search_defaults");

        let pk_sample =
            PkCircuitData::generate_sample(preset).expect("pk sample generation should succeed");
        let share_enc_sample_secret = ShareEncryptionCircuitData::generate_sample(
            preset,
            committee.clone(),
            DkgInputType::SecretKey,
            sd.z,
            sd.lambda,
        )
        .expect("share_encryption sample (secret) generation should succeed");

        let share_enc_sample_noise = ShareEncryptionCircuitData::generate_sample(
            preset,
            committee,
            DkgInputType::SmudgingNoise,
            sd.z,
            sd.lambda,
        )
        .expect("share_encryption sample (noise) generation should succeed");

        let e3_id = "aggregation-test-fold";

        let pk_wrapper_proof = PkCircuit
            .aggregate_proof(&prover, &preset, &[pk_sample], None, e3_id)
            .expect("pk aggregate_proof (1 input) should succeed");

        let fold_proof = ShareEncryptionCircuit
            .aggregate_proof(
                &prover,
                &preset,
                &[share_enc_sample_secret, share_enc_sample_noise],
                Some(&pk_wrapper_proof),
                e3_id,
            )
            .expect("share_encryption aggregate_proof with fold should succeed");

        assert!(!fold_proof.data.is_empty());
        assert!(!fold_proof.public_signals.is_empty());
        assert_eq!(fold_proof.circuit, e3_events::CircuitName::Fold);

        let verified = prover
            .verify_fold_proof(&fold_proof, e3_id, 0)
            .expect("verification should not error");
        assert!(verified, "fold proof should verify successfully");

        prover.cleanup(&format!("{}_inner_0", e3_id)).unwrap();
        prover.cleanup(e3_id).unwrap();
    }
}
