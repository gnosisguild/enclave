{"noir_version":"1.0.0-beta.15+83245db91dcf63420ef4bcbbd85b98f397fee663","hash":"9828651845942763134","abi":{"parameters":[{"name":"expected_commitments","type":{"kind":"array","length":5,"type":{"kind":"array","length":2,"type":{"kind":"field"}}},"visibility":"public"},{"name":"decrypted_shares","type":{"kind":"array","length":5,"type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":512,"type":{"kind":"field"}}}]}}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{"10481401461242010843":{"error_kind":"string","string":"Commitment mismatch"}}},"bytecode":"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","debug_symbols":"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D2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsMZD2c8nPFwxsNZNSHn2Ygc9qghOTUlp8bk1JycGpRTk3JqVA6dq6a80Tkezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezsywMkOszBQrM8bKzLEyg6yMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezjX/qgZg1QSsGoFVM7BqCFZNwaoxWDUHqwZh1SSsGoVVs7BqGFZNw6pxWDUPqwZi1USsGon1bCZWDcV6NhWLPWouVg3GqslYNRqrZmPVcCw6r/FYNR+rBmTVhKwakVUzsmpIVk3JqjFZNSerBmXVpKwalVWzsmpYVk3LqnFZNS+rBmbVxKwamVUzs2poVk3NqrFZNTerBmfV5KwanVWzs2p4Vk3PqvFZNT+rBmjVBK0aoVUztGqIVk3RqjFaNUerBmnVJK0apVWztGqYVk3TqnFaNU+rBmrh4YyHc83UqqFaNVXrycM9XS2u9v1cuSZr1Witmq1Vw7VqulaN16r5WjVgqyZs1YgtPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDudXkVjrHwxkPZzyc8XDGw7nVFLwag1dz8J4NwmOPGoVXs/BqGF5Nw6txeHSOhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng495rRTOdM+DIjvsyMLzPky0z5MmO+jIczHs54OOPhjIczHs54OOPh3GvuZQ2+rMmXNfry2exL9qjplzX+suZf1gBMOsfDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ/nUdPY6RwPZzyc8XDGwxkPZzyc8XDGwxkPZzyc8XDGwxkPZzyc8XDGwxkPZzyc8XDGwxkPZzyc8XAeNem2Rt3WrNsadlvTbp+Nu2WPGnhbE29r5C2d4+GMhzMezng44+GMhzMezng44+HMxDEzcszMHPOTh3u6alz1+7kyHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OOPhjIczHs54OM/6dxfoHA9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDedZs6xpuXdOta7x1zbeuAdfPJlyzR824riHX3M/xcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcMbDGQ9nPJzxcGb+mRmAZiagmRFoZgaaGYJmPJzxcMbDGQ9nPJzxcMbDGQ9nPJxX/QsrdI6HMx7OeDjj4YyHMx7OeDjj4YyHMx7OeDjj4YyHMx7OeDjj4YyHMx7OeDjj4YyHMx7OeDjj4YyHMx7OeDjj4YyHMx7OeDjj4YyHMx7OeDjj4YyHMx7OeDjj4YyH86pp9jXOvubZ10D7mmhfI+1rpv2zofbsUWPt6RwPZzyc8XDGwxkPZzyc8XDGwxkPZzyc8XDGwxkPZzyc8XDGwxkPZzyc8XDGwxkPZzyc8XDGwxkPZzyc8XDGwxkPZzyc8XDGwxkPZzyc8XDGwxkPZzyc8XDGwxkPZzyc8XDGwxkPZzyc8XDe9W8p0Tkezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng44+GMhzMezng4M4/NDGQzE9n85OGervKc+tHDPf0TDl87H9fjlblqXHWuBleTq8XV5urk6mvn9xV7LPZY7LHYY7HHYo/FHos9Fnts9tjssdljs8dmj80emz02e2z22Oxx2OOwx2GPwx6HPQ57HPY47HHY42SPRw93X4krc9W46lwNriZXi6vNFXuIPcQeYg+xh9hD7CH2EHuIPcQeZg+zh9nD7GH2MHuYPcweZg+zR2OPxh6NPRp7NPZo7NHYo7FHY4/GHp09Ont09ujs0dmjs0dnj84enT06ewz2GOwx2GOwx2CPwR6DPQZ7DPYY7DHZg84PnR86P3R+6PzQ+aHzQ+eHzg+dHzo/dH7o/ND5ofND54fOD50fOj90fuj80Pmh80Pnh84PnR86P3R+6PzQ+aHzQ+eHzg+dHzo/dH7o/ND5SeftSuftSuftSuftSuftSuftSuftSuftSuftSuftuthD7CH2EHuIPcQeYg+xh9hD7CH2MHuYPcweZg+zh9nD7GH2MHuYPRp7NPZo7NHYo7FHY4/GHo09Gns09ujs0dmjs0dnj84enT06e3T26OzR2WOwx2CPwR6DPQZ7DPYY7DHYY7DHYI/JHpM9JntM9pjsMdljssdkj8kekz0Weyz2WOyx2GOxx2KPxR6LPRZ7LPbY7LHZY7PHZo/NHps9Nnts9tjssdnjsfP1ePV1j6//wut/3n/5+P6nTx/+/e5vf3z9F0p///xz/jnSh//52///mv/y05ePnz59/NePv3755ecP//j9y4ev/3Tp43/78+9//hc=","file_map":{"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse lib::configs::default::dkg::{L_THRESHOLD, N, SHARE_DECRYPTION_BIT_MSG};\nuse lib::configs::default::H;\nuse lib::core::dkg::share_decryption::ShareDecryption;\nuse lib::math::polynomial::Polynomial;\n\nfn main(\n    expected_commitments: pub [[Field; L_THRESHOLD]; H],\n    decrypted_shares: [[Polynomial<N>; L_THRESHOLD]; H],\n) -> pub Field {\n    let share_decryption: ShareDecryption<N, L_THRESHOLD, H, SHARE_DECRYPTION_BIT_MSG> =\n        ShareDecryption::new(expected_commitments, decrypted_shares);\n\n    share_decryption.execute()\n}\n","path":"/Users/omardesogus/Projects/Enclave/enclave/circuits/bin/dkg/share_decryption/src/main.nr"},"64":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse crate::math::commitments::{\n    compute_aggregated_shares_commitment, compute_share_encryption_commitment_from_message,\n};\nuse crate::math::polynomial::Polynomial;\n\n/// Share Decryption Commitment Verification (Circuit 4).\n///\n/// Verifies:\n/// 1. Each decrypted share from H honest parties matches its commitment from Circuit 3\n/// 2. Computes sum of all shares\n/// 3. Returns commitment to aggregated shares\npub struct ShareDecryption<let N: u32, let L: u32, let H: u32, let BIT_MSG: u32> {\n    /// Expected commitments from Circuit 3 for H honest parties: [party_idx][mod_idx]\n    /// (public witness)\n    expected_commitments: [[Field; L]; H],\n\n    /// Decrypted shares from H honest parties: [party_idx][mod_idx]\n    /// (secret witnesses)\n    decrypted_shares: [[Polynomial<N>; L]; H],\n}\n\nimpl<let N: u32, let L: u32, let H: u32, let BIT_MSG: u32> ShareDecryption<N, L, H, BIT_MSG> {\n    pub fn new(\n        expected_commitments: [[Field; L]; H],\n        decrypted_shares: [[Polynomial<N>; L]; H],\n    ) -> Self {\n        ShareDecryption { expected_commitments, decrypted_shares }\n    }\n\n    /// Verifies all decrypted shares match their expected commitments\n    fn verify_commitments(self) {\n        for party_idx in 0..H {\n            for mod_idx in 0..L {\n                assert(\n                    compute_share_encryption_commitment_from_message::<N, BIT_MSG>(\n                        self.decrypted_shares[party_idx][mod_idx],\n                    )\n                        == self.expected_commitments[party_idx][mod_idx],\n                    \"Commitment mismatch\",\n                );\n            }\n        }\n    }\n\n    /// Computes sum of all decrypted shares\n    fn compute_aggregated_shares(self) -> [Polynomial<N>; L] {\n        let mut sum: [Polynomial<N>; L] = [Polynomial::new([0; N]); L];\n\n        for mod_idx in 0..L {\n            let mut coeffs = [0 as Field; N];\n            for coeff_idx in 0..N {\n                let mut total = 0 as Field;\n                for party_idx in 0..H {\n                    total =\n                        total + self.decrypted_shares[party_idx][mod_idx].coefficients[coeff_idx];\n                }\n                coeffs[coeff_idx] = total;\n            }\n            sum[mod_idx] = Polynomial::new(coeffs);\n        }\n\n        sum\n    }\n\n    /// Main verification function\n    /// Returns commitment to aggregated shares\n    pub fn execute(self) -> Field {\n        // Step 1: Verify all commitments match\n        self.verify_commitments();\n\n        // Step 2: Compute aggregated shares\n        let aggregated = self.compute_aggregated_shares();\n\n        // Step 3: Return commitment to aggregated shares\n        compute_aggregated_shares_commitment::<N, L, BIT_MSG>(aggregated)\n    }\n}\n","path":"/Users/omardesogus/Projects/Enclave/enclave/circuits/lib/src/core/dkg/share_decryption.nr"},"74":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse crate::math::helpers::{compute_safe, flatten};\nuse crate::math::polynomial::Polynomial;\n\n/// DOMAIN SEPARATORS\n\n// Domain separator - \"PK\"\npub global DS_PK: [u8; 64] = [\n    0x50, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"PK_GENERATION\"\npub global DS_PK_GENERATION: [u8; 64] = [\n    0x50, 0x4b, 0x5f, 0x47, 0x45, 0x4e, 0x45, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"SHARE_COMPUTATION\"\npub global DS_SHARE_COMPUTATION: [u8; 64] = [\n    0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x43, 0x4f, 0x4d, 0x50, 0x55, 0x54, 0x41, 0x54, 0x49, 0x4f,\n    0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"SHARE_ENCRYPTION\"\npub global DS_SHARE_ENCRYPTION: [u8; 64] = [\n    0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x45, 0x4e, 0x43, 0x52, 0x59, 0x50, 0x54, 0x49, 0x4f, 0x4e,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"PK_AGGREGATION\"\npub global DS_PK_AGGREGATION: [u8; 64] = [\n    0x50, 0x4b, 0x5f, 0x41, 0x47, 0x47, 0x52, 0x45, 0x47, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CIPHERTEXT\"\npub global DS_CIPHERTEXT: [u8; 64] = [\n    0x43, 0x49, 0x50, 0x48, 0x45, 0x52, 0x54, 0x45, 0x58, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"AGGREGATED_SHARES\"\npub global DS_AGGREGATED_SHARES: [u8; 64] = [\n    0x41, 0x47, 0x47, 0x52, 0x45, 0x47, 0x41, 0x54, 0x45, 0x44, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45,\n    0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"RECURSIVE_AGGREGATION\"\npub global DS_RECURSIVE_AGGREGATION: [u8; 64] = [\n    0x52, 0x45, 0x43, 0x55, 0x52, 0x53, 0x49, 0x56, 0x45, 0x5f, 0x41, 0x47, 0x47, 0x52, 0x45, 0x47,\n    0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_PK_GENERATION\"\npub global DS_CLG_PK_GENERATION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x50, 0x4b, 0x5f, 0x47, 0x45, 0x4e, 0x45, 0x52, 0x41, 0x54, 0x49, 0x4f,\n    0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_SHARE_ENCRYPTION\"\npub global DS_CLG_SHARE_ENCRYPTION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x45, 0x4e, 0x43, 0x52, 0x59, 0x50,\n    0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_USER_DATA_ENCRYPTION\"\npub global DS_CLG_USER_DATA_ENCRYPTION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x55, 0x53, 0x45, 0x52, 0x5f, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x45, 0x4e,\n    0x43, 0x52, 0x59, 0x50, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_SHARE_DECRYPTION\"\npub global DS_CLG_SHARE_DECRYPTION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x44, 0x45, 0x43, 0x52, 0x59, 0x50,\n    0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n\n/// WRAPPERS\n\npub fn compute_commitments(\n    payload: Vec<Field>,\n    domain_separator: [u8; 64],\n    io_pattern: [u32; 2],\n) -> Vec<Field> {\n    compute_safe(domain_separator, payload, io_pattern)\n}\n\npub fn single_polynomial_payload<let N: u32, let BIT_POLY: u32>(\n    payload: Vec<Field>,\n    input: Polynomial<N>,\n) -> Vec<Field> {\n    flatten::<_, _, BIT_POLY>(payload, [input])\n}\n\npub fn multiple_polynomial_payload<let N: u32, let L: u32, let BIT_POLY: u32>(\n    payload: Vec<Field>,\n    inputs: [Polynomial<N>; L],\n) -> Vec<Field> {\n    flatten::<_, _, BIT_POLY>(payload, inputs)\n}\n\n/// COMMITMENTS\n\npub fn compute_dkg_pk_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);\n    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);\n\n    compute_commitments(payload, DS_PK, [0x80000000 | payload.len(), 1]).get(0)\n}\n\npub fn compute_threshold_pk_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);\n    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);\n\n    compute_commitments(payload, DS_PK_GENERATION, [0x80000000 | payload.len(), 1]).get(0)\n}\n\npub fn compute_share_computation_sk_commitment<let N: u32, let BIT_SK: u32>(\n    sk: Polynomial<N>,\n) -> Field {\n    let mut payload = single_polynomial_payload::<N, BIT_SK>(Vec::new(), sk);\n    compute_commitments(\n        payload,\n        DS_SHARE_COMPUTATION,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_share_computation_e_sm_commitment<let N: u32, let L: u32, let BIT_E_SM: u32>(\n    e_sm: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_E_SM>(Vec::new(), e_sm);\n    compute_commitments(\n        payload,\n        DS_SHARE_COMPUTATION,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_share_encryption_commitment_from_message<let N: u32, let BIT_MSG: u32>(\n    message: Polynomial<N>,\n) -> Field {\n    let mut payload = single_polynomial_payload::<N, BIT_MSG>(Vec::new(), message);\n    compute_commitments(\n        payload,\n        DS_SHARE_ENCRYPTION,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_share_encryption_commitment_from_shares<let N: u32, let L: u32, let N_PARTIES: u32>(\n    y: [[[Field; N_PARTIES + 1]; L]; N],\n    party_idx: u32,\n    mod_idx: u32,\n) -> Field {\n    let mut payload = Vec::new();\n\n    for coeff_idx in 0..N {\n        payload.push(y[coeff_idx][mod_idx][party_idx + 1]);\n    }\n\n    // Include party_idx and mod_idx in the hash\n    payload.push(party_idx as Field);\n    payload.push(mod_idx as Field);\n\n    compute_commitments(\n        payload,\n        DS_SHARE_ENCRYPTION,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_aggregated_shares_commitment<let N: u32, let L: u32, let BIT_MSG: u32>(\n    agg_shares: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_MSG>(Vec::new(), agg_shares);\n    compute_commitments(\n        payload,\n        DS_AGGREGATED_SHARES,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_pk_aggregation_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);\n    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);\n\n    compute_commitments(payload, DS_PK_AGGREGATION, [0x80000000 | payload.len(), 1]).get(0)\n}\n\npub fn compute_recursive_aggregation_commitment(payload: Vec<Field>) -> Field {\n    compute_safe(\n        DS_RECURSIVE_AGGREGATION,\n        payload,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_ciphertext_commitment<let N: u32, let L: u32, let BIT_CT: u32>(\n    ct0: [Polynomial<N>; L],\n    ct1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_CT>(Vec::new(), ct0);\n    payload = multiple_polynomial_payload::<N, L, BIT_CT>(payload, ct1);\n\n    compute_commitments(payload, DS_CIPHERTEXT, [0x80000000 | payload.len(), 1]).get(0)\n}\n\n/// COMMITMENTS FOR CHALLENGES\n\npub fn compute_threshold_pk_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {\n    compute_commitments(\n        payload,\n        DS_CLG_PK_GENERATION,\n        [0x80000000 | payload.len(), 2 * L],\n    )\n}\n\npub fn compute_share_encryption_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {\n    compute_commitments(\n        payload,\n        DS_CLG_SHARE_ENCRYPTION,\n        [0x80000000 | payload.len(), 2 * L],\n    )\n}\n\npub fn compute_user_data_encryption_challenge_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0is: [Polynomial<N>; L],\n    pk1is: [Polynomial<N>; L],\n    gammas_payload: Vec<Field>,\n    pk_commitment: Field,\n) -> Vec<Field> {\n    assert(compute_pk_aggregation_commitment::<N, L, BIT_PK>(pk0is, pk1is) == pk_commitment);\n\n    compute_commitments(\n        gammas_payload,\n        DS_CLG_USER_DATA_ENCRYPTION,\n        [0x80000000 | gammas_payload.len(), 2 * L],\n    )\n}\n\npub fn compute_threshold_share_decryption_challenge<let L: u32>(payload: Vec<Field>) -> Field {\n    compute_commitments(\n        payload,\n        DS_CLG_SHARE_DECRYPTION,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n","path":"/Users/omardesogus/Projects/Enclave/enclave/circuits/lib/src/math/commitments.nr"},"75":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\n//! Helper functions for circuit construction and cryptographic operations.\nuse crate::math::polynomial::Polynomial;\nuse crate::math::safe::SafeSponge;\n\n/// Compute hex-aligned packing parameters for a given `BIT`.\n///\n/// # Purpose\n/// Returns `(nibble_bits, group)` for use by pack/flatten so layout stays consistent.\n/// - `nibble_bits`: ceil (`BIT`) to the next multiple of 4 (nibble alignment).\n///   - Examples: `BIT = 7 -> 8`, `BIT = 8 -> 8`, `BIT = 9 -> 12`, `BIT = 10 -> 12`, `BIT = 11 -> 12`,\n///     `BIT=16 -> 16`, `BIT = 17 -> 20`.\n/// - `group`: max number of encoded limbs that fit in one BN254 field element,\n///            when each limb uses an extra 4 bits (see below).\n///\n/// # Rationale\n/// - We align to nibbles so powers of two are hex-friendly and deterministic.\n/// - We reserve one extra nibble (4 bits) per stored value to lift signed\n///   coefficients into the non-negative range (e.g., store `v + 2^nibble_bits`),\n///   which implies a radix of `2^(nibble_bits + 4)`.\n///\n/// # Safety\n/// - Asserts `nibble_bits + 4 <= 254` to avoid mod-p wrap on BN254.\n/// - Ensures at least one limb fits: `group >= 1`.\nfn packing_layout<let BIT: u32>() -> (u32, u32) {\n    // Ceil BIT up to the next multiple of 4 (nibble alignment).\n    let nibble_bits = ((BIT + 3) / 4) * 4;\n\n    // Each stored limb uses an extra nibble because negative coefficients\n    // will be shifted to positive, so radix = 2^(nibble_bits+4).\n    assert(nibble_bits + 4 <= 254);\n\n    // Maximum limbs that fit in one BN254 element without wrap.\n    let group = 254 / (nibble_bits + 4);\n    assert(group >= 1);\n    (nibble_bits, group)\n}\n\n/// Flatten `L` polynomials into a single linear stream of packed `Field` carriers.\n///\n/// ## What this does\n/// - For each CRT limb `j` in `0..L`, it packs the coefficients of `poly[j]`\n///   with `pack::<A, BIT>` and appends all resulting carriers to `inputs`.\n/// - The packing layout (nibble-aligned width and `group` size) is taken from\n///   `packing_layout::<BIT>()` and must match what `pack` uses.\n///\n/// ## Determinism & order\n/// - Preserves a stable order: iterate `j = 0..L`, then for each `j` append\n///   carriers in ascending chunk index `i = 0..num_chunks`.\n/// - This ensures transcripts remain deterministic across runs.\n///\n/// ## Generics\n/// - `A`: polynomial degree (number of coefficients per polynomial).\n/// - `L`: number of CRT bases (polynomials).\n/// - `BIT`: per-coefficient bit bound used by the packing layout (compile-time).\n///\n/// ## Returns\n/// - The same `inputs` vector, extended with all carriers in deterministic order.\npub fn flatten<let A: u32, let L: u32, let BIT: u32>(\n    mut inputs: Vec<Field>,\n    poly: [Polynomial<A>; L],\n) -> Vec<Field> {\n    for j in 0..L {\n        // Pack its A coefficients into `num_chunks` carriers using the same BIT layout.\n        let packed = pack::<A, BIT>(poly[j].coefficients);\n\n        // Append carriers in-order to `inputs` to keep a stable transcript layout.\n        for i in 0..packed.len() {\n            inputs.push(packed.get(i));\n        }\n    }\n\n    // Return the extended input stream.\n    inputs\n}\n\n/// Pack `A` values into a `Vec<Field>` of carriers using the shared hex-aligned layout.\n///\n/// ## What this does\n/// - Computes `(nibble_bits, group)` via `packing_layout::<BIT>()`.\n/// - Encodes each value as a limb `digit = v + 2^nibble_bits` and concatenates\n///   limbs in base `radix = 2^(nibble_bits + 4)` (one extra nibble of headroom).\n/// - Packs up to `group` limbs per carrier (fits within BN254 254-bit capacity).\n/// - Pads the last, partial carrier with `digit = 2^nibble_bits` to keep a stable layout.\n///\n/// ## Determinism & order\n/// - Processes values in increasing index order and emits carriers in chunk order\n///   (`chunk = 0..num_chunks`). Padding is deterministic.\n///\n/// ## Generics\n/// - `A`: number of input values.\n/// - `BIT`: per-value bit bound; rounded up to `nibble_bits` by `packing_layout`.\n///\n/// ## Preconditions / Notes\n/// - Call with the raw coefficients whose magnitudes already satisfy the BIT bound\n///   (as enforced by the upstream range checks); `pack` performs the signed -> unsigned\n///   shift internally via `v + base`.\n/// - `group >= 1` is enforced by `packing_layout::<BIT>()`.\n/// - Padding with `digit = 2^nibble_bits` encodes `zero limb` consistently.\n///\n/// ## Returns\n/// - A `Vec<Field>` where each element is a concatenation of up to `group` limbs,\n///   suitable for hashing or transcript I/O.\npub fn pack<let A: u32, let BIT: u32>(values: [Field; A]) -> Vec<Field> {\n    // Layout parameters: nibble-aligned width and limbs-per-carrier group size.\n    let (nibble_bits, group) = packing_layout::<BIT>();\n\n    let base = 2.pow_32(nibble_bits as Field); // 2^nibble_bits\n    let radix = 2.pow_32((nibble_bits + 4) as Field); // 2^(nibble_bits + 4)\n\n    // Number of chunks to emit: ceil(A / group).\n    let num_chunks = (A + group - 1) / group;\n    let mut out = Vec::new();\n\n    // Process in fixed-size chunks of `group` limbs.\n    for chunk in 0..num_chunks {\n        // How many real values go into this chunk.\n        let remain = A - (chunk * group);\n        let take = if remain < group { remain } else { group };\n\n        // Build field element accumulator (big-endian concatenation in `radix`).\n        let mut acc = 0;\n        for i in 0..take {\n            let v = values[chunk * group + i];\n            acc = acc * radix + (v + base);\n        }\n\n        // Pad remaining limb slots with the canonical zero-limb `digit = base`.\n        for _ in 0..(group - take) {\n            acc = acc * radix + base;\n        }\n\n        out.push(acc);\n    }\n    out\n}\n\n/// Computes a cryptographic hash using the SAFE (Sponge API for Field Elements) protocol.\n///\n/// This is a convenience wrapper around the SAFE sponge API that handles the full\n/// lifecycle: initialization, absorption, squeezing, and finalization. It's designed\n/// for use in Fiat-Shamir challenge generation and commitment schemes within zero-knowledge circuits.\n///\n/// # Arguments\n/// * `domain_separator` - A 64-byte domain separator used to differentiate between\n///                        different protocol instances and prevent cross-protocol attacks.\n/// * `inputs` - Vector of field elements to be absorbed into the sponge.\n/// * `io_pattern` - A 2-element array encoding the I/O pattern:\n///                 - `io_pattern[0]`: Encoded ABSORB operation (MSB=1, lower 31 bits = length)\n///                 - `io_pattern[1]`: Encoded SQUEEZE operation (MSB=0, lower 31 bits = length)\n///\n/// # Returns\n/// A vector of field elements squeezed from the sponge, with length determined by\n/// the SQUEEZE operation in the IO pattern.\npub fn compute_safe(\n    domain_separator: [u8; 64],\n    inputs: Vec<Field>,\n    io_pattern: [u32; 2],\n) -> Vec<Field> {\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(inputs);\n    let digests = sponge.squeeze();\n    sponge.finish();\n\n    digests\n}\n\n#[test]\nfn test_flatten() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([1, 2, 3]); // degree 2\n    let poly2 = Polynomial::new([4, -16, 6]); // degree 2\n    let poly3 = Polynomial::new([-7, 8, 9]); // degree 2\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 4>(inputs, polynomials);\n\n    // Verify the flattened coefficients are in the correct positions\n    // Every value shifted 1 nibble incase of negative integers\n    assert(result.get(0) == 0x11121310101010101010101010101010101010101010101010101010101010);\n    assert(result.get(1) == 0x14001610101010101010101010101010101010101010101010101010101010); // -16 became 00 at  0x 14 00 16,\n    assert(result.get(2) == 0x09181910101010101010101010101010101010101010101010101010101010); // -7 became 09 at 0x 09 18 19(16 - 7 = 9)\n}\n\n#[test]\nfn test_flatten_big() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([\n        1791218451968394,\n        21888242871839275222246405745257275088548364400416034343698198265248580087864,\n        21888242871839275222246405745257275088548364400416034343698200542108324633466,\n        5430119342984413,\n        704811298945172,\n        8901715723925099,\n        21888242871839275222246405745257275088548364400416034343698203098124042812559,\n        21888242871839275222246405745257275088548364400416034343698200215091693880034,\n    ]);\n    let poly2 = Polynomial::new([\n        21888242871839275222246405745257275088548364400416034343698200314078269634250,\n        21888242871839275222246405745257275088548364400416034343698200967285641915872,\n        2909990636858607,\n        7896103832076587,\n        2078397209533893,\n        21888242871839275222246405745257275088548364400416034343698199792421452734531,\n        614400389245817,\n        8290314119277588,\n    ]);\n    let poly3 = Polynomial::new([\n        21888242871839275222246405745257275088548364400416034343698201373175279892906,\n        21888242871839275222246405745257275088548364400416034343698201087241869723721,\n        6768789983786188,\n        635797784303388,\n        7610153424227556,\n        4633893206538324,\n        2016269760615332,\n        21888242871839275222246405745257275088548364400416034343698201007080554428142,\n    ]);\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 54>(inputs, polynomials);\n\n    // Verify the flattened coefficients are in the correct positions\n    // Every value shifted 1 nibble incase of negative integers\n\n    // For the first index of result operation goes like this,\n\n    // First four index of poly1\n    // 1791218451968394,\n    // 21888242871839275222246405745257275088548364400416034343698198265248580087864,\n    // 21888242871839275222246405745257275088548364400416034343698200542108324633466,\n    // 5430119342984413,\n\n    // base + 1791218451968394 = 0x1065d1a8b8b718a\n    // base - 5921327228407753 = 0xeaf69591f3b037 (negative coefficient shifted)\n    // base - 3644467483862151 = 0xf30d604a3a9b79 (negative coefficient shifted)\n    // base + 5430119342984413 = 0x1134aaa2e86ccdd\n    assert(result.get(0) == 0x1065d1a8b8b718a0eaf69591f3b0370f30d604a3a9b791134aaa2e86ccdd);\n    assert(result.get(1) == 0x1028105ab1b789411fa010339db66b0fc220f1326bc8e0f1e3f4cc1e02e1);\n    assert(result.get(2) == 0x0f23dfbe7cd76c90f4901299312ddf10a569efe35acef11c0d76f005412b);\n    assert(result.get(3) == 0x107624a8f605dc50f0638a368960421022ecb3cf36b7911d73ff2c27ec14);\n    assert(result.get(4) == 0x0f6013a24e1b9a90f4fd2c158a08481180c2dba8af4cc10242413515171c);\n    assert(result.get(5) == 0x11b0964eb898ce411076805680b85410729c962da53a40f4b44412d0f6ed);\n}\n\n#[test]\nfn test_flatten_small() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([712345, 104857, 999999, 500001, 123, 654321, 77]);\n    let poly2 = Polynomial::new([1, 524287, 888888, 23456, 34567, 765432, 0]);\n    let poly3 = Polynomial::new([444444, 333333, 222222, 111111, 987654, 246810, 13579]);\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 20>(inputs, polynomials);\n\n    assert(result.get(0) == 0x1ade991199991f423f17a12110007b19fbf110004d100000100000100000);\n    assert(result.get(1) == 0x10000117ffff1d9038105ba01087071badf8100000100000100000100000);\n    assert(result.get(2) == 0x16c81c15161513640e11b2071f120613c41a10350b100000100000100000);\n}\n\n#[test]\nfn test_safe_hashing_with_safe_helper() {\n    // Verifies basic hash functionality with a simple ABSORB(3) + SQUEEZE(1) pattern.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice(&[1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let digests1 = compute_safe(domain_separator, elements, io_pattern);\n\n    assert(digests1.len() == 1);\n    assert(digests1.get(0) != 0);\n\n    // Test determinism\n    let digests2 = compute_safe(domain_separator, elements, io_pattern);\n\n    assert(digests2.len() == 1);\n    assert(digests2.get(0) != 0);\n    assert(digests2.get(0) == digests1.get(0));\n}\n\n#[test]\nfn test_pack() {\n    // Test pack function directly with small values\n    let values = [1, 2, 3, 4];\n    let packed = pack::<4, 4>(values);\n\n    // With BIT=4, nibble_bits=4, group should be floor(254/(4+4)) = 31\n    // So all 4 values should fit in one carrier\n    assert(packed.len() >= 1);\n\n    // Test with negative values\n    let values_neg = [-1, 2, -3, 4];\n    let packed_neg = pack::<4, 4>(values_neg);\n    assert(packed_neg.len() >= 1);\n}\n\n#[test]\nfn test_pack_single_value() {\n    // Test packing a single value\n    let values = [42];\n    let packed = pack::<1, 8>(values);\n    assert(packed.len() == 1);\n    assert(packed.get(0) != 0);\n}\n\n#[test]\nfn test_pack_determinism() {\n    // Test that packing is deterministic\n    let values = [10, 20, 30];\n    let packed1 = pack::<3, 8>(values);\n    let packed2 = pack::<3, 8>(values);\n\n    assert(packed1.len() == packed2.len());\n    for i in 0..packed1.len() {\n        assert(packed1.get(i) == packed2.get(i));\n    }\n}\n","path":"/Users/omardesogus/Projects/Enclave/enclave/circuits/lib/src/math/helpers.nr"},"81":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse keccak256::keccak256;\nuse poseidon::poseidon2_permutation;\n\n/// SAFE (Sponge API for Field Elements)\n///\n/// This module provides a complete implementation of the SAFE API in Noir as defined in:\n/// \"SAFE (Sponge API for Field Elements) - A Toolbox for ZK Hash Applications\"\n/// see https://hackmd.io/bHgsH6mMStCVibM_wYvb2w#22-Sponge-state for more details.\n///\n/// SAFE provides a unified interface for cryptographic sponge functions that can be\n/// instantiated with various permutations to create hash functions, MACs, authenticated\n/// encryption schemes, and other cryptographic primitives for ZK proof systems.\n///\n/// This implementation follows the SAFE specification exactly, providing:\n/// - Complete API: START, ABSORB, SQUEEZE, FINISH operations.\n/// - Full security: Domain separation, tag computation, IO pattern validation.\n/// - Poseidon2 integration: Field-friendly permutation for ZK systems.\n/// - Specification compliance: All operations follow SAFE spec 2.4 exactly.\n/// - Natural API design: Variable-length inputs, automatic length detection from IO patterns.\n///\n/// # API Design\n///\n/// The API is designed for natural usage while maintaining type safety:\n/// - `absorb(input: [Field])`: Accepts variable-length arrays, no padding required.\n/// - `squeeze()`: Returns a vector with field element(s).\n/// - IO patterns automatically determine operation lengths for validation.\n\n/// Rate parameter for the sponge construction (number of field elements that can be absorbed per permutation call).\nglobal RATE: u32 = 3;\n\n/// Capacity parameter for the sponge construction (security parameter, typically 1-2 field elements).\nglobal CAPACITY: u32 = 1;\n\n/// Total state size (rate + capacity) in field elements.\nglobal STATE_SIZE: u32 = RATE + CAPACITY;\n\n/// IO Pattern encoding constants (from SAFE spec 2.3).\n///\n/// These constants are used for encoding operation types in the 32-bit word format:\n/// - MSB set to 1 for ABSORB operations\n/// - MSB set to 0 for SQUEEZE operations\n\n/// Flag for ABSORB operations (MSB = 1)\nglobal ABSORB_FLAG: u32 = 0x80000000;\n\n/// Flag for SQUEEZE operations (MSB = 0)\nglobal SQUEEZE_FLAG: u32 = 0x00000000;\n\n/// SAFE Sponge State (following spec 2.2)\n///\n/// The sponge state consists of the permutation state, tag, position counters,\n/// and IO pattern tracking as defined in the SAFE specification.\n///\n/// # Generic Parameters\n/// - `L`: The length of the IO pattern array\n///\n/// # Fields\n/// - `state`: Permutation state V in F^n (rate + capacity elements)\n/// - `tag`: Parameter tag T used for instance differentiation\n/// - `absorb_pos`: Current absorb position (<= n-c)\n/// - `squeeze_pos`: Current squeeze position (<= n-c)\n/// - `io_pattern`: Expected IO pattern for validation (encoded 32-bit words)\n/// - `io_count`: Current operation count for pattern tracking\npub struct SafeSponge<let L: u32> {\n    /// Permutation state V in F^n (rate + capacity elements).\n    state: [Field; STATE_SIZE],\n    /// Parameter tag T used for instance differentiation.\n    tag: Field,\n    /// Current absorb position (<= n-c).\n    absorb_pos: u32,\n    /// Current squeeze position (<= n-c).\n    squeeze_pos: u32,\n    /// Expected IO pattern for validation.\n    io_pattern: [u32; L],\n    /// Current operation count for pattern tracking (spec 2.4: io_count).\n    io_count: u32,\n}\n\nimpl<let L: u32> SafeSponge<L> {\n    /// Initializes a new SAFE sponge instance with the given IO pattern and domain separator (following spec 2.4).\n    ///\n    /// # Arguments\n    /// - `io_pattern`: Array of 32-bit encoded operations defining the expected sequence of ABSORB/SQUEEZE calls.\n    ///               Each word has MSB=1 for ABSORB operations, MSB=0 for SQUEEZE operations.\n    /// - `domain_separator`: 64-byte domain separator for cross-protocol security.\n    ///\n    /// # Returns\n    /// A new `SafeSponge` instance with initialized state\n    pub fn start(io_pattern: [u32; L], domain_separator: [u8; 64]) -> SafeSponge<L> {\n        // Compute tag from IO pattern and domain separator (spec 2.3).\n        let tag = compute_tag(io_pattern, domain_separator);\n\n        let mut state = [0; STATE_SIZE];\n        // Initialize capacity with tag (spec 2.4).\n        // Add T to the first 128 bits of the state.\n        state[0] = tag;\n\n        SafeSponge { state, tag, absorb_pos: 0, squeeze_pos: 0, io_pattern, io_count: 0 }\n    }\n\n    /// Absorbs field elements into the sponge state, interleaving permutation calls as needed (following spec 2.4).\n    ///\n    /// The number of elements to absorb is automatically validated against the IO pattern.\n    /// This method accepts variable-length arrays, making it natural to use without padding.\n    ///\n    /// # Arguments\n    /// - `input`: Array of field elements to absorb (variable length, must match IO pattern)\n    pub fn absorb(&mut self, input: Vec<Field>) {\n        let length = input.len() as u32;\n\n        // Validate against IO pattern.\n        assert(self.io_count < L);\n\n        // Parse expected operation from io_pattern (encoded word)\n        let expected_encoded_word = self.io_pattern[self.io_count];\n        let is_expected_absorb = (expected_encoded_word & ABSORB_FLAG) != 0;\n        let expected_length = expected_encoded_word & 0x7FFFFFFF;\n\n        // Validate operation type and length\n        assert(is_expected_absorb, \"Expected ABSORB operation\");\n        assert(expected_length == length, \"Length mismatch\");\n\n        // Process each element naturally (no unnecessary iterations).\n        for i in 0..length {\n            // If absorb_pos == (n-c) then permute and reset (spec 2.4).\n            if self.absorb_pos == RATE {\n                // n-c = RATE.\n                self.state = self.permute();\n                self.absorb_pos = 0;\n            }\n\n            // Add X[i] to state at absorb_pos (spec 2.4).\n            // Note: absorb_pos is the rate position, not capacity position.\n            self.state[self.absorb_pos + CAPACITY] =\n                self.state[self.absorb_pos + CAPACITY] + input.get(i);\n            self.absorb_pos += 1;\n        }\n\n        // Verify that the encoded word matches the expected pattern.\n        let encoded_word = ABSORB_FLAG | length;\n        assert(encoded_word == expected_encoded_word);\n\n        self.io_count += 1;\n\n        // Force permute at start of next SQUEEZE (spec 2.4).\n        self.squeeze_pos = RATE;\n    }\n\n    /// Extracts field elements from the sponge state, interleaving permutation calls as needed (following spec 2.4).\n    ///\n    /// The number of elements to squeeze is automatically determined from the IO pattern.\n    pub fn squeeze(&mut self) -> Vec<Field> {\n        // Validate against IO pattern.\n        assert(self.io_count < L);\n\n        // Parse expected operation from io_pattern (encoded word)\n        let expected_encoded_word = self.io_pattern[self.io_count];\n        let is_expected_squeeze = (expected_encoded_word & ABSORB_FLAG) == 0;\n        let length = expected_encoded_word & 0x7FFFFFFF;\n\n        // Validate operation type\n        assert(is_expected_squeeze, \"Expected SQUEEZE operation\");\n\n        let mut output = Vec::new();\n\n        // SQUEEZE implementation following spec 2.4.\n        // If length==0, loop won't execute (spec 2.4).\n        for _ in 0..length {\n            // If squeeze_pos==(n-c) then permute and reset (spec 2.4).\n            if self.squeeze_pos == RATE {\n                // n-c = RATE.\n                self.state = self.permute();\n                self.squeeze_pos = 0;\n                self.absorb_pos = 0;\n            }\n            // Set Y[i] to state element at squeeze_pos (spec 2.4).\n            output.push(self.state[self.squeeze_pos + CAPACITY]);\n            self.squeeze_pos += 1;\n        }\n\n        // Verify that the encoded word matches the expected pattern.\n        let encoded_word = SQUEEZE_FLAG | length;\n        assert(encoded_word == expected_encoded_word);\n\n        self.io_count += 1;\n        output\n    }\n\n    /// Finalizes the sponge instance, verifying that all expected operations have been performed and clearing the internal state for security (following spec 2.4).\n    ///\n    /// This function is used to ensure that the sponge instance has been used correctly and to prevent information leakage.\n    pub fn finish(&mut self) {\n        // Check that io_count equals the length of the IO pattern expected (spec 2.4).\n        assert(self.io_count == L, \"IO pattern not completed\");\n\n        // Erase the state and its variables (spec 2.4).\n        self.state = [0; STATE_SIZE];\n        self.absorb_pos = 0;\n        self.squeeze_pos = 0;\n        self.io_count = 0;\n    }\n\n    /// Permute the state using Poseidon2 (following spec 2.4).\n    ///\n    /// Applies the Poseidon2 permutation to the current state.\n    /// This is the core cryptographic primitive of the sponge construction.\n    ///\n    /// # Returns\n    /// New state after permutation\n    fn permute(self) -> [Field; STATE_SIZE] {\n        poseidon2_permutation(self.state, STATE_SIZE)\n    }\n}\n\n/// Computes a unique tag for a sponge instance based on its IO pattern and domain separator.\n/// The tag is used to ensure that distinct instances behave like distinct functions.\n///\n/// # Arguments\n/// - `io_pattern`: Array of 32-bit encoded operations defining the sponge's usage pattern.\n///               Each word has MSB=1 for ABSORB operations, MSB=0 for SQUEEZE operations.\n/// - `domain_separator`: 64-byte domain separator for cross-protocol security.\n///\n/// # Returns\n/// A field element representing the 128-bit tag.\npub fn compute_tag<let L: u32>(io_pattern: [u32; L], domain_separator: [u8; 64]) -> Field {\n    // Step 1: Parse and aggregate consecutive operations of the same type\n    let mut encoded_words = [0; L]; // Support up to L operations.\n    let mut word_count = 0;\n    let mut current_absorb_sum = 0;\n    let mut current_squeeze_sum = 0;\n    let mut last_was_absorb = false;\n\n    for i in 0..L {\n        if io_pattern[i] > 0 {\n            // Parse operation type from MSB and length from lower 31 bits\n            let is_absorb = (io_pattern[i] & ABSORB_FLAG) != 0;\n            let length = io_pattern[i] & 0x7FFFFFFF; // Clear MSB to get length\n\n            if is_absorb {\n                if last_was_absorb {\n                    // Aggregate consecutive ABSORB operations\n                    current_absorb_sum += length;\n                } else {\n                    // Start new ABSORB sequence\n                    if current_squeeze_sum > 0 {\n                        // Flush previous SQUEEZE sequence\n                        encoded_words[word_count] = SQUEEZE_FLAG | current_squeeze_sum;\n                        word_count += 1;\n                        current_squeeze_sum = 0;\n                    }\n                    current_absorb_sum = length;\n                }\n                last_was_absorb = true;\n            } else {\n                if !last_was_absorb {\n                    // Aggregate consecutive SQUEEZE operations\n                    current_squeeze_sum += length;\n                } else {\n                    // Start new SQUEEZE sequence\n                    if current_absorb_sum > 0 {\n                        // Flush previous ABSORB sequence\n                        encoded_words[word_count] = ABSORB_FLAG | current_absorb_sum;\n                        word_count += 1;\n                        current_absorb_sum = 0;\n                    }\n                    current_squeeze_sum = length;\n                }\n                last_was_absorb = false;\n            }\n        }\n    }\n\n    // Flush remaining operations\n    if current_absorb_sum > 0 {\n        encoded_words[word_count] = ABSORB_FLAG | current_absorb_sum;\n        word_count += 1;\n    }\n    if current_squeeze_sum > 0 {\n        encoded_words[word_count] = SQUEEZE_FLAG | current_squeeze_sum;\n        word_count += 1;\n    }\n\n    // Step 2: Serialize to byte string and append domain separator (following SAFE spec 2.3).\n    // Buffer is 256 bytes: max 192 bytes for IO pattern (48 words) + 64 bytes for domain separator.\n    // Note: We must use a fixed-size array because Noir's keccak256 requires [u8; N], not Vec<u8>.\n    let max_io_pattern_bytes: u32 = 192; // 256 - 64 (domain separator)\n    let io_pattern_bytes = word_count * 4;\n    assert(\n        io_pattern_bytes <= max_io_pattern_bytes,\n        \"IO pattern too large: max 48 aggregated words supported\",\n    );\n\n    let mut input_bytes = [0u8; 256];\n    let mut byte_count: u32 = 0;\n\n    // Serialize encoded words to bytes (big-endian as per SAFE spec).\n    // Note: Noir requires compile-time loop bounds, so we iterate over L (the array size)\n    // instead of word_count (runtime value). The condition `i < word_count` ensures we only\n    // process valid encoded words. This is safe because word_count <= L always holds\n    // (we can have at most L encoded words from L input operations).\n    for i in 0..L {\n        if i < word_count {\n            let word = encoded_words[i];\n            input_bytes[byte_count] = (word >> 24) as u8;\n            input_bytes[byte_count + 1] = (word >> 16) as u8;\n            input_bytes[byte_count + 2] = (word >> 8) as u8;\n            input_bytes[byte_count + 3] = word as u8;\n            byte_count += 4;\n        }\n    }\n\n    // Append full 64-byte domain separator.\n    for i in 0..64 {\n        input_bytes[byte_count] = domain_separator[i];\n        byte_count += 1;\n    }\n\n    // Step 3: Hash with Keccak-256 and truncate to 128 bits.\n    // Note: The SAFE spec uses SHA3-256, but we use Keccak-256 for Noir compatibility.\n    // Keccak-256 differs from SHA3-256 in padding, but both provide equivalent security.\n    let hash_bytes = keccak256(input_bytes, byte_count);\n\n    // Convert first 128 bits (16 bytes) to field element.\n    let mut tag_value: Field = 0;\n    for i in 0..16 {\n        tag_value = tag_value * 256 + (hash_bytes[i] as Field);\n    }\n\n    tag_value\n}\n\n#[test]\nfn test_safe_hashing() {\n    // Verifies basic hash functionality with a simple ABSORB(3) + SQUEEZE(1) pattern.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice(&[1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(elements);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(elements);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_merkle_node() {\n    // Verifies SAFE can be used for Merkle tree node hashing with pattern ABSORB(1) + ABSORB(1) + SQUEEZE(1).\n    // Tests the ability to absorb multiple inputs before squeezing output.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let left = Vec::from_slice([123]);\n    let right = Vec::from_slice([456]);\n\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(left);\n    sponge.absorb(right);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(left);\n    sponge2.absorb(right);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_commitment_scheme() {\n    // Verifies SAFE can be used for commitment schemes with pattern ABSORB(3) + SQUEEZE(1).\n    // Tests the ability to create deterministic commitments from multiple field elements.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let values = Vec::from_slice([10, 20, 30]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(values);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(values);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_domain_separation() {\n    // Verifies that different domain separators produce different outputs for the same input.\n    // This is crucial for cross-protocol security and preventing collisions between different applications.\n    let elements = Vec::from_slice([1, 2, 3]);\n    let domain1 = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let domain2 = [\n        0x41, 0x42, 0x43, 0x45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n\n    let mut sponge1 = SafeSponge::start(io_pattern, domain1);\n    sponge1.absorb(elements);\n    let output1 = sponge1.squeeze();\n    sponge1.finish();\n\n    let mut sponge2 = SafeSponge::start(io_pattern, domain2);\n    sponge2.absorb(elements);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output1.len() == 1);\n    assert(output2.len() == 1);\n    assert(output1.get(0) != output2.get(0)); // Different domain separators should produce different outputs\n}\n\n#[test]\nfn test_multiple_squeeze() {\n    // Verifies that multiple field elements can be squeezed in a single operation.\n    // Tests pattern ABSORB(3) + SQUEEZE(2) to ensure proper state management.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice([1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(2)\n    let io_pattern = [0x80000003, 0x00000002];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(elements);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 2);\n    assert(output.get(0) != 0);\n    assert(output.get(1) != 0);\n    assert(output.get(0) != output.get(1)); // Different squeeze outputs should be different\n}\n\n#[test]\nfn test_zero_length_operations() {\n    // Verifies that zero-length ABSORB and SQUEEZE operations are handled correctly.\n    // Tests pattern ABSORB(0) + SQUEEZE(1) to ensure proper state transitions.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Pattern: ABSORB(0), SQUEEZE(1)\n    let io_pattern = [0x80000000, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(Vec::new());\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n}\n\n#[test]\nfn test_tag_computation() {\n    // Verifies the tag computation algorithm using the example from the SAFE specification.\n    // Pattern: ABSORB(3), ABSORB(3), SQUEEZE(3)\n    // Should aggregate to: ABSORB(6), SQUEEZE(3)\n    // Encoded as: [0x80000006, 0x00000003]\n    // Tests determinism and pattern differentiation.\n\n    let io_pattern = [0x80000003, 0x80000003, 0x00000003];\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test determinism\n    let tag2 = compute_tag(io_pattern, domain_separator);\n    assert(tag == tag2);\n\n    // Test that different patterns produce different tags\n    let io_pattern2 = [0x80000003, 0x00000003]; // ABSORB(3), SQUEEZE(3) - different pattern\n    let tag3 = compute_tag(io_pattern2, domain_separator);\n    assert(tag != tag3);\n}\n\n#[test]\nfn test_tag_computation_debug() {\n    println(\"=== SAFE Tag Computation Debug Test ===\");\n\n    // Test your specific pattern [2, 2, 2] (ABSORB(2), SQUEEZE(2), ABSORB(2))\n    let io_pattern = [0x80000002, 0x00000002, 0x80000002];\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    println(f\"Testing pattern: {io_pattern}\");\n    println(\n        f\"Expected to aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(2)\",\n    );\n    println(\n        f\"Expected encoded words: [0x80000002, 0x00000002, 0x80000002]\",\n    );\n    println(\"\");\n\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    println(f\"=== Expected Rust Output ===\");\n    println(\"Pattern [2, 2, 2] (ABSORB(2), SQUEEZE(2), ABSORB(2))\");\n    println(\"Domain separator: 0x41424344...\");\n    println(\"Tag: 0xce3bb9ee4b2d41c42e9cdda38afe8b6a\");\n    println(\"\");\n\n    println(f\"=== Noir Output ===\");\n    println(f\"Tag: {tag}\");\n    println(\"\");\n\n    println(\"Compare the tag values above with Rust script!\");\n}\n\n#[test]\nfn test_consecutive_absorb_aggregation() {\n    // Test that consecutive ABSORB operations are properly aggregated\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1) should aggregate to ABSORB(2), SQUEEZE(1)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), ABSORB(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001];\n\n    // This should aggregate to: ABSORB(2), SQUEEZE(1) = [0x80000002, 0x00000001]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag ABSORB(2), SQUEEZE(1)\n    let aggregated_pattern = [0x80000002, 0x00000001];\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(tag == aggregated_tag, \"Consecutive ABSORB operations should aggregate to the same tag\");\n\n    // Test that a different pattern produces a different tag\n    let different_pattern = [0x80000001, 0x00000001, 0x80000001]; // ABSORB(1), SQUEEZE(1), ABSORB(1)\n    let different_tag = compute_tag(different_pattern, domain_separator);\n\n    // This should be different because it doesn't have consecutive ABSORB operations\n    assert(tag != different_tag, \"Different patterns should produce different tags\");\n\n    println(\"=== Consecutive ABSORB Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x80000001, 0x00000001] (ABSORB(1), ABSORB(1), SQUEEZE(1))\",\n    );\n    println(\n        f\"Aggregated pattern: [0x80000002, 0x00000001] (ABSORB(2), SQUEEZE(1))\",\n    );\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Different pattern tag: {different_tag}\");\n}\n\n#[test]\nfn test_consecutive_squeeze_aggregation() {\n    // Test that consecutive SQUEEZE operations are properly aggregated\n    // Pattern: ABSORB(1), SQUEEZE(1), SQUEEZE(1) should aggregate to ABSORB(1), SQUEEZE(2)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), SQUEEZE(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x00000001, 0x00000001];\n\n    // This should aggregate to: ABSORB(1), SQUEEZE(2) = [0x80000001, 0x00000002]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag ABSORB(1), SQUEEZE(2)\n    let aggregated_pattern = [0x80000001, 0x00000002];\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(\n        tag == aggregated_tag,\n        \"Consecutive SQUEEZE operations should aggregate to the same tag\",\n    );\n\n    // Test that a different pattern produces a different tag\n    let different_pattern = [0x80000001, 0x00000001, 0x80000001]; // ABSORB(1), SQUEEZE(1), ABSORB(1)\n    let different_tag = compute_tag(different_pattern, domain_separator);\n\n    // This should be different because it doesn't have consecutive SQUEEZE operations\n    assert(tag != different_tag, \"Different patterns should produce different tags\");\n\n    println(\"=== Consecutive SQUEEZE Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x00000001, 0x00000001] (ABSORB(1), SQUEEZE(1), SQUEEZE(1))\",\n    );\n    println(\n        f\"Aggregated pattern: [0x80000001, 0x00000002] (ABSORB(1), SQUEEZE(2))\",\n    );\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Different pattern tag: {different_tag}\");\n}\n\n#[test]\nfn test_mixed_consecutive_aggregation() {\n    // Test that both consecutive ABSORB and SQUEEZE operations are properly aggregated\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1)\n    // Should aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(1)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001, 0x00000001, 0x80000001];\n\n    // This should aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(1) = [0x80000002, 0x00000002, 0x80000001]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag\n    let aggregated_pattern = [0x80000002, 0x00000002, 0x80000001]; // ABSORB(2), SQUEEZE(2), ABSORB(1)\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(tag == aggregated_tag, \"Mixed consecutive operations should aggregate to the same tag\");\n\n    println(\"=== Mixed Consecutive Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x80000001, 0x00000001, 0x00000001, 0x80000001]\",\n    );\n    println(\n        f\"  (ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1))\",\n    );\n    println(f\"Aggregated pattern: [0x80000002, 0x00000002, 0x80000001]\");\n    println(f\"  (ABSORB(2), SQUEEZE(2), ABSORB(1))\");\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n}\n\n#[test]\nfn test_large_io_pattern() {\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Create pattern with 48 alternating ABSORB(1) and SQUEEZE(1) operations\n    // This is the maximum supported (48 words * 4 bytes = 192 bytes, leaving 64 for domain separator)\n    let mut io_pattern = [0u32; 48];\n    for i in 0..48 {\n        if i % 2 == 0 {\n            io_pattern[i] = ABSORB_FLAG | 1; // ABSORB(1)\n        } else {\n            io_pattern[i] = SQUEEZE_FLAG | 1; // SQUEEZE(1)\n        }\n    }\n\n    let tag = compute_tag(io_pattern, domain_separator);\n    assert(tag != 0);\n}\n\n#[test]\nfn test_domain_separator_not_truncated() {\n    // This test verifies that the domain separator is always included in the tag computation,\n    // even for large IO patterns. If the domain separator were truncated, different domain\n    // separators would produce the same tag for large patterns.\n\n    let domain_separator_a = [\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41,\n    ]; // All 'A's\n\n    let domain_separator_b = [\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42,\n    ]; // All 'B's\n\n    // Create pattern with 48 alternating operations (max supported: 192 bytes of IO pattern)\n    let mut io_pattern = [0u32; 48];\n    for i in 0..48 {\n        if i % 2 == 0 {\n            io_pattern[i] = ABSORB_FLAG | 1;\n        } else {\n            io_pattern[i] = SQUEEZE_FLAG | 1;\n        }\n    }\n\n    let tag_a = compute_tag(io_pattern, domain_separator_a);\n    let tag_b = compute_tag(io_pattern, domain_separator_b);\n\n    // Tags MUST be different because domain separators are different.\n    // If they were the same, it would mean the domain separator was truncated/ignored.\n    assert(tag_a != tag_b, \"Domain separator must affect tag even for large IO patterns\");\n}\n","path":"/Users/omardesogus/Projects/Enclave/enclave/circuits/lib/src/math/safe.nr"}},"expression_width":{"Bounded":{"width":4}}}