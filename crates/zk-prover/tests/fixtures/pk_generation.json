{
  "noir_version": "1.0.0-beta.15+83245db91dcf63420ef4bcbbd85b98f397fee663",
  "hash": "12232726796948057982",
  "abi": {
    "parameters": [
      {
        "name": "a",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "struct",
            "path": "lib::math::polynomial::Polynomial",
            "fields": [{ "name": "coefficients", "type": { "kind": "array", "length": 512, "type": { "kind": "field" } } }]
          }
        },
        "visibility": "public"
      },
      {
        "name": "eek",
        "type": {
          "kind": "struct",
          "path": "lib::math::polynomial::Polynomial",
          "fields": [{ "name": "coefficients", "type": { "kind": "array", "length": 512, "type": { "kind": "field" } } }]
        },
        "visibility": "private"
      },
      {
        "name": "sk",
        "type": {
          "kind": "struct",
          "path": "lib::math::polynomial::Polynomial",
          "fields": [{ "name": "coefficients", "type": { "kind": "array", "length": 512, "type": { "kind": "field" } } }]
        },
        "visibility": "private"
      },
      {
        "name": "e_sm",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "struct",
            "path": "lib::math::polynomial::Polynomial",
            "fields": [{ "name": "coefficients", "type": { "kind": "array", "length": 512, "type": { "kind": "field" } } }]
          }
        },
        "visibility": "private"
      },
      {
        "name": "r1is",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "struct",
            "path": "lib::math::polynomial::Polynomial",
            "fields": [{ "name": "coefficients", "type": { "kind": "array", "length": 1023, "type": { "kind": "field" } } }]
          }
        },
        "visibility": "private"
      },
      {
        "name": "r2is",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "struct",
            "path": "lib::math::polynomial::Polynomial",
            "fields": [{ "name": "coefficients", "type": { "kind": "array", "length": 511, "type": { "kind": "field" } } }]
          }
        },
        "visibility": "private"
      },
      {
        "name": "pk0is",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "struct",
            "path": "lib::math::polynomial::Polynomial",
            "fields": [{ "name": "coefficients", "type": { "kind": "array", "length": 512, "type": { "kind": "field" } } }]
          }
        },
        "visibility": "private"
      },
      {
        "name": "pk1is",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "struct",
            "path": "lib::math::polynomial::Polynomial",
            "fields": [{ "name": "coefficients", "type": { "kind": "array", "length": 512, "type": { "kind": "field" } } }]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": {
      "abi_type": { "kind": "tuple", "fields": [{ "kind": "field" }, { "kind": "field" }, { "kind": "field" }] },
      "visibility": "public"
    },
    "error_types": {
      "12469291177396340830": { "error_kind": "string", "string": "call to assert_max_bit_size" },
      "15711739108859631478": { "error_kind": "string", "string": "Public key equation 2 failed" },
      "16226075151901316264": { "error_kind": "string", "string": "Public key equation 1 failed" }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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GO4Y7hjuGO4Y7ph7xy819eutv9jU+2jxVvFo89bk0eGtxaPmrfeODzv1660RPFq8VTzavDV5dHhr8ah5K3cs7ljcsbhjccfijsUdizsWdyzuWNwh7hB3iDvEHeIOcYe4Q9wh7hB3bO7Y3LG5Y3PH5o7NHZs7NnfQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQ+aLzReeLzhedLzpfdL7ofNH5ovNF54vOF50vOl90vuh80fmi80Xni84XnS86X3S+6HzR+aLzReeLzhedLzpfdL7ofNH5ovNF54vOF50vOl90vuh80fmi80Xni84XnS86X3S+6HzR+aLzReeLzhedLzpfdL7ofNH5ovNF54vOF50vOl90vuh80fmi80Xni84XnS86X3S+6HzR+aLzReeLzhedLzpfdL7ofNH5ovNF54vOF50vOl90vuh80fmi80Xni84XnS86X3S+6HzR+aLzReeLzhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0fmm803nm843nW8633S+6XzT+abzTeebzjedbzrfdL7pfNP5pvNN55vON51vOt90vul80/mm803nm843nW8633S+6XzT+abzTeebzjedbzrfdL7pfNP5pvNN55vON51vOt90vul80/mm803nm843nW8633S+6XzT+abzTeebzjedbzrfdL7pfNP5pvNN55vON51vOt90vul80/mm803nm843nW8633S+6XzT+abzTeebzjedbzrfdL7pfNP5pvNN55vON51vOt90vul80/mm803nm843nSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedHzo/dH7o/ND5ofND54fOD50fOj90fuj80Pmh80Pnh84PnR86P3R+6PzQ+aHzQ+eHzg+dHzo/dH7o/ND5ofND54fOD50fOj90fuj80Pmh80Pnh84PnR86P3R+6PzQ+aHzQ+eHzg+dHzo/dH7o/ND5ofND54fOD50fOj90fuj80Pmh80Pnh84PnR86P3R+6PzQ+aHzQ+eHzg+dHzo/dH7o/ND5ofND54fOD50fOj90fuj80Pmh80Pnh84PnR86P3R+6PzQ+aHzQ+eHzg+dHzo/dH7o/NB50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nT+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dzO9dzO9dzO9dzO9dzO9dzO9dzO9dzO9dzO9dzO9dzO9dzO9dzO9dzO9dzO9dzO9dzO9dzO9dzO9dzO9QR3LO5Y3LG4Y3HH4o7FHYs7Fncs7ljcIe4Qd4g7xB3iDnGHuEPcIe4Qd2zu2NyxuWNzx+aOzR2bOzZ3bO7Y3JHckdyR3JHckdyR3JHckdyR3JHccbjjcMfhjsMdhzsOdxzuONxxuONwR3FHcUdxR3FHcUdxR3FHcUdxR3FHc0dzR3NHc0dzR3NHc0dzR3NHc8dwx3DHcMdwx3DHcMdwx3DHcAed4+GEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTng44eGEhxMeTni4jYfbeLiNh9t4uI2H23i4jYfbeLiNh9t4uI2H23i4jYfbeLiNh9t4uI2H23i4jYfbeLiNh9t4uI2H23i4jYfbeLiNh9t4uI2H23i4jYfbeLiNh9t4uI2H23i4jYfbeLiNh9t4uI2H23i4jYfbeLiNh9t4uI2H23i4jYfbeLiNh9t4uI2H23i4jYfbeLiNh9t4uI2H23i4jYfbeLiNh9t4uI2H23i4jYfbeLiNh9t4uI2H23i4jYfbeLiNh9t4uI2H23i4jYfbeLiNh9t4uI2H23i4jYfbeLiNh9t4uI2H23i4jYfbeLiNh9t4uI2H23i4/cvDrf3rUfHot/8dq349mvfRLw/3662/PNz7aPFW8Wjz1uTR4a3Fo+atcx/93vnHW3/v/H20eKt4tHlr8ujw1uJR81buWNyxuGNxx+KOxR2LOxZ3LO5Y3LG4Q9wh7hB3iDvEHeIOcYe4Q9wh7tjcsbljc8fmjs0dmzs2d2zu2NyxuSO5I7kjuSO5I7kjuSO5I7kjuSO543DH4Y7DHYc7Dncc7jjccbjjcMfhjuKO4o7ijuKO4o7ijuKO4o7ijuKO5o7mjuaO5o7mjuaO5o7mjuaO5o7hjuGO4Y7hjuGO4Q46DzoPOg86X3S+6HzR+aLzReeLzhedLzpfdL7ofNH5ovNF54vOF50vOl90vuh80fmi80Xni84XnS86X3S+6HzR+aLzReeLzhedLzpfdL7ofNH5ovNF54vOF50vOl90vuh80fmi80Xni84XnS86X3S+6HzR+aLzReeLzhedLzpfdL7ofNH5ovNF54vOF50vOl90vuh80fmi80Xni84XnS86X3S+6HzR+aLzReeLzhedLzpfdL7ofNH5ovNF54vOF50vOl90vuh80fmi80Xni84XnS86X3S+6HzR+aJz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOhedi85F56Jz0bnoXHQuOt90vul80/mm803nm843nW8633S+6XzT+abzTeebzjedbzrfdL7pfNP5pvNN55vON51vOt90vul80/mm803nm843nW8633S+6XzT+abzTeebzjedbzrfdL7pfNP5pvNN55vON51vOt90vul80/mm803nm843nW8633S+6XzT+abzTeebzjedbzrfdL7pfNP5pvNN55vON51vOt90vul80/mm803nm843nW8633S+6XzT+abzTeebzjedbzrfdL7pfNP5pvNN55vON51vOt90vul80/mm86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzpPOk86TzQ+eHzg+dHzo/dH7o/ND5ofND54fOD50fOj90fuj80Pmh80Pnh84PnR86P3R+6PzQ+aHzQ+eHzg+dHzo/dH7o/ND5ofND54fOD50fOj90fuj80Pmh80Pnh84PnR86P3R+6PzQ+aHzQ+eHzg+dHzo/dH7o/ND5ofND54fOD50fOj90fuj80Pmh80Pnh84PnR86P3R+6PzQ+aHzQ+eHzg+dHzo/dH7o/ND5ofND54fOD50fOj90fuj80Pmh80Pnh84PnR86P3R+6PzQ+aHzQ+eHzg+dHzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOi86LzovOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86bzpvOm86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86HzofOh86n9t5PrfzfG7n+dzO87md53M7z+d2ns/tPJ/beT6383xu5/nczvO5nedzO8/ndp7P7Tyf23k+t/N8buf53M7zCe5Y3LG4Y3HH4o7FHYs7Fncs7ljcsbhD3CHuEHeIO8Qd4g5xh7hD3CHu2NyxuWNz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cUdxR3FHc0dzR3NHc0dzR3NHc0dzR3NHc8dwx3DHcMdwx3DHcMdwx3DHcMfcO355uF9v/eXh3keLt4pHm7cmjw5vLR41b713/PJwH2+N4NHireLR5q3Jo8Nbi0fNW7ljccfijsUdizsWdyzuWNyxuGNxx+IOcYe4Q9wh7hB3iDvEHeIOcYe4Y3PH5o7NHZs76HzR+aLzReeLzhedLzpfdL7ofNH5ovNF54vOF50vOl90vuh80fmi80Xni84XnS86X3S+6HzR+aLzReeLzhedLzpfdL7ofNH5ovNF54vOF50vOl90vuh80fmi80Xni84XnS86X3S+6HzR+aLzReeLzhedLzpfdC46F52LzkXnonPRuehcdC46F52LzkXnonPRuehcdC46F52LzkXnonPRuehcdC46F52LzkXnonPRuehcdC46F52LzkXnonPRuehcdC46F52LzkXnonPRuehcdC46F52LzkXnonPRuehcdC46F52LzkXnonPRuehcdC46F52LzkXnonPRuehcdC46F52LzkXnonPRuehcdC46F52LzkXnonPRuehcdC46F52LzkXnonPRuehcdC46F52LzkXnm843nW8633S+6XzT+abzTeebzjedbzrfdL7pfNP5pvNN55vON51vOt90vul80/mm803nm843nW8633S+6XzT+abzTeebzjedbzrfdL7pfNP5pvNN55vON51vOt90vul80/mm803nm843nW8633S+6XzT+abzTeebzjedbzrfdL7pfNP5pvNN55vON51vOt90vul80/mm803nm843nW8633S+6XzT+abzTeebzjedbzrfdL7pfNP5pvNN55vON51vOt90vul80/mm803nm843nW8633SedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedJ50nnSedH7o/ND5ofND54fOD50fOj90fuj80Pmh80Pnh84PnR86P3R+6PzQ+aHzQ+eHzg+dHzo/dH7o/ND5ofND54fOD50fOj90fuj80Pmh80Pnh84PnR86P3R+6PzQ+aHzQ+eHzg+dHzo/dH7o/ND5ofND54fOD50fOj90fuj80Pmh80Pnh84PnR86P3R+6PzQ+aHzQ+eHzg+dHzo/dH7o/ND5ofND54fOD50fOj90fuj80Pmh80Pnh84PnR86P3R+6PzQ+aHzQ+eHzg+dHzo/dH7o/ND5ofND50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnRedF50XnTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedN503nTedD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dD50PnQ+dzO6/ndl7P7bye23k9t/N6buf13M7ruZ3Xczuv53Zez+28ntt5Pbfzem7n9dzO67md13M7r+d2Xs/tvJ7beT3BHYs7Fncs7ljcsbhjccfijsUdizsWd4g7xB3iDnGHuEPcIe4Qd4g7xB2bOzZ3bO7Y3LG5Y3PH5o7NHZs7NnckdyR3JHckdyR3JHckdyR3JHckdxzuONxxuONwx+GOwx2HOw53HO443FHcUdxR3FHcUdxR3FHcUdxR3FHc0dzR3NHc0dzR3NHc0dzR3NHc0dwx3DHcMdwx3DHcMdwx3DHcMdxB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQedB50HnQed4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs8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bG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lqS3JL0l6S1Jb0l6S9Jbkt6S9JaktyS9JektSW9JekvSW5LekvSWpLckvSXpLUlvSXpL0luS3pL0lqS3JL0l6S1Jb0l6S9Jbkt6S9JaktyS9JektSW9JekvSW5LekvSWpLckvSXpLUlvSXpL0luS3pL0lqS3JL0l6S1Jb0l6S9Jbkt6S9JaktyS9JektSW9JekvSW5LekvSWpLckvSXpLUlvSXpL0luS3pL0lqS3JL0l6S1Jb0l6S9Jbkt6S9JaktyS9JektSW9JekvSW5LekvSWpLckvSXpLUlvSXpL0luS3pL0lqS3JL0l6S1Jb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG9JeUvKW1LekvKWlLekvCXlLSlvSXlLyltS3pLylpS3pLwl5S0pb0l5S8pbUt6S8paUt6S8JeUtKW9JeUvKW1LekvKWlLekvCXlLSlvSXlLyltS3pLylpS3pLwl5S0pb0l5S8pbUt6S8paUt6S8JeUtKW9JeUvKW1LekvKWlLekvCXlLSlvSXlLyltS3pLylpS3pLwl5S0pb0l5S8pbUt6S8paUt6S8JeUtKW9JeUvKW1LekvKWlLekvCXlLSlvSXlLyltS3pLylpS3pLwl5S0pb0l5S8pbUt6S8paUt6S8JeUtKW9JeUvKW1LekvKWtLekvSXtLWlvSXtL2lvS3pL2lrS3pL0l7S1pb0l7S9pb0t6S9pa0t6S9Je0taW9Je0vaW9LekvaWtLekvSXtLWlvSXtL2lvS3pL2lrS3pL0l7S1pb0l7S9pb0t6S9pa0t6S9Je0taW9Je0vaW9LekvaWtLekvSXtLWlvSXtL2lvS3pL2lrS3pL0l7S1pb0l7S9pb0t6S9pa0t6S9Je0taW9Je0vaW9LekvaWtLekvSXtLWlvSXtL2lvS3pL2lrS3pL0l7S1pb0l7S9pb0t6S9pa0t6S9Je0taW9Je0vaW9LekvaWtLekvSXtLWlvyXhLxlsy3pLxloy3ZLwl4y0Zb8l4S8ZbMt6S8ZaMt2S8JeMtGW/JeEvGWzLekvGWjLdkvCXjLRlvyXhLxlsy3pLxloy3ZLwl4y0Zb8l4S8ZbMt6S8ZaMt2S8JeMtGW/JeEvGWzLekvGWjLdkvCXjLRlvyXhLxlsy3pLxloy3ZLwl4y0Zb8l4S8ZbMt6S8ZaMt2S8JeMtGW/JeEvGWzLekvGWjLdkvCXjLRlvyXhLxlsy3pLxloy3ZLwl4y0Zb8l4S8ZbMt6S8ZaMt2S8JeMtGW/JeEvGWzLekvGWjLdkvCXjLRlvyXhLxlsy3pJhS+JhS+JhS+JhS+JhS+JhS+JhS+JhS+JhS+JhS+JhS+JhS+JhS+JhS+JhS+JhS+JhS+JhS+JhS+JhS+IJ37Z82/Jty7ct37Z82/Jty7ct37Z82/Jt8m3ybfJt8m3ybfJt8m3ybfJt8m3bt23ftn3b9m3bt23ftn3b9m3bt23flr4tfVv6tvRt6dvSt6VvS9+Wvi192/Ftx7cd33Z82/Ftx7cd33Z82/Ftx7eVbyvfVr6tfFv5tvJt5dvKt5VvK9/Wvq19W/u29m3t29q3tW9r39a+rX3b+LbxbePbxreNbxvfNr5tfNv4Nm9JeEvCWxLekvCWhLckvCXhLQlvSXhLwlsS3pLwloS3JLwl4S0Jb0l4S8JbEt6S8JaEtyS8JeEtCW9JeEvCWxLekvCWhLckvCXhLQlvSXhLwlsS3pLwloS3JLwl4S0Jb0l4S8JbEt6S8JaEtyS8JeEtCW9JeEvCWxLekvCWhLckvCXhLQlvSXhLwlsS3pLwloS3JLwl4S0Jb0l4S8JbEt6S8JaEtyS8JeEtCW9JeEvCWxLekvCWhLckvCXhLQlvSXhLwlsS3pLwloS3JLwl4S0Jb0l4S8JbEt6S8JaEtyS8JeEtCW9JeEvCWxLekvCWLG/J8pYsb8nylixvyfKWLG/J8pYsb8nylixvyfKWLG/J8pYsb8nylixvyfKWLG/J8pYsb8nylixvyfKWLG/J8pYsb8nylixvyfKWLG/J8pYsb8nylixvyfKW2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3WvYvYbda9i9ht1r2L2G3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3euye112r8vuddm9LrvXZfe67F6X3ev65V7X/ngYfvjb/7ZVHw/lh9vvkH54/A7lh+13GB7+viXvO/y+Jffh8jvID7ffIf3w+B3KD9vvMPfhL/f68Q6/3Ot9uPwO8sPtd0g/PH6H8sP2O3DbL/f6vkOEHy6/g/xw+x3SD4/fofyw/Q6+bfm25duWb1u+bfm25duWb1u+bfm25dvk2+Tb5Nvk2+Tb5Nvk2+Tb5Nvk27Zv275t+7bt27Zv275t+7bt27Zv274tfVv6tvRt6dvSt6VvS9+Wvi19W/q249uObzu+7fi249uObzu+7fi249uObyvfVr6tfFv5tvJt5dvKt5VvK99Wvs1bIm+JvCXylshbIm+JvCXylshbIm+JvCXylshbIm+JvCXylshbIm+JvCXylmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9pZsb8n2lmxvyfaWbG/J9paktyS9JektSW9JekvSW5LekvSWpLckvSXpLUlvSXpL0luS3pL0lqS3JL0l6S1Jb0l6S9Jbkt6S9JaktyS9JektSW9JekvSW5LekvSWpLckvSXpLUlvSXpL0luS3pL0lqS3JL0l6S1Jb0l6S9Jbkt6S9JaktyS9JektSW9JekvSW5LekvSWpLckvSXpLUlvSXpL0luS3pL0lqS3JL0l6S1Jb0l6S9Jbkt6S9JaktyS9JektSW9JekvSW5LekvSWpLckvSXpLUlvSXpL0luS3pL0lqS3JL0l6S1Jb0l6S9Jbkt6S9JaktyS9JektSW/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYcb8nxlhxvyfGWHG/J8ZYc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r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J7ld2r7F5l9yq7V9m9yu5Vdq+ye5Xdq+xeZfcqu1fZvcruVXavsnuV3avsXmX3KrtX2b3K7lV2r7J73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73Xav2+51271uu9dt97rtXrfd67Z73b/cq/TxcHj4+5bofDwMP1x+B/nh9jukHx6/Q/lh+x2Gh79vyfsOv2/Jfbj8DvLD7XdIPzx+h/JD37Z9W/q29G3p29K3pW9L35a+LX1b+rb0bce3Hd92fNvxbce3Hd92fNvxbce3Hd9Wvq18W/m28m3l28q3lW8r31a+rXxb+7b2be3b2re1b2vf1r6tfVv7tvZt49vGt41vG982vm182/i28W3j24bbfrnXj3f45V7vw+V3kB9uv0P64fE7lB+234HbfrnX9x0i/HD5HeSH2++Qfnj8DuWH7Xfwbcu3Ld+2fNvybcu3Ld+2fNvybd6S7S3Z3pLtLdneku0t2d6S7S3Z3pLtLdneku0t2d6S7S3Z3pLtLdneku0t2d6S7S3Z3pLtLdneku0t2d6S7S3Z3pLtLdneku0t2d6S7S3Z3pLtLdneku0t2d6S7S3Z3pLtLdneku0t2d6S7S3Z3pLtLdneku0t2d6S7S3Z3pLtLdneku0t2d6S7S3Z3pLtLdneku0t2d6S7S3Z3pLtLdneku0t2d6S7S3Z3pLtLdneku0tSW9JekvSW5LekvSWpLckvSXpLUlvSXpL0luS3pL0lqS3JL0l6S1Jb0l6S9Jbkt6S9JaktyS9JektSW9JekvSW5LekvSWpLckvSXpLUlvSXpL0luS3pL0lqS3JL0l6S1Jb0l6S9Jbkt6S9JaktyS9JektSW9JekvSW5LekvSWpLckvSXpLUlvSXpL0luS3pL0lqS3JL0l6S1Jb0l6S9Jbkt6S9JaktyS9JektSW9JekvSW5LekvSWpLckvSXpLUlvSXpL0luS3pL0lqS3JL0l6S1Jb0l6S9Jbkt6S9JaktyS9JektSW9JekvSW5LekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLjLTnekuMtOd6S4y053pLylpS3pLwl5S0pb0l5S8pbUt6S8paUt6S8JeUtKW9JeUvKW1LekvKWlLekvCXlLSlvSXlLyltS3pLylvxyr/ehb/OWlLekvCXlLSlvSXlLyltS3pLylpS3pLwl5S0pb0l5S8pbUt6S8paUt6S8JeUtKW9JeUvKW1LekvKWlLekvCXlLSlvSXlLyltS3pLylpS3pLwl5S0pb0l5S8pbUt6S8paUt6S8JeUtKW9JeUvKW1LekvKWlLekvCXlLSlvSXlLyltS3pLylpS3pLwl5S0pb0l5S8pbUt6S8paUt6S8JeUtKW9JeUvKW1LekvKWtLekvSXtLWlvSXtL2lvS3pL2lrS3pL0l7S1pb0l7S9pb0t6S9pa0t6S9Je0taW9Je0vaW9LekvaWtLekvSXtLWlvSXtL2lvS3pL2lrS3pL0l7S1pb0l7S9pb0t6S9pa0t6S9Je0taW9Je0vaW9LekvaWtLekvSXtLWlvSXtL2lvS3pL2lrS3pL0l7S1pb0l7S9pb0t6S9pa0t6S9Je0taW9Je0vaW9LekvaWtLekvSXtLWlvSXtL2lvS3pL2lrS3pL0l7S1pb0l7S9pb0t6S9pa0t6S9Je0taW9Je0vaW9LekvaWtLekvSXtLWlvyXhLxlsy3pLxloy3ZLwl4y0Zb8l4S8ZbMt6S8ZaMt2S8JeMtGW/JeEvGWzLekvGWjLdkvCXjLRlvyXhLxlsy3pLxloy3ZLwl4y0Zb8l4S8ZbMt6S8ZaMt2S8JeMtGW/JeEvGWzLekvGWjLdkvCXjLRlvyXhLxlsy3pLxloy3ZLwl4y0Zb8l4S8ZbMt6S8ZaMt2S8JeMtGW/JeEvGWzLekvGWjLdkvCXjLRlvyXhLxlsy3pLxloy3ZLwl4y0Zb8l4S8ZbMt6S8Zb8/039zapgWdRm592L2m6cOdeef74XI6Ry2RQUKlGWDMbUvevLjMwzRm8GscmXlY2nEQzOOSw5LDksOSw5LDksOSw5LDksOSw5LDksOSw5LDksuV9L6ufXkvr5taR+fi2pn19L6ufXkvr5taR+fi2pn19L6ufXkvr5taR+fi2pn19L6ufXkvr5taR+fi2pn19L6ufXkvr5taR+fi2pn+BtyduStyVvS96WvC15W/K25G3J25K3Pd72eNvjbY+3Pd72eNvjbY+3Pd72eNvH2z7e9vG2j7d9vO3jbR9v+3jbx9s+3la8rXhb8bbibcXbircVbyveVryteFvztuZtzduatzVva97WvK15W/O25m3D24a3DW8b3ja8bXjb8LbhbcPbhrctb1vetrxtedvytuVty9uWty1vW952vO142/G2423H2463HW873na8DUsCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSwJLAksCSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLEksSSxJLHpY8LHlY8rDkYcnDkoclD0seljwseVjysORhycOShyUPSx6WPCx5WPKw5GHJw5KHJQ9LHpY8LHlY8rCE7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6L7rXoXovutehei+616F6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvutelem+616V6b7rXpXpvuteleh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXofudeheh+516F6H7nXoXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXpfudelel+516V6X7nXpXvfv7vXLP2dw/sfaV3/Ox/nxQXE2Hwzn8sH9nn9Z8s8Hf1ny75l88Dg/PijO5oPhXD643/PjbR9v+3jbx9s+3vbxto+3fbzt420fbyveVryteFvxtuJtxduKtxVvK95WvK15W/O25m3N25q3NW9r3ta8rXlb87bhbcPbhrcNbxveNrxteNvwtuFtw9uWty1vW962vG152/K25W3L25a3LW873na87Xjb8bbjbcfbjrcdbzvedr9v+7t7/fPB393rv2fyweP8+KA4mw+Gc/ng921/d6//fBDBmXzwOD8+KM7mg+FcPuBtWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJYUlhSWFJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0ljSWNJY0lgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWDJYMlgyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYsliyWLJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYclhyWHJYcr+W3M+vJffza8n9/FpyP7+W3M+vJffza8n9/FpyP7+W3M+vJffza8n9/FpyP7+W3M+vJffza8n9/FpyP7+W3M+vJffza8n9/FpyP8Hbkrclb0velrwteVvytuRtyduStyVve7zt8bbH2x5ve7zt8bbH2x5ve7zt8baPt3287eNtH2/7eNvH2z7e9vG2j7d9vK14W/G24m3F24q3FW8r3la8rXhb8bbmbc3bmrc1b2ve1ryteVvztuZtzduGtw1vG942vG142/C24W3D24a3DW9b3ra8bXnb8rblbcvblrctb1vetrzteNvxtuNtx9uOtx1vO952vO14G5YElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYElgSWBJYEliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWJJYkliSWPCx5WPKw5GHJw5KHJQ9LHpY8LHlY8rDkYcnDkoclD0seljwseVjysORhycOShyUPSx6WPCx5WPKw5GHJw5KHJQ9LHpY8LHlY8rDkYcnDkoclD0seljwseVjysORhycOShyUPSx6WPCx5WPKw5GHJw5KHJQ9LHpY8LHlY8rDkYcnDkoclD0seljwseVjysORhycOShyUPSx6WPCx5WPKw5GHJw5KHJQ9LHpY8LHlY8rDkYcnDkoclD0seljwseVjysORhycOShyUPSx6WPCx5WPKw5GHJhyUflnxY8mHJhyUflnxY8mHJhyUflnxY8mHJhyUflnxY8mHJhyUflnxY8mEJ3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e3evRvR7d69G9Ht3r0b0e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sKSwpLCksKSwpLCksKSwpLGksaSxpLGksaSxpLGksaSxpLGksaSxpLGksaSxpLGksaSxpLGksaSxpLGksaSxpLGksaSxpLGksaSxpLGksaSxpLGksaSxpLHk7+718s+5nPd7/mXJv+d/rP3HPy7/uVP30/3pLt2te3Sv7uP+C5XfW7ul3dJuabe0W9ot7ZZ2S7ut3dZua7e129pt7bZ2W7ut3dbuaHe0O9od7Y52R7uj3dHuaHe0u9pd7a52V7ur3dXuane1u9pd7Z52T7un3dPuafe0e9o97Z52j92/k9nfO3Sn7qf70126W/foXt3aDe2GdkO7od3Qbmg3tBvaDe2GdlO7qd3Ubmo3tZvaTe2mdlO7qd2n3afdp92n3afdp92n3afdp92n3U+78mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXhVfzgVfzgVfzgVfzgVfzgVfzgVfzgVfzgVfzgVfz8aDe0G9oN7YZ2Q7uh3dBuaDe0G9pN7aZ2U7up3dRuaje1m9pN7aZ2n3afdp92n3afdp92n3afdp92n3Y/7X7a/bT7affT7qfdT7ufdj/tftot7ZZ2S7ul3dJuabe0W9ot7ZZ2W7ut3dZua7e129pt7bZ2W7ut3dHuaHe0O9od7Y52R7uj3dHuaHe1u9pd7a52V7ur3dXuane1u9o97Z52T7un3dPuafe0e9r949X+ue/3jj9e/XP/tdv3507dT/enu3S37tG9uo/7b6/+vbUb2g3thnZDu6Hd0G5oN7Sb2k3tpnZTu6nd1G5qN7Wb2k3tPu0+7T7tPu0+7T7tPu0+7T7tPu1+2v20+2n30+6n3U+7n3Y/7X7a/bRb2i3tlnZLu6Xd0m5pt7Rb2i3ttnZbu63d1m5rt7Xb2m3ttnZbu6Pd0e5od7Q72h3tjnZHu6Pd0e5qd7W72l3trnZXu6vd1e5qd7V72j3tnnZPu6fd0+5p97R72j12/86kf+/Qnbqf7k936W7do3t1a1depbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568+uTVJ68+efXJq09effLqk1efvPrk1SevPnn1yatPXn3y6pNXn7z65NUnrz559cmrT1598uqTV5+8+uTVJ68+efXJq09effLqk1efvPrk1SevPnn1yatPXn3y6pNXn7z65NUnrz559cmrT1598uqTV5+8+uTVJ68+efXJq09effLqk1efvPrk1SevPnn1yatPXn3y6pNXn7z65NUnrz559cmrT1598uqTV5+8+uTVJ68+efXJq09effLqk1efvPrk1SevPnn1yatPXn3y6pNXn7z65NUnrz559cmrT1598uqTV5+8+uTVJ68+efXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXy6k/fPv3nHt1/7e77cx/33179e4fu1P10f7pLd+se3dp92v20+2n30+6n3U+7n3Y/7X7a/bT7abe0W9ot7ZZ2S7ul3dJuabe0W9pt7bZ2W7ut3dZua7e129pt7bZ2R7uj3dHuaHe0O9od7Y52R7uj3dXuane1u9pd7a52V7ur3dXuave0e9o97Z52T7un3dPuafe0e+z+6dv/vUN36n66P92lu3WP7tWt3dBuaDe0G9oN7YZ2Q7uh3dBuaDe1m9pN7aZ2U7up3dRualdenbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1eHV/mDV/mDV/mDV/mDV/mDV/mDV/mDV/mDV/mDV/nzo93Qbmg3tBvaDe2GdkO7od3Qbmg3tZvaTe2mdlO7qd3Ubmo3tZvafdp92n3afdp92n3afdp92n3afdr9tPtp99Pup91Pu592P+1+2v20+2m3tFvaLe2Wdku7pd3Sbmm3tFvabe22dlu7rd3Wbmu3tdvabe22dke7o93R7mh3tDvaHe2Odke7o93V7mp3tbvaXe2udle7q93V7mr3tHvaPe2edk+7p93T7mn3tCuvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6k/fvv3nPu4/Xv1zh+7U/XR/ukt36x7d2v20W9ot7ZZ2S7ul3dJuabe0W9ot7bZ2W7ut3dZua7e129pt7bZ2W7uj3dHuaHe0O9od7Y52R7uj3dHuane1u9pd7a52V7ur3dXuane1e9o97Z52T7un3dPuafe0e9o9dv/07f/eoTt1P92f7tLdukf36tZuaDe0G9oN7YZ2Q7uh3dBuaDe0m9pN7aZ2U7up3dRuaje1m9pN7T7tPu0+7T7tPu0+7T7tPu3Kq09effLqk1efvPrk1SevPnn1yatPXn3y6pNXn7z65NUnrz559cmrT1598uqTV5+8+uTVJ68+efXJq09effLqk1efvPrk1SevPnn1yatPXn3y6pNXn7z65NUnrz559cmrT1598uqTV5+8+uTVJ68+efXJq09effLqk1efvPrk1SevPnn1yatPXn3y6pNXn7z65FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrl1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1Ze/dO335/7uP949c8dulP30/3pLt2te3Rrt7Tb2m3ttnZbu63d1m5rt7Xb2m3tjnZHu6Pd0e5od7Q72h3tjnZHu6vd1e5qd7W72l3trnZXu6vd1e5p97R72j3tnnZPu6fd0+5p99j9p2//5w7dqfvp/nSX7tY9ule3dkO7od3Qbmg3tBvaDe2GdkO7od3Ubmo3tZvaTe2mdlO7qd3Ubmr3afdp92n3afdp92n3afdp92n3affT7qfdT7ufdj/tftr9tPtpV16dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dXj1fvDq/eDV+8Gr94NX7wev3g9evR+8ej949X7w6v38aDe0G9oN7YZ2Q7uh3dBuaDe0G9pN7aZ2U7up3dRuaje1m9pN7aZ2n3afdp92n3afdp92n3afdp92n3Y/7X7a/bT7affT7qfdT7ufdj/tftot7ZZ2S7ul3dJuabe0W9ot7ZZ2W7ut3dZua7e129pt7bZ2W7ut3dHuaHe0O9od7Y52R7uj3dHuaHe1u9pd7a52V7ur3dXuane1u9o97Z52T7un3dPuafe0e9o97cqrkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyqsnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568+tO33/fnPu6/vfr3Dt2p++n+dJfu1j26tdvaHe2Odke7o93R7mh3tDvaHe2Odle7q93V7mp3tbvaXe2udle7q93T7mn3tHvaPe2edk+7p93T7rH7p2//9w7dqfvp/nSX7tY9ule3dkO7od3Qbmg3tBvaDe2GdkO7od3Ubmo3tZvaTe2mdlO7qd3Ubmr3afdp92n3afdp92n3afdp92n3affT7qfdT7ufdj/tftr9tPtp99Pup93Sbmm3tFvaLe2Wdku7pV159cmrT1598uqTV5+8+uTVJ68+efXJq09effLqk1efvPrk1SevPnn1yatPXn3y6pNXn7z65NUnrz559cmrT1598uqTV5+8+uTVJ68+efXJq09effLqk1efvPrk1SevPnn1yauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05eHV59P3j1/eDV94NX3w9efT949f3g1feDV98PXn0/ePX9/Gg3tBvaDe2GdkO7od3Qbmg3tBvaTe2mdlO7qd3Ubmo3tZvaTe2mdp92n3afdp92n3afdp92n3afdp92P+1+2v20+2n30+6n3U+7n3Y/7X7aLe2Wdku7pd3Sbmm3tFvaLe2Wdlu7rd3Wbmu3tdvabe22dlu7rd3R7mh3tDvaHe2Odke7o93R7mh3tbvaXe2udle7q93V7mp3tbvaPe2edk+7p93T7mn3tHvaPe3Kq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evFLf/qlv/9S3f+rbP/Xtn/r2T337p779U9/+qW//1Ld/6ts/9e2f+vZPffunvv1T3/6pb//Ut3/q2z/17d8/ffv9ff/x6p87dKfup/vTXbpb9+he3do97Z52T7un3dPuafe0e9o97R67//Tt/9yhO3U/3Z/u0t26R/fq1m5oN7Qb2g3thnZDu6Hd0G5oN7Sb2k3tpnZTu6nd1G5qN7Wb2k3tPu0+7T7tPu0+7T7tPu0+7T7tPu1+2v20+2n30+6n3U+7n3Y/7X7a/bRb2i3tlnZLu6Xd0m5pt7Rb2i3ttnZbu63d1m5rt7Xb2m3ttnZbu6Pd0e5od7Q72h3tjnZHu6NdefXJq09effLqk1efvPrk1SevPnn1yatPXn3y6pNXn7z65NUnrz559cmrT1598uqTVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp59Xffnj/fn/u4//Lq9w7dqfvp/nSX7tY9urV77P7dt//eoTt1P92f7tLdukf36tZuaDe0G9oN7YZ2Q7uh3dBuaDe0m9pN7aZ2U7up3dRuaje1m9pN7T7tPu0+7T7tPu0+7T7tPu0+7T7tftr9tPtp99Pup91Pu592P+1+2v20W9ot7ZZ2S7ul3dJuabe0W9ot7bZ2W7ut3dZua7e129pt7bZ2W7uj3dHuaHe0O9od7Y52R7uj3dHuane1u9pd7a52V7ur3dWuvDp5dfLq5NXJq5NXJ69OXp28Onl18urwqn7wqn7wqn7wqn7wqn7wqn7wqn7wqn7wqn7wqn5+tBvaDe2GdkO7od3Qbmg3tBvaDe2mdlO7qd3Ubmo3tZvaTe2mdlO7T7tPu0+7T7tPu0+7T7tPu0+7T7ufdj/tftr9tPtp99Pup91Pu592P+2Wdku7pd3Sbmm3tFvaLe2Wdku7rd3Wbmu3tdvabe22dlu7rd3W7mh3tDvaHe2Odke7o93R7mh3tLvaXe2udle7q93V7mp3tbvaXe2edk+7p93T7mn3tHvaPe2eduVVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5dWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09ePXn15NWTV09evT9e3Z/7fu/vj1f/3KE7dT/dn+7S3bpH9+rWbmg3tBvaDe2GdkO7od3Qbmg3tJvaTe2mdlO7qd3Ubmo3tZvaTe0+7T7tPu0+7T7tPu0+7T7tPu0+7X7a/bT7affT7qfdT7ufdj/tftr9tFvaLe2Wdku7pd3Sbmm3tFvaLe22dlu7rd3Wbmu3tdvabe22dlu7o93R7mh3tDvaHe2Odke7o93R7mp3tbvaXe2udle7q93V7mp3tXvaPe2edk+7p93T7mn3tCuvPnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5dfLq5NXJq5NXJ69OXp28Onn1p2+P/HMf999e/XuH7tT9dH+6S/dfu1F/7tH99+78uY/7b68y/tx/7eaf/86f3+/8/txP96e7dLfu0b26j/vP73f+5w7d2n3afdp92n3afdp92n3a/bT7affT7qfdT7ufdj/tftr9tPtpt7Rb2i3tlnZLu6Xd0m5pt7Rb2m3ttnZbu63d1m5rt7Xb2m3ttnZHu6Pd0e5od7Q72h3tjnZHu6Pd1e5qd7W72l3trnZXu6vd1e5q97R72j3tnnZPu6fd0+5p97R7v7v95+e3/3uH7tT9dH+6S3frHt2rW7uh3dBuaDe0G9oN7YZ2Q7uh3dBuaje1m9pN7aZ2U7up3dRuaje1+7T7tPu0+7T7tPu0+7T7tPu0+7T7affT7qfdT7ufdj/tftr9tPtp99Nuabe0W9ot7ZZ2S7ul3dJuabe029pt7bZ2W7ut3dZua7e129pt7Y52R7uj3dHuaHe0O9od7Y52R7ur3dXuane1u9pd7a52V7ur3dXuafe0e9o97Z52T7un3dPuaVdehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0Jehbz68/Pb/7nlVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1Jepbx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrz65NUnrz559cmrT1598uqTV5+8+uTVJ68+efXJq09effLqk1efvPrk1SevPnn1yatPXn3y6pNXn7z65NUnrz559cmrT1598uqTV5+8+vPz27f/3E/3p7t0t+7RvbqP+49X/9yhW7ufdj/tftr9tPtp99Pup93Sbmm3tFvaLe2Wdku7pd3Sbmm3tdvabe22dlu7rd3Wbmu3tdvaHe2Odke7o93R7mh3tDvaHe2Odle7q93V7mp3tbvaXe2udle7q93T7mn3tHvaPe2edk+7p93T7rH75+e3/3uH7tT9dH+6S3frHt2rW7uh3dBuaDe0G9oN7YZ2Q7uh3dBuaje1m9pN7aZ2U7up3dRuaje1+7T7tCuvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl7907ffn/vp/nSX7tY9ulf3cf/x6p87dGu3tFvaLe2Wdku7pd3Sbmu3tdvabe22dlu7rd3Wbmu3tTvaHe2Odke7o93R7mh3tDvaHe2udle7q93V7mp3tbvaXe2udle7p93T7mn3tHvaPe2edk+7p9373Z1/+vZ/7tCdup/uT3fpbt2je3VrN7Qb2g3thnZDu6Hd0G5oN7Qb2k3tpnZTu6nd1G5qN7Wb2k3tpnafdp92n3afdp92n3afdp92n3afdj/tftr9tPtp99Pup91Pu592P+1+2i3tlnZLu6Xd0m5pt7Rb2i3tlnZbu63d1m5rt7Xb2m3ttnZbu63d0e5od7Q72h3tjnZHu6Pd0e5od7W72l3trnZXu6vd1e5qd7W72j3tnnZPu6fd0+5p97R72j3tyquQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJqyevnrx68urJq09effLqk1efvPrk1SevPnn1yatPXn3y6pNXn7z65NUnrz559cmrT1598uqTV5+8+uTVJ68+efXJq09effLqk1efvPrk1SevPnn1yatPXn3y6pNXn7z65NUnrz559cmrT1598uqTV5+8+uTVJ68+efXJq09effLqk1efvPrTt9/35366P92lu3WP7tV93H9+v/M/d+jWbmu3tdvabe22dlu7rd3R7mh3tDvaHe2Odke7o93R7mh3tbvaXe2udle7q93V7mp3tbvaPe2edk+7p93T7mn3tHvaPe0eu3/69n/v0J26n+5Pd+lu3aN7dWs3tBvaDe2GdkO7od3Qbmg3tBvaTe2mdlO7qd3Ubmo3tZvaTe2mdp92n3afdp92n3afdp92n3afdp92P+1+2v20+2n30+6n3U+7n3Y/7X7aLe2WduVVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl1eLU/eLU/eLU/eLU/eLU/eLU/eLU/eLU/eLU/eLU/P9oN7YZ2Q7uh3dBuaDe0G9oN7YZ2U7up3dRuaje1m9pN7aZ2U7up3afdp92n3afdp92n3afdp92n3afdT7ufdj/tftr9tPtp99Pup91Pu592S7ul3dJuabe0W9ot7ZZ2S7ul3dZua7e129pt7bZ2W7ut3dZua3e0O9od7Y52R7uj3dHuaHe0O9pd7a52V7ur3dXuane1u9pd7a52T7un3dPuafe0e9o97Z52T7vyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqyasnr568evLqk1efvPrk1SevPnn1yatPXn3y6pNXn7z65NUnrz559cmrT1598uqTV5+8+uTVJ68+efXJq09effLqk1efvPrk1SevPnn1yatPXn3y6pNXn7z65NUnrz559cmrT1598uqTV5+8+uTVJ68+efXJq09effLqk1efvPrk1Sev1Lev+vZV377q21d9+6pvX/Xtq7591bev+vZV377q21d9+6pvX/Xtq7591bev+vZV377q21d9+/7Tt9+f+9Ndulv36F7dx/3Hq3/u0J26tbvaXe2udle7q93V7mn3tHvaPe2edk+7p93T7mn32P2nb//nDt2p++n+dJfu1j26V7d2Q7uh3dBuaDe0G9oN7YZ2Q7uh3dRuaje1m9pN7aZ2U7up3dRuavdp92n3afdp92n3afdp92n3afdp99Pup91Pu592P+1+2v20+2n30+6n3dJuabe0W9ot7ZZ2S7ul3dJuabe129pt7bZ2W7ut3dZua7e129od7Y52R7vyquRVyauSVyWvSl6VvCp5VfKq5FXJq5JXJa9KXpW8KnlV8qrkVcmrklclr0pelbwqeVXyquRVyauWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6u++PX++P/fT/eku3a17dK/u4/7Lq987dGv3tHvaPe2edk+7p9373b2/+/bfO3Sn7qf70126W/foXt3aDe2GdkO7od3Qbmg3tBvaDe2GdlO7qd3Ubmo3tZvaTe2mdlO7qd2n3afdp92n3afdp92n3afdp92n3U+7n3Y/7X7a/bT7affT7qfdT7ufdku7pd3Sbmm3tFvaLe2Wdku7pd3Wbmu3tdvabe22dlu7rd3Wbmt3tDvaHe2Odke7o93R7mh3tDvaXe2udle7q93V7mp3tbvaXe2udk+7p93T7mn3tHvaPe2edk+78irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr0JehbwKeRXyKuRVyKuQVyGvQl6FvAp5FfIq5FXIq5BXIa9CXoW8CnkV8irkVcirkFchr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXyKuVVyquUVymvUl6lvEp5lfIq5VXKq5RXKa9SXqW8SnmV8irlVcqrlFcpr1JepbxKeZXy6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6smrJ6+evHry6pNXn7z65NUnrz559cmrT1598uqTV5+8+uTVJ68+efXJq09effLqk1efvPrk1SevPnn1yatPXn3y6pNXn7z65NUnrz559cmrT1598uqTV5+8+uTVJ68+efXJq09effLqk1efvPrk1SevPnn1yatPXn3y6pNXn7z65NUnrz559cmrT1598uqTV5+8+uTVJ68+efXJq09effLqk1efvPrk1SevPnn1yatPXn3y6pNXn7z65NUnrz559cmrT1598uqTV5+8+uTVJ68+efXJq09effLqk1efvPrk1Sevvj9e3Z/76f50l+7WPbpX9/3e9cerf+7Qnbqf7k936W7do3t1aze0G9oN7YZ2Q7uh3dBuaDe0G9pN7aZ2U7up3dRuaje1m9pN7aZ2n3afdp92n3afdp92n3afdp92n3Y/7X7a/bT7affT7qfdT7ufdj/tftot7ZZ2S7ul3dJuabe0W9ot7ZZ2W7ut3dZua7e129pt7bZ2W7ut3dHuaHe0O9od7Y52R7uj3dHuaHe1u9pd7a52V7ur3dXuane1u9o97Z525VXJq5JXJa9KXpW8KnlV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr1petbxqedXyquVVy6uWVy2vWl61vGp51fKq5VXLq5ZXLa9aXrW8annV8qrlVcurllctr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauTVyKuRVyOvRl6NvBp5NfJq5NXIq5FXI69GXo28Gnk18mrk1cirkVcjr0ZejbwaeTXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvVl6tvFp5tfJq5dXKq5VXK69WXq28Wnm18mrl1cqrlVcrr1ZerbxaebXyauXVyquVVyuvTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5dfLq5NXJq5NXJ69OXp28Onl18urk1cmrk1cnr05enbw6eXXy6uTVyauTVyevTl6dvDp5db9evZ+fX6/+ukP3X7uRf+6n+9Ndulv36F7dx/23V1F/7tD99+78uZ/uv3Yz/tx/7Wb+j//b//T//V/++3/5X/7X//qf/z//0//9//8ff/x//Z//23/6P/7Lf/vf/vnj//H/+9///Zv/9b//l//6X//L//t//t//+3/7T//5//l//vf//D//1//2n/7+u//x//gf/xc=",
  "file_map": {
    "3": {
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n",
      "path": "std/array/mod.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "19": {
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n",
      "path": "std/hash/mod.nr"
    },
    "50": {
      "source": "// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse lib::configs::default::threshold::{\n    L, N, PK_GENERATION_BIT_E_SM, PK_GENERATION_BIT_EEK, PK_GENERATION_BIT_PK, PK_GENERATION_BIT_R1,\n    PK_GENERATION_BIT_R2, PK_GENERATION_BIT_SK, PK_GENERATION_CONFIGS,\n};\nuse lib::core::threshold::pk_generation::PkGeneration;\nuse lib::math::polynomial::Polynomial;\n\nfn main(\n    a: pub [Polynomial<N>; L],\n    eek: Polynomial<N>,\n    sk: Polynomial<N>,\n    e_sm: [Polynomial<N>; L],\n    r1is: [Polynomial<(2 * N) - 1>; L],\n    r2is: [Polynomial<N - 1>; L],\n    pk0is: [Polynomial<N>; L],\n    pk1is: [Polynomial<N>; L],\n) -> pub (Field, Field, Field) {\n    let pk_generation: PkGeneration<N, L, PK_GENERATION_BIT_EEK, PK_GENERATION_BIT_SK, PK_GENERATION_BIT_E_SM, PK_GENERATION_BIT_R1, PK_GENERATION_BIT_R2, PK_GENERATION_BIT_PK> = PkGeneration::new(\n        PK_GENERATION_CONFIGS,\n        a,\n        eek,\n        sk,\n        e_sm,\n        r1is,\n        r2is,\n        pk0is,\n        pk1is,\n    );\n    pk_generation.execute()\n}\n",
      "path": "/Users/ctrlc03/Documents/zk/enclave/circuits/bin/threshold/pk_generation/src/main.nr"
    },
    "70": {
      "source": "// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse crate::math::commitments::{\n    compute_share_computation_e_sm_commitment, compute_share_computation_sk_commitment,\n    compute_threshold_pk_challenge, compute_threshold_pk_commitment,\n};\nuse crate::math::helpers::flatten;\nuse crate::math::polynomial::Polynomial;\n\n/// Cryptographic parameters for threshold public key generation circuit.\npub struct Configs<let N: u32, let L: u32> {\n    /// CRT moduli: [q_0, q_1, ..., q_{L-1}]\n    pub qis: [Field; L],\n    /// Bound for error polynomial (eek) coefficients\n    pub eek_bound: Field,\n    /// Bound for secret key polynomial (sk) coefficients\n    pub sk_bound: Field,\n    /// Bound for smudging noise polynomial (e_sm) coefficients\n    pub e_sm_bound: Field,\n    /// Bounds for r1 polynomials (modulus switching quotients) for each CRT basis\n    pub r1_bounds: [Field; L],\n    /// Bounds for r2 polynomials (cyclotomic reduction quotients) for each CRT basis\n    pub r2_bounds: [Field; L],\n}\n\nimpl<let N: u32, let L: u32> Configs<N, L> {\n    pub fn new(\n        qis: [Field; L],\n        eek_bound: Field,\n        sk_bound: Field,\n        e_sm_bound: Field,\n        r1_bounds: [Field; L],\n        r2_bounds: [Field; L],\n    ) -> Self {\n        Configs { qis, eek_bound, sk_bound, e_sm_bound, r1_bounds, r2_bounds }\n    }\n}\n\n/// Correct Threshold Public Key Generation Circuit (Circuit 1).\n///\n/// Verifies:\n/// 1. Range checks on all secret witnesses (secret key, error, smudging noise, quotients)\n/// 2. Correct public key generation: pk0_i = -a_i * sk + eek + r2_i * (X^N + 1) + r1_i * q_i\n///    and pk1_i = a_i\n///\n/// Outputs:\n/// - commit(threshold_sk)\n/// - commit(threshold_pk)\n/// - commit(e_sm)\npub struct PkGeneration<let N: u32, let L: u32, let BIT_EEK: u32, let BIT_SK: u32, let BIT_E_SM: u32, let BIT_R1: u32, let BIT_R2: u32, let BIT_PK: u32> {\n    /// Cryptographic parameters including bounds, moduli, and constants.\n    configs: Configs<N, L>,\n\n    /// Common Reference String polynomials (public witnesses)\n    /// One polynomial per modulus i\n    a: [Polynomial<N>; L],\n\n    /// Error polynomial (secret witness)\n    /// Small coefficients sampled from error distribution\n    eek: Polynomial<N>,\n\n    /// Secret key polynomial (secret witness)\n    /// Small coefficients sampled from CBD (Centered Binomial Distribution)\n    sk: Polynomial<N>,\n\n    /// Smudging noise polynomial (secret witness)\n    /// Used for threshold decryption security\n    e_sm: [Polynomial<N>; L],\n\n    /// Quotients from polynomial operations (secret witnesses)\n    /// r1[i] are quotients from modulus switching for modulus i (can be negative, degree 2*N-1)\n    r1: [Polynomial<2 * N - 1>; L],\n    /// r2[i] are quotients from cyclotomic reduction for modulus i (typically positive, degree N-1)\n    r2: [Polynomial<N - 1>; L],\n\n    /// Threshold public key components (committed witnesses)\n    /// pk0[i] is the first component of the public key for modulus i\n    pk0: [Polynomial<N>; L],\n    /// pk1[i] is the second component of the public key for modulus i (should equal a[i])\n    pk1: [Polynomial<N>; L],\n}\n\nimpl<let N: u32, let L: u32, let BIT_EEK: u32, let BIT_SK: u32, let BIT_E_SM: u32, let BIT_R1: u32, let BIT_R2: u32, let BIT_PK: u32> PkGeneration<N, L, BIT_EEK, BIT_SK, BIT_E_SM, BIT_R1, BIT_R2, BIT_PK> {\n    pub fn new(\n        configs: Configs<N, L>,\n        a: [Polynomial<N>; L],\n        eek: Polynomial<N>,\n        sk: Polynomial<N>,\n        e_sm: [Polynomial<N>; L],\n        r1: [Polynomial<2 * N - 1>; L],\n        r2: [Polynomial<N - 1>; L],\n        pk0: [Polynomial<N>; L],\n        pk1: [Polynomial<N>; L],\n    ) -> Self {\n        PkGeneration { configs, a, eek, sk, e_sm, r1, r2, pk0, pk1 }\n    }\n\n    /// Flattens all witness data into a single array for Fiat-Shamir challenge generation\n    fn payload(\n        self,\n        sk_commitment: Field,\n        pk_commitment: Field,\n        e_sm_commitment: Field,\n    ) -> Vec<Field> {\n        let mut inputs = Vec::new();\n\n        // Flatten CRS polynomials a (L polynomials of degree N)\n        inputs = flatten::<_, _, BIT_PK>(inputs, self.a);\n\n        // Flatten error polynomial eek (1 polynomial of degree N)\n        inputs = flatten::<_, _, BIT_EEK>(inputs, [self.eek]);\n\n        // Use commitments instead of full polynomials\n        inputs.push(sk_commitment);\n        inputs.push(pk_commitment);\n        inputs.push(e_sm_commitment);\n\n        // Flatten quotient polynomials (L polynomials each)\n        inputs = flatten::<_, _, BIT_R1>(inputs, self.r1);\n        inputs = flatten::<_, _, BIT_R2>(inputs, self.r2);\n\n        inputs\n    }\n\n    /// Main execution function\n    /// Returns (commit(threshold_sk), commit(threshold_pk), commit(e_sm))\n    pub fn execute(self) -> (Field, Field, Field) {\n        // Step 1: Perform range checks on all secret witness values\n        self.perform_range_checks();\n\n        // Step 2: Compute commitments\n        let sk_commitment = compute_share_computation_sk_commitment::<N, BIT_SK>(self.sk);\n        let e_sm_commitment =\n            compute_share_computation_e_sm_commitment::<N, L, BIT_E_SM>(self.e_sm);\n        let pk_commitment = compute_threshold_pk_commitment::<N, L, BIT_PK>(self.pk0, self.pk1);\n\n        // Step 3: Generate Fiat-Shamir challenges using commitments\n        let gammas = self.generate_challenge(sk_commitment, pk_commitment, e_sm_commitment);\n\n        // Step 4: Verify public key equations for each modulus\n        for i in 0..L {\n            let gamma = gammas.get(i);\n            self.verify_public_key_for_modulus(i, gamma);\n        }\n\n        // Step 5: Return all commitments\n        (sk_commitment, pk_commitment, e_sm_commitment)\n    }\n\n    /// Generates Fiat-Shamir challenge values using the SAFE cryptographic sponge\n    fn generate_challenge(\n        self,\n        sk_commitment: Field,\n        pk_commitment: Field,\n        e_sm_commitment: Field,\n    ) -> Vec<Field> {\n        let inputs = self.payload(sk_commitment, pk_commitment, e_sm_commitment);\n\n        compute_threshold_pk_challenge::<L>(inputs)\n    }\n\n    /// Performs range checks on all secret witness values\n    fn perform_range_checks(self) {\n        // Check that error polynomial has small coefficients\n        self.eek.range_check_2bounds::<BIT_EEK>(self.configs.eek_bound, self.configs.eek_bound);\n\n        // Check that secret key polynomial has small coefficients\n        self.sk.range_check_2bounds::<BIT_SK>(self.configs.sk_bound, self.configs.sk_bound);\n\n        // Check quotient terms are within expected bounds (per modulus)\n        for i in 0..L {\n            self.e_sm[i].range_check_2bounds::<BIT_E_SM>(\n                self.configs.e_sm_bound,\n                self.configs.e_sm_bound,\n            );\n\n            self.r1[i].range_check_2bounds::<BIT_R1>(\n                self.configs.r1_bounds[i],\n                self.configs.r1_bounds[i],\n            );\n\n            self.r2[i].range_check_2bounds::<BIT_R2>(\n                self.configs.r2_bounds[i],\n                self.configs.r2_bounds[i],\n            );\n        }\n    }\n\n    /// Verifies the threshold public key generation equations for a specific CRT basis\n    fn verify_public_key_for_modulus(self, i: u32, gamma: Field) {\n        // Evaluate all polynomials at the random challenge point gamma\n        let a_at_gamma = self.a.map(|a_poly| a_poly.eval(gamma));\n\n        let eek_at_gamma = self.eek.eval(gamma);\n        let sk_at_gamma = self.sk.eval(gamma);\n\n        let r1_at_gamma = self.r1.map(|r1_poly| r1_poly.eval(gamma));\n        let r2_at_gamma = self.r2.map(|r2_poly| r2_poly.eval(gamma));\n\n        let pk0_at_gamma = self.pk0.map(|pk0_poly| pk0_poly.eval(gamma));\n        let pk1_at_gamma = self.pk1.map(|pk1_poly| pk1_poly.eval(gamma));\n\n        // Evaluate the cyclotomic polynomial X^N + 1 at gamma\n        let cyclo_at_gamma = gamma.pow_32(N as Field) + 1;\n\n        // pk0_i = -a_i * sk + eek + r2_i * (X^N + 1) + r1_i * q_i\n        let expected_pk0 = -a_at_gamma[i] * sk_at_gamma\n            + eek_at_gamma\n            + r2_at_gamma[i] * cyclo_at_gamma\n            + r1_at_gamma[i] * self.configs.qis[i];\n\n        assert(pk0_at_gamma[i] == expected_pk0, \"Public key equation 1 failed\");\n\n        // Equation 2: pk1_i = a_i\n        assert(pk1_at_gamma[i] == a_at_gamma[i], \"Public key equation 2 failed\");\n    }\n}\n",
      "path": "/Users/ctrlc03/Documents/zk/enclave/circuits/lib/src/core/threshold/pk_generation.nr"
    },
    "74": {
      "source": "// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse crate::math::helpers::{compute_safe, flatten};\nuse crate::math::polynomial::Polynomial;\n\n/// DOMAIN SEPARATORS\n\n// Domain separator - \"PK\"\npub global DS_PK: [u8; 64] = [\n    0x50, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"PK_GENERATION\"\npub global DS_PK_GENERATION: [u8; 64] = [\n    0x50, 0x4b, 0x5f, 0x47, 0x45, 0x4e, 0x45, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"SHARE_COMPUTATION\"\npub global DS_SHARE_COMPUTATION: [u8; 64] = [\n    0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x43, 0x4f, 0x4d, 0x50, 0x55, 0x54, 0x41, 0x54, 0x49, 0x4f,\n    0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"SHARE_ENCRYPTION\"\npub global DS_SHARE_ENCRYPTION: [u8; 64] = [\n    0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x45, 0x4e, 0x43, 0x52, 0x59, 0x50, 0x54, 0x49, 0x4f, 0x4e,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"PK_AGGREGATION\"\npub global DS_PK_AGGREGATION: [u8; 64] = [\n    0x50, 0x4b, 0x5f, 0x41, 0x47, 0x47, 0x52, 0x45, 0x47, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CIPHERTEXT\"\npub global DS_CIPHERTEXT: [u8; 64] = [\n    0x43, 0x49, 0x50, 0x48, 0x45, 0x52, 0x54, 0x45, 0x58, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"AGGREGATED_SHARES\"\npub global DS_AGGREGATED_SHARES: [u8; 64] = [\n    0x41, 0x47, 0x47, 0x52, 0x45, 0x47, 0x41, 0x54, 0x45, 0x44, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45,\n    0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"RECURSIVE_AGGREGATION\"\npub global DS_RECURSIVE_AGGREGATION: [u8; 64] = [\n    0x52, 0x45, 0x43, 0x55, 0x52, 0x53, 0x49, 0x56, 0x45, 0x5f, 0x41, 0x47, 0x47, 0x52, 0x45, 0x47,\n    0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_PK_GENERATION\"\npub global DS_CLG_PK_GENERATION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x50, 0x4b, 0x5f, 0x47, 0x45, 0x4e, 0x45, 0x52, 0x41, 0x54, 0x49, 0x4f,\n    0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_SHARE_ENCRYPTION\"\npub global DS_CLG_SHARE_ENCRYPTION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x45, 0x4e, 0x43, 0x52, 0x59, 0x50,\n    0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_USER_DATA_ENCRYPTION\"\npub global DS_CLG_USER_DATA_ENCRYPTION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x55, 0x53, 0x45, 0x52, 0x5f, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x45, 0x4e,\n    0x43, 0x52, 0x59, 0x50, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_SHARE_DECRYPTION\"\npub global DS_CLG_SHARE_DECRYPTION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x44, 0x45, 0x43, 0x52, 0x59, 0x50,\n    0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n\n/// WRAPPERS\n\npub fn compute_commitments(\n    payload: Vec<Field>,\n    domain_separator: [u8; 64],\n    io_pattern: [u32; 2],\n) -> Vec<Field> {\n    compute_safe(domain_separator, payload, io_pattern)\n}\n\npub fn single_polynomial_payload<let N: u32, let BIT_POLY: u32>(\n    payload: Vec<Field>,\n    input: Polynomial<N>,\n) -> Vec<Field> {\n    flatten::<_, _, BIT_POLY>(payload, [input])\n}\n\npub fn multiple_polynomial_payload<let N: u32, let L: u32, let BIT_POLY: u32>(\n    payload: Vec<Field>,\n    inputs: [Polynomial<N>; L],\n) -> Vec<Field> {\n    flatten::<_, _, BIT_POLY>(payload, inputs)\n}\n\n/// COMMITMENTS\n\npub fn compute_dkg_pk_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);\n    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);\n\n    compute_commitments(payload, DS_PK, [0x80000000 | payload.len(), 1]).get(0)\n}\n\npub fn compute_threshold_pk_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);\n    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);\n\n    compute_commitments(payload, DS_PK_GENERATION, [0x80000000 | payload.len(), 1]).get(0)\n}\n\npub fn compute_share_computation_sk_commitment<let N: u32, let BIT_SK: u32>(\n    sk: Polynomial<N>,\n) -> Field {\n    let mut payload = single_polynomial_payload::<N, BIT_SK>(Vec::new(), sk);\n    compute_commitments(\n        payload,\n        DS_SHARE_COMPUTATION,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_share_computation_e_sm_commitment<let N: u32, let L: u32, let BIT_E_SM: u32>(\n    e_sm: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_E_SM>(Vec::new(), e_sm);\n    compute_commitments(\n        payload,\n        DS_SHARE_COMPUTATION,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_share_encryption_commitment_from_message<let N: u32, let BIT_MSG: u32>(\n    message: Polynomial<N>,\n) -> Field {\n    let mut payload = single_polynomial_payload::<N, BIT_MSG>(Vec::new(), message);\n    compute_commitments(\n        payload,\n        DS_SHARE_ENCRYPTION,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_share_encryption_commitment_from_shares<let N: u32, let L: u32, let N_PARTIES: u32>(\n    y: [[[Field; N_PARTIES + 1]; L]; N],\n    party_idx: u32,\n    mod_idx: u32,\n) -> Field {\n    let mut payload = Vec::new();\n\n    for coeff_idx in 0..N {\n        payload.push(y[coeff_idx][mod_idx][party_idx + 1]);\n    }\n\n    // Include party_idx and mod_idx in the hash\n    payload.push(party_idx as Field);\n    payload.push(mod_idx as Field);\n\n    compute_commitments(\n        payload,\n        DS_SHARE_ENCRYPTION,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_aggregated_shares_commitment<let N: u32, let L: u32, let BIT_MSG: u32>(\n    agg_shares: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_MSG>(Vec::new(), agg_shares);\n    compute_commitments(\n        payload,\n        DS_AGGREGATED_SHARES,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_pk_aggregation_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);\n    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);\n\n    compute_commitments(payload, DS_PK_AGGREGATION, [0x80000000 | payload.len(), 1]).get(0)\n}\n\npub fn compute_recursive_aggregation_commitment(payload: Vec<Field>) -> Field {\n    compute_safe(\n        DS_RECURSIVE_AGGREGATION,\n        payload,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_ciphertext_commitment<let N: u32, let L: u32, let BIT_CT: u32>(\n    ct0: [Polynomial<N>; L],\n    ct1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_CT>(Vec::new(), ct0);\n    payload = multiple_polynomial_payload::<N, L, BIT_CT>(payload, ct1);\n\n    compute_commitments(payload, DS_CIPHERTEXT, [0x80000000 | payload.len(), 1]).get(0)\n}\n\n/// COMMITMENTS FOR CHALLENGES\n\npub fn compute_threshold_pk_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {\n    compute_commitments(\n        payload,\n        DS_CLG_PK_GENERATION,\n        [0x80000000 | payload.len(), 2 * L],\n    )\n}\n\npub fn compute_share_encryption_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {\n    compute_commitments(\n        payload,\n        DS_CLG_SHARE_ENCRYPTION,\n        [0x80000000 | payload.len(), 2 * L],\n    )\n}\n\npub fn compute_user_data_encryption_challenge_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0is: [Polynomial<N>; L],\n    pk1is: [Polynomial<N>; L],\n    gammas_payload: Vec<Field>,\n    pk_commitment: Field,\n) -> Vec<Field> {\n    assert(compute_pk_aggregation_commitment::<N, L, BIT_PK>(pk0is, pk1is) == pk_commitment);\n\n    compute_commitments(\n        gammas_payload,\n        DS_CLG_USER_DATA_ENCRYPTION,\n        [0x80000000 | gammas_payload.len(), 2 * L],\n    )\n}\n\npub fn compute_threshold_share_decryption_challenge<let L: u32>(payload: Vec<Field>) -> Field {\n    compute_commitments(\n        payload,\n        DS_CLG_SHARE_DECRYPTION,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n",
      "path": "/Users/ctrlc03/Documents/zk/enclave/circuits/lib/src/math/commitments.nr"
    },
    "75": {
      "source": "// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\n//! Helper functions for circuit construction and cryptographic operations.\nuse crate::math::polynomial::Polynomial;\nuse crate::math::safe::SafeSponge;\n\n/// Compute hex-aligned packing parameters for a given `BIT`.\n///\n/// # Purpose\n/// Returns `(nibble_bits, group)` for use by pack/flatten so layout stays consistent.\n/// - `nibble_bits`: ceil (`BIT`) to the next multiple of 4 (nibble alignment).\n///   - Examples: `BIT = 7 -> 8`, `BIT = 8 -> 8`, `BIT = 9 -> 12`, `BIT = 10 -> 12`, `BIT = 11 -> 12`,\n///     `BIT=16 -> 16`, `BIT = 17 -> 20`.\n/// - `group`: max number of encoded limbs that fit in one BN254 field element,\n///            when each limb uses an extra 4 bits (see below).\n///\n/// # Rationale\n/// - We align to nibbles so powers of two are hex-friendly and deterministic.\n/// - We reserve one extra nibble (4 bits) per stored value to lift signed\n///   coefficients into the non-negative range (e.g., store `v + 2^nibble_bits`),\n///   which implies a radix of `2^(nibble_bits + 4)`.\n///\n/// # Safety\n/// - Asserts `nibble_bits + 4 <= 254` to avoid mod-p wrap on BN254.\n/// - Ensures at least one limb fits: `group >= 1`.\nfn packing_layout<let BIT: u32>() -> (u32, u32) {\n    // Ceil BIT up to the next multiple of 4 (nibble alignment).\n    let nibble_bits = ((BIT + 3) / 4) * 4;\n\n    // Each stored limb uses an extra nibble because negative coefficients\n    // will be shifted to positive, so radix = 2^(nibble_bits+4).\n    assert(nibble_bits + 4 <= 254);\n\n    // Maximum limbs that fit in one BN254 element without wrap.\n    let group = 254 / (nibble_bits + 4);\n    assert(group >= 1);\n    (nibble_bits, group)\n}\n\n/// Flatten `L` polynomials into a single linear stream of packed `Field` carriers.\n///\n/// ## What this does\n/// - For each CRT limb `j` in `0..L`, it packs the coefficients of `poly[j]`\n///   with `pack::<A, BIT>` and appends all resulting carriers to `inputs`.\n/// - The packing layout (nibble-aligned width and `group` size) is taken from\n///   `packing_layout::<BIT>()` and must match what `pack` uses.\n///\n/// ## Determinism & order\n/// - Preserves a stable order: iterate `j = 0..L`, then for each `j` append\n///   carriers in ascending chunk index `i = 0..num_chunks`.\n/// - This ensures transcripts remain deterministic across runs.\n///\n/// ## Generics\n/// - `A`: polynomial degree (number of coefficients per polynomial).\n/// - `L`: number of CRT bases (polynomials).\n/// - `BIT`: per-coefficient bit bound used by the packing layout (compile-time).\n///\n/// ## Returns\n/// - The same `inputs` vector, extended with all carriers in deterministic order.\npub fn flatten<let A: u32, let L: u32, let BIT: u32>(\n    mut inputs: Vec<Field>,\n    poly: [Polynomial<A>; L],\n) -> Vec<Field> {\n    for j in 0..L {\n        // Pack its A coefficients into `num_chunks` carriers using the same BIT layout.\n        let packed = pack::<A, BIT>(poly[j].coefficients);\n\n        // Append carriers in-order to `inputs` to keep a stable transcript layout.\n        for i in 0..packed.len() {\n            inputs.push(packed.get(i));\n        }\n    }\n\n    // Return the extended input stream.\n    inputs\n}\n\n/// Pack `A` values into a `Vec<Field>` of carriers using the shared hex-aligned layout.\n///\n/// ## What this does\n/// - Computes `(nibble_bits, group)` via `packing_layout::<BIT>()`.\n/// - Encodes each value as a limb `digit = v + 2^nibble_bits` and concatenates\n///   limbs in base `radix = 2^(nibble_bits + 4)` (one extra nibble of headroom).\n/// - Packs up to `group` limbs per carrier (fits within BN254 254-bit capacity).\n/// - Pads the last, partial carrier with `digit = 2^nibble_bits` to keep a stable layout.\n///\n/// ## Determinism & order\n/// - Processes values in increasing index order and emits carriers in chunk order\n///   (`chunk = 0..num_chunks`). Padding is deterministic.\n///\n/// ## Generics\n/// - `A`: number of input values.\n/// - `BIT`: per-value bit bound; rounded up to `nibble_bits` by `packing_layout`.\n///\n/// ## Preconditions / Notes\n/// - Call with the raw coefficients whose magnitudes already satisfy the BIT bound\n///   (as enforced by the upstream range checks); `pack` performs the signed -> unsigned\n///   shift internally via `v + base`.\n/// - `group >= 1` is enforced by `packing_layout::<BIT>()`.\n/// - Padding with `digit = 2^nibble_bits` encodes `zero limb` consistently.\n///\n/// ## Returns\n/// - A `Vec<Field>` where each element is a concatenation of up to `group` limbs,\n///   suitable for hashing or transcript I/O.\npub fn pack<let A: u32, let BIT: u32>(values: [Field; A]) -> Vec<Field> {\n    // Layout parameters: nibble-aligned width and limbs-per-carrier group size.\n    let (nibble_bits, group) = packing_layout::<BIT>();\n\n    let base = 2.pow_32(nibble_bits as Field); // 2^nibble_bits\n    let radix = 2.pow_32((nibble_bits + 4) as Field); // 2^(nibble_bits + 4)\n\n    // Number of chunks to emit: ceil(A / group).\n    let num_chunks = (A + group - 1) / group;\n    let mut out = Vec::new();\n\n    // Process in fixed-size chunks of `group` limbs.\n    for chunk in 0..num_chunks {\n        // How many real values go into this chunk.\n        let remain = A - (chunk * group);\n        let take = if remain < group { remain } else { group };\n\n        // Build field element accumulator (big-endian concatenation in `radix`).\n        let mut acc = 0;\n        for i in 0..take {\n            let v = values[chunk * group + i];\n            acc = acc * radix + (v + base);\n        }\n\n        // Pad remaining limb slots with the canonical zero-limb `digit = base`.\n        for _ in 0..(group - take) {\n            acc = acc * radix + base;\n        }\n\n        out.push(acc);\n    }\n    out\n}\n\n/// Computes a cryptographic hash using the SAFE (Sponge API for Field Elements) protocol.\n///\n/// This is a convenience wrapper around the SAFE sponge API that handles the full\n/// lifecycle: initialization, absorption, squeezing, and finalization. It's designed\n/// for use in Fiat-Shamir challenge generation and commitment schemes within zero-knowledge circuits.\n///\n/// # Arguments\n/// * `domain_separator` - A 64-byte domain separator used to differentiate between\n///                        different protocol instances and prevent cross-protocol attacks.\n/// * `inputs` - Vector of field elements to be absorbed into the sponge.\n/// * `io_pattern` - A 2-element array encoding the I/O pattern:\n///                 - `io_pattern[0]`: Encoded ABSORB operation (MSB=1, lower 31 bits = length)\n///                 - `io_pattern[1]`: Encoded SQUEEZE operation (MSB=0, lower 31 bits = length)\n///\n/// # Returns\n/// A vector of field elements squeezed from the sponge, with length determined by\n/// the SQUEEZE operation in the IO pattern.\npub fn compute_safe(\n    domain_separator: [u8; 64],\n    inputs: Vec<Field>,\n    io_pattern: [u32; 2],\n) -> Vec<Field> {\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(inputs);\n    let digests = sponge.squeeze();\n    sponge.finish();\n\n    digests\n}\n\n#[test]\nfn test_flatten() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([1, 2, 3]); // degree 2\n    let poly2 = Polynomial::new([4, -16, 6]); // degree 2\n    let poly3 = Polynomial::new([-7, 8, 9]); // degree 2\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 4>(inputs, polynomials);\n\n    // Verify the flattened coefficients are in the correct positions\n    // Every value shifted 1 nibble incase of negative integers\n    assert(result.get(0) == 0x11121310101010101010101010101010101010101010101010101010101010);\n    assert(result.get(1) == 0x14001610101010101010101010101010101010101010101010101010101010); // -16 became 00 at  0x 14 00 16,\n    assert(result.get(2) == 0x09181910101010101010101010101010101010101010101010101010101010); // -7 became 09 at 0x 09 18 19(16 - 7 = 9)\n}\n\n#[test]\nfn test_flatten_big() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([\n        1791218451968394,\n        21888242871839275222246405745257275088548364400416034343698198265248580087864,\n        21888242871839275222246405745257275088548364400416034343698200542108324633466,\n        5430119342984413,\n        704811298945172,\n        8901715723925099,\n        21888242871839275222246405745257275088548364400416034343698203098124042812559,\n        21888242871839275222246405745257275088548364400416034343698200215091693880034,\n    ]);\n    let poly2 = Polynomial::new([\n        21888242871839275222246405745257275088548364400416034343698200314078269634250,\n        21888242871839275222246405745257275088548364400416034343698200967285641915872,\n        2909990636858607,\n        7896103832076587,\n        2078397209533893,\n        21888242871839275222246405745257275088548364400416034343698199792421452734531,\n        614400389245817,\n        8290314119277588,\n    ]);\n    let poly3 = Polynomial::new([\n        21888242871839275222246405745257275088548364400416034343698201373175279892906,\n        21888242871839275222246405745257275088548364400416034343698201087241869723721,\n        6768789983786188,\n        635797784303388,\n        7610153424227556,\n        4633893206538324,\n        2016269760615332,\n        21888242871839275222246405745257275088548364400416034343698201007080554428142,\n    ]);\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 54>(inputs, polynomials);\n\n    // Verify the flattened coefficients are in the correct positions\n    // Every value shifted 1 nibble incase of negative integers\n\n    // For the first index of result operation goes like this,\n\n    // First four index of poly1\n    // 1791218451968394,\n    // 21888242871839275222246405745257275088548364400416034343698198265248580087864,\n    // 21888242871839275222246405745257275088548364400416034343698200542108324633466,\n    // 5430119342984413,\n\n    // base + 1791218451968394 = 0x1065d1a8b8b718a\n    // base - 5921327228407753 = 0xeaf69591f3b037 (negative coefficient shifted)\n    // base - 3644467483862151 = 0xf30d604a3a9b79 (negative coefficient shifted)\n    // base + 5430119342984413 = 0x1134aaa2e86ccdd\n    assert(result.get(0) == 0x1065d1a8b8b718a0eaf69591f3b0370f30d604a3a9b791134aaa2e86ccdd);\n    assert(result.get(1) == 0x1028105ab1b789411fa010339db66b0fc220f1326bc8e0f1e3f4cc1e02e1);\n    assert(result.get(2) == 0x0f23dfbe7cd76c90f4901299312ddf10a569efe35acef11c0d76f005412b);\n    assert(result.get(3) == 0x107624a8f605dc50f0638a368960421022ecb3cf36b7911d73ff2c27ec14);\n    assert(result.get(4) == 0x0f6013a24e1b9a90f4fd2c158a08481180c2dba8af4cc10242413515171c);\n    assert(result.get(5) == 0x11b0964eb898ce411076805680b85410729c962da53a40f4b44412d0f6ed);\n}\n\n#[test]\nfn test_flatten_small() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([712345, 104857, 999999, 500001, 123, 654321, 77]);\n    let poly2 = Polynomial::new([1, 524287, 888888, 23456, 34567, 765432, 0]);\n    let poly3 = Polynomial::new([444444, 333333, 222222, 111111, 987654, 246810, 13579]);\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 20>(inputs, polynomials);\n\n    assert(result.get(0) == 0x1ade991199991f423f17a12110007b19fbf110004d100000100000100000);\n    assert(result.get(1) == 0x10000117ffff1d9038105ba01087071badf8100000100000100000100000);\n    assert(result.get(2) == 0x16c81c15161513640e11b2071f120613c41a10350b100000100000100000);\n}\n\n#[test]\nfn test_safe_hashing_with_safe_helper() {\n    // Verifies basic hash functionality with a simple ABSORB(3) + SQUEEZE(1) pattern.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice(&[1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let digests1 = compute_safe(domain_separator, elements, io_pattern);\n\n    assert(digests1.len() == 1);\n    assert(digests1.get(0) != 0);\n\n    // Test determinism\n    let digests2 = compute_safe(domain_separator, elements, io_pattern);\n\n    assert(digests2.len() == 1);\n    assert(digests2.get(0) != 0);\n    assert(digests2.get(0) == digests1.get(0));\n}\n\n#[test]\nfn test_pack() {\n    // Test pack function directly with small values\n    let values = [1, 2, 3, 4];\n    let packed = pack::<4, 4>(values);\n\n    // With BIT=4, nibble_bits=4, group should be floor(254/(4+4)) = 31\n    // So all 4 values should fit in one carrier\n    assert(packed.len() >= 1);\n\n    // Test with negative values\n    let values_neg = [-1, 2, -3, 4];\n    let packed_neg = pack::<4, 4>(values_neg);\n    assert(packed_neg.len() >= 1);\n}\n\n#[test]\nfn test_pack_single_value() {\n    // Test packing a single value\n    let values = [42];\n    let packed = pack::<1, 8>(values);\n    assert(packed.len() == 1);\n    assert(packed.get(0) != 0);\n}\n\n#[test]\nfn test_pack_determinism() {\n    // Test that packing is deterministic\n    let values = [10, 20, 30];\n    let packed1 = pack::<3, 8>(values);\n    let packed2 = pack::<3, 8>(values);\n\n    assert(packed1.len() == packed2.len());\n    for i in 0..packed1.len() {\n        assert(packed1.get(i) == packed2.get(i));\n    }\n}\n",
      "path": "/Users/ctrlc03/Documents/zk/enclave/circuits/lib/src/math/helpers.nr"
    },
    "80": {
      "source": "// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse super::modulo::U128::ModU128;\n\n/// Polynomial structure representing a polynomial of degree N-1.\n///\n/// A polynomial P(X) = a_{N-1} * X^{N-1} + a_{N-2} * X^{N-2} + ... + a_1 * X + a_0\n/// is represented as an array of coefficients where coefficients[0] = a_{N-1} (highest degree)\n/// and coefficients[N-1] = a_0 (constant term).\npub struct Polynomial<let N: u32> {\n    /// Array of polynomial coefficients in descending degree order\n    /// coefficients[0] = coefficient of X^{N-1} (highest degree term)\n    /// coefficients[N-1] = constant term (degree 0)\n    pub coefficients: [Field; N],\n}\n\nimpl<let N: u32> Polynomial<N> {\n    /// Creates a new polynomial from an array of coefficients.\n    ///\n    /// # Arguments\n    /// * `coefficients` - Array of N coefficients in descending degree order\n    ///                    coefficients[0] = coefficient of X^{N-1}\n    ///                    coefficients[N-1] = constant term\n    ///\n    /// # Returns\n    /// A new Polynomial instance with the specified coefficients\n    pub fn new(coefficients: [Field; N]) -> Self {\n        Polynomial { coefficients }\n    }\n\n    /// Adds two polynomials.\n    ///\n    /// # Arguments\n    /// * `other` - The polynomial to add to the current polynomial.\n    ///\n    /// # Returns\n    /// A new polynomial with the coefficients added.\n    pub fn add(self, other: Self) -> Self {\n        let mut result = Self::new([0; N]);\n\n        for i in 0..N {\n            result.coefficients[i] = self.coefficients[i] + other.coefficients[i];\n        }\n\n        result\n    }\n\n    /// Subtracts two polynomials.\n    ///\n    /// # Arguments\n    /// * `other` - The polynomial to subtract from the current polynomial.\n    ///\n    /// # Returns\n    /// A new polynomial with the coefficients subtracted.\n    pub fn sub(self, other: Self) -> Self {\n        let mut result = Self::new([0; N]);\n\n        for i in 0..N {\n            result.coefficients[i] = self.coefficients[i] - other.coefficients[i];\n        }\n\n        result\n    }\n\n    /// Multiplies a polynomial by a scalar.\n    ///\n    /// # Arguments\n    /// * `scalar` - The scalar to multiply the polynomial by.\n    ///\n    /// # Returns\n    /// A new polynomial with the coefficients multiplied by the scalar.\n    pub fn mul_scalar(self, scalar: Field) -> Self {\n        let mut result = Self::new([0; N]);\n\n        for i in 0..N {\n            result.coefficients[i] = self.coefficients[i] * scalar;\n        }\n\n        result\n    }\n\n    /// Evaluates the polynomial at a given point using Horner's method.\n    ///\n    /// Horner's method computes P(x) = a_{N-1} * x^{N-1} + ... + a_1 * x + a_0\n    /// as ((...((a_{N-1} * x + a_{N-2}) * x + a_{N-3}) * x + ...) * x + a_0)\n    /// This approach require n multiplications and n additions to evaluate the polynomial.\n    ///\n    /// # Arguments\n    /// * `x` - The point at which to evaluate the polynomial.\n    ///\n    /// # Returns\n    /// The value of the polynomial at point x: P(x).\n    pub fn eval(self, x: Field) -> Field {\n        let mut result = self.coefficients[0];\n\n        for i in 1..self.coefficients.len() {\n            result = result * x + self.coefficients[i];\n        }\n\n        result\n    }\n\n    /// Evaluates the polynomial at a given point with modular reduction.\n    ///\n    /// This function computes `P(x) mod q` using Horner's method with intermediate\n    /// modular reductions to prevent overflow. The result is guaranteed to be in\n    /// the range `[0, q)`.\n    ///\n    /// The function performs modular reduction after each multiplication and addition\n    /// to ensure the accumulator always remains in the range `[0, q)`, preventing\n    /// any potential overflow issues.\n    ///\n    /// # Arguments\n    /// * `x` - The point at which to evaluate the polynomial\n    /// * `q` - The modular arithmetic context containing the modulus\n    ///\n    /// # Returns\n    /// The value `P(x) mod q` in the range `[0, q)`\n    pub fn eval_mod(self, x: Field, q: ModU128) -> Field {\n        let mut acc = self.coefficients[0];\n        let len = self.coefficients.len();\n\n        for i in 1..len {\n            acc = q.mul_mod(acc, x);\n            acc = q.add(acc, self.coefficients[i]);\n        }\n\n        acc\n    }\n\n    /// Performs range checking on polynomial coefficients using asymmetric bounds.\n    ///\n    /// This function constrains all polynomial coefficients to be in the range [-lower_bound, upper_bound],\n    /// where `lower_bound` is a non-negative magnitude.\n    /// It uses a shifting technique to handle negative numbers efficiently:\n    /// 1. Shifts each coefficient by adding `lower_bound`: c' = c + lower_bound\n    /// 2. Checks that shifted coefficients are in [0, upper_bound + lower_bound] using bit-size assertions\n    /// 3. This ensures original coefficients are in [-lower_bound, upper_bound]\n    ///\n    /// The function uses two bit-size checks per coefficient to ensure the value is within bounds:\n    /// - `shifted_coefficient.assert_max_bit_size::<BIT + 1>()` ensures c' >= 0\n    /// - `(range_size - shifted_coefficient).assert_max_bit_size::<BIT + 1>()` ensures c' <= range_size\n    ///\n    /// # Arguments\n    /// * `upper_bound` - The upper bound for coefficient range checking\n    /// * `lower_bound` - Non-negative magnitude of the negative bound\n    ///                   Coefficients must satisfy: -lower_bound <= c <= upper_bound\n    ///\n    /// # Generic Parameters\n    /// * `BIT` - The bit-length of the total range `upper_bound + lower_bound`\n    ///           (choose `BIT` so `upper_bound + lower_bound < 2^BIT`). Since all checked\n    ///           values lie in `[0, upper_bound + lower_bound]`, they cannot exceed `BIT + 1` bits.\n    ///\n    /// # Panics\n    /// This function will cause the circuit to fail if any coefficient is outside\n    /// the specified bounds.\n    pub fn range_check_2bounds<let BIT: u32>(self, upper_bound: Field, lower_bound: Field) {\n        let range_size = lower_bound + upper_bound;\n\n        for i in 0..self.coefficients.len() {\n            let shifted_coefficient = self.coefficients[i] + lower_bound;\n\n            shifted_coefficient.assert_max_bit_size::<BIT + 1>();\n            (range_size - shifted_coefficient).assert_max_bit_size::<BIT + 1>();\n        }\n    }\n\n    /// Performs range checking on polynomial coefficients for the range [0, upper_bound).\n    ///\n    /// This function constrains all polynomial coefficients to be non-negative and\n    /// strictly less than `upper_bound`. It uses bit-size assertions to verify that\n    /// coefficients are in the valid range.\n    ///\n    /// The function performs two checks per coefficient:\n    /// 1. `coeff.assert_max_bit_size::<BIT>()` ensures `coeff >= 0` and `coeff < 2^BIT`\n    /// 2. `(upper_bound - 1 - coeff).assert_max_bit_size::<BIT>()` ensures `coeff < upper_bound`\n    ///\n    /// # Arguments\n    /// * `upper_bound` - The exclusive upper bound for coefficient range checking.\n    ///                   Coefficients must satisfy: `0 <= c < upper_bound`\n    ///\n    /// # Generic Parameters\n    /// * `BIT` - The bit-length parameter. Must satisfy `upper_bound <= 2^BIT` for\n    ///           the range check to work correctly.\n    ///\n    /// # Panics\n    /// This function will cause the circuit to fail if any coefficient is outside\n    /// the range `[0, upper_bound)`.\n    pub fn range_check_standard<let BIT: u32>(self, upper_bound: Field) {\n        for i in 0..self.coefficients.len() {\n            let coeff = self.coefficients[i];\n            // Check coeff >= 0 and coeff < 2^BIT\n            coeff.assert_max_bit_size::<BIT>();\n            // Check coeff <= upper_bound - 1 (i.e., coeff < upper_bound)\n            (upper_bound - 1 - coeff).assert_max_bit_size::<BIT>();\n        }\n    }\n\n    /// Performs range checking on polynomial coefficients for the range [0, 2^BIT).\n    ///\n    /// This is a specialized range check for coefficients that must be non-negative\n    /// and less than a power of two. It's more efficient than `range_check_standard`\n    /// when the upper bound is exactly `2^BIT` because it only needs a single\n    /// bit-size assertion per coefficient.\n    ///\n    /// The function verifies that each coefficient satisfies:\n    /// - `coeff >= 0` (implicit from bit-size check)\n    /// - `coeff < 2^BIT` (enforced by `assert_max_bit_size::<BIT>()`)\n    ///\n    /// # Generic Parameters\n    /// * `BIT` - The bit-length parameter. Coefficients must satisfy: `0 <= c < 2^BIT`\n    ///\n    /// # Panics\n    /// This function will cause the circuit to fail if any coefficient is outside\n    /// the range `[0, 2^BIT)`.\n    pub fn range_check_power_of_two<let BIT: u32>(self) {\n        for i in 0..self.coefficients.len() {\n            self.coefficients[i].assert_max_bit_size::<BIT>();\n        }\n    }\n}\n\n#[test]\nfn test_polynomial_eval() {\n    let coeffs = [1, 2, 3]; // represents 1x^2 + 2x + 3\n    let poly = Polynomial::new(coeffs);\n\n    let x = 2; // evaluate at x = 2\n    let result = poly.eval(x);\n\n    // (1 * 2^2) + (2 * 2) + 3 = 4 + 4 + 3 = 11\n    assert(result == 11);\n}\n\n#[test]\nfn test_polynomial_eval_zero() {\n    let coeffs = [1, -2, 1]; // x^2 - 2x + 1 = (x-1)^2\n    let poly = Polynomial::new(coeffs);\n\n    let x = 1; // evaluate at x = 1, should be 0\n    let result = poly.eval(x);\n\n    assert(result == 0);\n}\n\n#[test]\nfn test_polynomial_bounds() {\n    let coeffs = [-16, 240, 242];\n    let poly = Polynomial::new(coeffs);\n\n    // Test double bounds check - constrains to [-240, 242]\n    poly.range_check_2bounds::<8>(242, 240);\n}\n\n#[test(should_fail_with = \"assert_max_bit_size\")]\nfn test_polynomial_out_of_bounds_coefficients() {\n    let coeffs = [-100];\n    let poly = Polynomial::new(coeffs);\n\n    // Test double bounds check - constrains to [-98, 99]\n    // Should fail because -100 is out of bounds.\n    poly.range_check_2bounds::<7>(99, 98);\n}\n\n#[test]\nfn test_polynomial_add() {\n    let coeffs1 = [1, 2, 3]; // 1x^2 + 2x + 3\n    let coeffs2 = [4, 5, 6]; // 4x^2 + 5x + 6\n    let poly1 = Polynomial::new(coeffs1);\n    let poly2 = Polynomial::new(coeffs2);\n\n    let result = poly1.add(poly2);\n\n    // Expected: (1+4)x^2 + (2+5)x + (3+6) = 5x^2 + 7x + 9\n    assert(result.coefficients[0] == 5);\n    assert(result.coefficients[1] == 7);\n    assert(result.coefficients[2] == 9);\n}\n\n#[test]\nfn test_polynomial_sub() {\n    let coeffs1 = [5, 7, 9]; // 5x^2 + 7x + 9\n    let coeffs2 = [1, 2, 3]; // 1x^2 + 2x + 3\n    let poly1 = Polynomial::new(coeffs1);\n    let poly2 = Polynomial::new(coeffs2);\n\n    let result = poly1.sub(poly2);\n\n    // Expected: (5-1)x^2 + (7-2)x + (9-3) = 4x^2 + 5x + 6\n    assert(result.coefficients[0] == 4);\n    assert(result.coefficients[1] == 5);\n    assert(result.coefficients[2] == 6);\n}\n\n#[test]\nfn test_polynomial_mul_scalar() {\n    let coeffs = [1, 2, 3]; // 1x^2 + 2x + 3\n    let poly = Polynomial::new(coeffs);\n    let scalar = 5;\n\n    let result = poly.mul_scalar(scalar);\n\n    // Expected: 5x^2 + 10x + 15\n    assert(result.coefficients[0] == 5);\n    assert(result.coefficients[1] == 10);\n    assert(result.coefficients[2] == 15);\n}\n\n#[test]\nfn test_polynomial_mul_scalar_zero() {\n    let coeffs = [1, 2, 3];\n    let poly = Polynomial::new(coeffs);\n    let scalar = 0;\n\n    let result = poly.mul_scalar(scalar);\n\n    // Expected: 0x^2 + 0x + 0 = 0\n    assert(result.coefficients[0] == 0);\n    assert(result.coefficients[1] == 0);\n    assert(result.coefficients[2] == 0);\n}\n\n#[test]\nfn test_eval_mod_simple() {\n    // Test without initial reduction - simple case\n    // p(x) = x + 1 at x=5od 7\n    // Expected: (5 + 1) mod 7 = 6\n    let q = ModU128::new(7);\n\n    let poly1 = Polynomial::new([1, 1]);\n    let result1 = poly1.eval_mod(5, q);\n    assert(result1 == 6);\n\n    // Test: p(x) = 2x + 3 at x=5od 7\n    // Expected: (10 + 3) mod 7 = 13 mod 7 = 6\n    let poly2 = Polynomial::new([2, 3]);\n    let result2 = poly2.eval_mod(5, q);\n    assert(result2 == 6);\n}\n\n#[test]\nfn test_eval_mod_degree_2() {\n    // p(x) = x^2 + 2x + 3 at x=5od 7\n    // Using Horner's method: ((1)*5 + 2)*5 + 3 = (5+2)*5 + 3 = 7*5 + 3 = 35 + 3 = 38\n    // 38 mod 7 = 3 (since 38 = 5*7 + 3)\n    let q = ModU128::new(7);\n\n    let poly = Polynomial::new([1, 2, 3]);\n    let result = poly.eval_mod(5, q);\n    assert(result == 3);\n}\n\n#[test]\nfn test_eval_mod() {\n    // Test 1: Simple polynomial x^2 + 2x + 3 at x=5od 7\n    // Expected: (25 + 10 + 3) mod 7 = 38 mod 7 = 3\n    let q = ModU128::new(7);\n\n    let poly1 = Polynomial::new([1, 2, 3]);\n    let result1 = poly1.eval_mod(5, q);\n    assert(result1 == 3);\n\n    // Test 2: Higher degree polynomialod small prime\n    // p(x) = x^3 + x^2 + x + 1 at x=2od 11\n    // Expected: (8 + 4 + 2 + 1) mod 11 = 15 mod 11 = 4\n    let q = ModU128::new(11);\n\n    let poly2 = Polynomial::new([1, 1, 1, 1]);\n    let result2 = poly2.eval_mod(2, q);\n    assert(result2 == 4);\n\n    // Test 3: Polynomial with larger coefficients\n    // p(x) = 100x^2 + 50x + 25 at x=10od 73\n    // Expected: (10000 + 500 + 25) mod 73 = 10525 mod 73 = 13\n    let q = ModU128::new(73);\n\n    let poly3 = Polynomial::new([100, 50, 25]);\n    let result3 = poly3.eval_mod(10, q);\n    assert(result3 == 13);\n\n    // Test 4: Result should be less than modulus\n    let poly4 = Polynomial::new([5, 3, 7]);\n    let q = ModU128::new(17);\n    let result4 = poly4.eval_mod(4, q);\n    assert(result4 as u128 < q.get_mod_field() as u128);\n\n    // Test 5: Compare with regular eval for small values\n    let poly5 = Polynomial::new([1, 2, 1]);\n    let x = 3;\n    let q = ModU128::new(1000);\n    let result5 = poly5.eval_mod(x, q);\n    let expected5 = poly5.eval(x);\n    assert(result5 == expected5);\n\n    // Test 6: Zero polynomial\n    let poly6 = Polynomial::new([0, 0, 0]);\n    let q = ModU128::new(13);\n    let result6 = poly6.eval_mod(100, q);\n    assert(result6 == 0);\n}\n\n#[test]\nfn test_large_party_ids_scenario() {\n    // Simulating party IDs in range [1, 100]\n    let party_id_1 = 42;\n    let party_id_2 = 73;\n    let m = ModU128::new(288230376151711717); // ~58 bits\n\n    // Operations that would be used in Lagrange coefficients\n    let product = m.mul_mod(party_id_1, party_id_2);\n    let diff = m.sub(party_id_2, party_id_1);\n\n    assert(product == 3066);\n    assert(diff == 31);\n}\n\n#[test]\nfn test_eval_vs_eval_mod() {\n    // Compare eval and eval_mod for small values where no reduction should occur\n    let poly = Polynomial::new([1, 2, 3]);\n    let x = 2;\n    let q = ModU128::new(1000); // Large enough that no reduction happens\n\n    let result_normal = poly.eval(x);\n    let result_mod = poly.eval_mod(x, q);\n\n    // They should be equal: (1)*2 + 2)*2 + 3 = (2+2)*2 + 3 = 4*2 + 3 = 11\n    assert(result_normal == 11);\n    assert(result_mod == 11);\n}\n\n#[test]\nfn test_eval_mod_step_by_step() {\n    // p(x) = x + 1 at x=5od 7\n    // Step by step: acc = 1, then acc = 1*5 + 1 = 6\n    let poly = Polynomial::new([1, 1]);\n\n    // Manually compute\n    let mut acc = 1; // coefficients[0]\n    acc = acc * 5 + 1; // = 6\n    assert(acc == 6);\n\n    // Now with reduce_mod\n    let m = ModU128::new(7);\n    let reduced = m.reduce_mod(acc);\n    assert(reduced == 6);\n\n    // Now test the actual function\n    let result = poly.eval_mod(5, m);\n    assert(result == 6);\n}\n",
      "path": "/Users/ctrlc03/Documents/zk/enclave/circuits/lib/src/math/polynomial.nr"
    },
    "81": {
      "source": "// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse keccak256::keccak256;\nuse poseidon::poseidon2_permutation;\n\n/// SAFE (Sponge API for Field Elements)\n///\n/// This module provides a complete implementation of the SAFE API in Noir as defined in:\n/// \"SAFE (Sponge API for Field Elements) - A Toolbox for ZK Hash Applications\"\n/// see https://hackmd.io/bHgsH6mMStCVibM_wYvb2w#22-Sponge-state for more details.\n///\n/// SAFE provides a unified interface for cryptographic sponge functions that can be\n/// instantiated with various permutations to create hash functions, MACs, authenticated\n/// encryption schemes, and other cryptographic primitives for ZK proof systems.\n///\n/// This implementation follows the SAFE specification exactly, providing:\n/// - Complete API: START, ABSORB, SQUEEZE, FINISH operations.\n/// - Full security: Domain separation, tag computation, IO pattern validation.\n/// - Poseidon2 integration: Field-friendly permutation for ZK systems.\n/// - Specification compliance: All operations follow SAFE spec 2.4 exactly.\n/// - Natural API design: Variable-length inputs, automatic length detection from IO patterns.\n///\n/// # API Design\n///\n/// The API is designed for natural usage while maintaining type safety:\n/// - `absorb(input: [Field])`: Accepts variable-length arrays, no padding required.\n/// - `squeeze()`: Returns a vector with field element(s).\n/// - IO patterns automatically determine operation lengths for validation.\n\n/// Rate parameter for the sponge construction (number of field elements that can be absorbed per permutation call).\nglobal RATE: u32 = 3;\n\n/// Capacity parameter for the sponge construction (security parameter, typically 1-2 field elements).\nglobal CAPACITY: u32 = 1;\n\n/// Total state size (rate + capacity) in field elements.\nglobal STATE_SIZE: u32 = RATE + CAPACITY;\n\n/// IO Pattern encoding constants (from SAFE spec 2.3).\n///\n/// These constants are used for encoding operation types in the 32-bit word format:\n/// - MSB set to 1 for ABSORB operations\n/// - MSB set to 0 for SQUEEZE operations\n\n/// Flag for ABSORB operations (MSB = 1)\nglobal ABSORB_FLAG: u32 = 0x80000000;\n\n/// Flag for SQUEEZE operations (MSB = 0)\nglobal SQUEEZE_FLAG: u32 = 0x00000000;\n\n/// SAFE Sponge State (following spec 2.2)\n///\n/// The sponge state consists of the permutation state, tag, position counters,\n/// and IO pattern tracking as defined in the SAFE specification.\n///\n/// # Generic Parameters\n/// - `L`: The length of the IO pattern array\n///\n/// # Fields\n/// - `state`: Permutation state V in F^n (rate + capacity elements)\n/// - `tag`: Parameter tag T used for instance differentiation\n/// - `absorb_pos`: Current absorb position (<= n-c)\n/// - `squeeze_pos`: Current squeeze position (<= n-c)\n/// - `io_pattern`: Expected IO pattern for validation (encoded 32-bit words)\n/// - `io_count`: Current operation count for pattern tracking\npub struct SafeSponge<let L: u32> {\n    /// Permutation state V in F^n (rate + capacity elements).\n    state: [Field; STATE_SIZE],\n    /// Parameter tag T used for instance differentiation.\n    tag: Field,\n    /// Current absorb position (<= n-c).\n    absorb_pos: u32,\n    /// Current squeeze position (<= n-c).\n    squeeze_pos: u32,\n    /// Expected IO pattern for validation.\n    io_pattern: [u32; L],\n    /// Current operation count for pattern tracking (spec 2.4: io_count).\n    io_count: u32,\n}\n\nimpl<let L: u32> SafeSponge<L> {\n    /// Initializes a new SAFE sponge instance with the given IO pattern and domain separator (following spec 2.4).\n    ///\n    /// # Arguments\n    /// - `io_pattern`: Array of 32-bit encoded operations defining the expected sequence of ABSORB/SQUEEZE calls.\n    ///               Each word has MSB=1 for ABSORB operations, MSB=0 for SQUEEZE operations.\n    /// - `domain_separator`: 64-byte domain separator for cross-protocol security.\n    ///\n    /// # Returns\n    /// A new `SafeSponge` instance with initialized state\n    pub fn start(io_pattern: [u32; L], domain_separator: [u8; 64]) -> SafeSponge<L> {\n        // Compute tag from IO pattern and domain separator (spec 2.3).\n        let tag = compute_tag(io_pattern, domain_separator);\n\n        let mut state = [0; STATE_SIZE];\n        // Initialize capacity with tag (spec 2.4).\n        // Add T to the first 128 bits of the state.\n        state[0] = tag;\n\n        SafeSponge { state, tag, absorb_pos: 0, squeeze_pos: 0, io_pattern, io_count: 0 }\n    }\n\n    /// Absorbs field elements into the sponge state, interleaving permutation calls as needed (following spec 2.4).\n    ///\n    /// The number of elements to absorb is automatically validated against the IO pattern.\n    /// This method accepts variable-length arrays, making it natural to use without padding.\n    ///\n    /// # Arguments\n    /// - `input`: Array of field elements to absorb (variable length, must match IO pattern)\n    pub fn absorb(&mut self, input: Vec<Field>) {\n        let length = input.len() as u32;\n\n        // Validate against IO pattern.\n        assert(self.io_count < L);\n\n        // Parse expected operation from io_pattern (encoded word)\n        let expected_encoded_word = self.io_pattern[self.io_count];\n        let is_expected_absorb = (expected_encoded_word & ABSORB_FLAG) != 0;\n        let expected_length = expected_encoded_word & 0x7FFFFFFF;\n\n        // Validate operation type and length\n        assert(is_expected_absorb, \"Expected ABSORB operation\");\n        assert(expected_length == length, \"Length mismatch\");\n\n        // Process each element naturally (no unnecessary iterations).\n        for i in 0..length {\n            // If absorb_pos == (n-c) then permute and reset (spec 2.4).\n            if self.absorb_pos == RATE {\n                // n-c = RATE.\n                self.state = self.permute();\n                self.absorb_pos = 0;\n            }\n\n            // Add X[i] to state at absorb_pos (spec 2.4).\n            // Note: absorb_pos is the rate position, not capacity position.\n            self.state[self.absorb_pos + CAPACITY] =\n                self.state[self.absorb_pos + CAPACITY] + input.get(i);\n            self.absorb_pos += 1;\n        }\n\n        // Verify that the encoded word matches the expected pattern.\n        let encoded_word = ABSORB_FLAG | length;\n        assert(encoded_word == expected_encoded_word);\n\n        self.io_count += 1;\n\n        // Force permute at start of next SQUEEZE (spec 2.4).\n        self.squeeze_pos = RATE;\n    }\n\n    /// Extracts field elements from the sponge state, interleaving permutation calls as needed (following spec 2.4).\n    ///\n    /// The number of elements to squeeze is automatically determined from the IO pattern.\n    pub fn squeeze(&mut self) -> Vec<Field> {\n        // Validate against IO pattern.\n        assert(self.io_count < L);\n\n        // Parse expected operation from io_pattern (encoded word)\n        let expected_encoded_word = self.io_pattern[self.io_count];\n        let is_expected_squeeze = (expected_encoded_word & ABSORB_FLAG) == 0;\n        let length = expected_encoded_word & 0x7FFFFFFF;\n\n        // Validate operation type\n        assert(is_expected_squeeze, \"Expected SQUEEZE operation\");\n\n        let mut output = Vec::new();\n\n        // SQUEEZE implementation following spec 2.4.\n        // If length==0, loop won't execute (spec 2.4).\n        for _ in 0..length {\n            // If squeeze_pos==(n-c) then permute and reset (spec 2.4).\n            if self.squeeze_pos == RATE {\n                // n-c = RATE.\n                self.state = self.permute();\n                self.squeeze_pos = 0;\n                self.absorb_pos = 0;\n            }\n            // Set Y[i] to state element at squeeze_pos (spec 2.4).\n            output.push(self.state[self.squeeze_pos + CAPACITY]);\n            self.squeeze_pos += 1;\n        }\n\n        // Verify that the encoded word matches the expected pattern.\n        let encoded_word = SQUEEZE_FLAG | length;\n        assert(encoded_word == expected_encoded_word);\n\n        self.io_count += 1;\n        output\n    }\n\n    /// Finalizes the sponge instance, verifying that all expected operations have been performed and clearing the internal state for security (following spec 2.4).\n    ///\n    /// This function is used to ensure that the sponge instance has been used correctly and to prevent information leakage.\n    pub fn finish(&mut self) {\n        // Check that io_count equals the length of the IO pattern expected (spec 2.4).\n        assert(self.io_count == L, \"IO pattern not completed\");\n\n        // Erase the state and its variables (spec 2.4).\n        self.state = [0; STATE_SIZE];\n        self.absorb_pos = 0;\n        self.squeeze_pos = 0;\n        self.io_count = 0;\n    }\n\n    /// Permute the state using Poseidon2 (following spec 2.4).\n    ///\n    /// Applies the Poseidon2 permutation to the current state.\n    /// This is the core cryptographic primitive of the sponge construction.\n    ///\n    /// # Returns\n    /// New state after permutation\n    fn permute(self) -> [Field; STATE_SIZE] {\n        poseidon2_permutation(self.state, STATE_SIZE)\n    }\n}\n\n/// Computes a unique tag for a sponge instance based on its IO pattern and domain separator.\n/// The tag is used to ensure that distinct instances behave like distinct functions.\n///\n/// # Arguments\n/// - `io_pattern`: Array of 32-bit encoded operations defining the sponge's usage pattern.\n///               Each word has MSB=1 for ABSORB operations, MSB=0 for SQUEEZE operations.\n/// - `domain_separator`: 64-byte domain separator for cross-protocol security.\n///\n/// # Returns\n/// A field element representing the 128-bit tag.\npub fn compute_tag<let L: u32>(io_pattern: [u32; L], domain_separator: [u8; 64]) -> Field {\n    // Step 1: Parse and aggregate consecutive operations of the same type\n    let mut encoded_words = [0; L]; // Support up to L operations.\n    let mut word_count = 0;\n    let mut current_absorb_sum = 0;\n    let mut current_squeeze_sum = 0;\n    let mut last_was_absorb = false;\n\n    for i in 0..L {\n        if io_pattern[i] > 0 {\n            // Parse operation type from MSB and length from lower 31 bits\n            let is_absorb = (io_pattern[i] & ABSORB_FLAG) != 0;\n            let length = io_pattern[i] & 0x7FFFFFFF; // Clear MSB to get length\n\n            if is_absorb {\n                if last_was_absorb {\n                    // Aggregate consecutive ABSORB operations\n                    current_absorb_sum += length;\n                } else {\n                    // Start new ABSORB sequence\n                    if current_squeeze_sum > 0 {\n                        // Flush previous SQUEEZE sequence\n                        encoded_words[word_count] = SQUEEZE_FLAG | current_squeeze_sum;\n                        word_count += 1;\n                        current_squeeze_sum = 0;\n                    }\n                    current_absorb_sum = length;\n                }\n                last_was_absorb = true;\n            } else {\n                if !last_was_absorb {\n                    // Aggregate consecutive SQUEEZE operations\n                    current_squeeze_sum += length;\n                } else {\n                    // Start new SQUEEZE sequence\n                    if current_absorb_sum > 0 {\n                        // Flush previous ABSORB sequence\n                        encoded_words[word_count] = ABSORB_FLAG | current_absorb_sum;\n                        word_count += 1;\n                        current_absorb_sum = 0;\n                    }\n                    current_squeeze_sum = length;\n                }\n                last_was_absorb = false;\n            }\n        }\n    }\n\n    // Flush remaining operations\n    if current_absorb_sum > 0 {\n        encoded_words[word_count] = ABSORB_FLAG | current_absorb_sum;\n        word_count += 1;\n    }\n    if current_squeeze_sum > 0 {\n        encoded_words[word_count] = SQUEEZE_FLAG | current_squeeze_sum;\n        word_count += 1;\n    }\n\n    // Step 2: Serialize to byte string and append domain separator (following SAFE spec 2.3).\n    // Buffer is 256 bytes: max 192 bytes for IO pattern (48 words) + 64 bytes for domain separator.\n    // Note: We must use a fixed-size array because Noir's keccak256 requires [u8; N], not Vec<u8>.\n    let max_io_pattern_bytes: u32 = 192; // 256 - 64 (domain separator)\n    let io_pattern_bytes = word_count * 4;\n    assert(\n        io_pattern_bytes <= max_io_pattern_bytes,\n        \"IO pattern too large: max 48 aggregated words supported\",\n    );\n\n    let mut input_bytes = [0u8; 256];\n    let mut byte_count: u32 = 0;\n\n    // Serialize encoded words to bytes (big-endian as per SAFE spec).\n    // Note: Noir requires compile-time loop bounds, so we iterate over L (the array size)\n    // instead of word_count (runtime value). The condition `i < word_count` ensures we only\n    // process valid encoded words. This is safe because word_count <= L always holds\n    // (we can have at most L encoded words from L input operations).\n    for i in 0..L {\n        if i < word_count {\n            let word = encoded_words[i];\n            input_bytes[byte_count] = (word >> 24) as u8;\n            input_bytes[byte_count + 1] = (word >> 16) as u8;\n            input_bytes[byte_count + 2] = (word >> 8) as u8;\n            input_bytes[byte_count + 3] = word as u8;\n            byte_count += 4;\n        }\n    }\n\n    // Append full 64-byte domain separator.\n    for i in 0..64 {\n        input_bytes[byte_count] = domain_separator[i];\n        byte_count += 1;\n    }\n\n    // Step 3: Hash with Keccak-256 and truncate to 128 bits.\n    // Note: The SAFE spec uses SHA3-256, but we use Keccak-256 for Noir compatibility.\n    // Keccak-256 differs from SHA3-256 in padding, but both provide equivalent security.\n    let hash_bytes = keccak256(input_bytes, byte_count);\n\n    // Convert first 128 bits (16 bytes) to field element.\n    let mut tag_value: Field = 0;\n    for i in 0..16 {\n        tag_value = tag_value * 256 + (hash_bytes[i] as Field);\n    }\n\n    tag_value\n}\n\n#[test]\nfn test_safe_hashing() {\n    // Verifies basic hash functionality with a simple ABSORB(3) + SQUEEZE(1) pattern.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice(&[1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(elements);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(elements);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_merkle_node() {\n    // Verifies SAFE can be used for Merkle tree node hashing with pattern ABSORB(1) + ABSORB(1) + SQUEEZE(1).\n    // Tests the ability to absorb multiple inputs before squeezing output.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let left = Vec::from_slice([123]);\n    let right = Vec::from_slice([456]);\n\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(left);\n    sponge.absorb(right);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(left);\n    sponge2.absorb(right);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_commitment_scheme() {\n    // Verifies SAFE can be used for commitment schemes with pattern ABSORB(3) + SQUEEZE(1).\n    // Tests the ability to create deterministic commitments from multiple field elements.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let values = Vec::from_slice([10, 20, 30]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(values);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(values);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_domain_separation() {\n    // Verifies that different domain separators produce different outputs for the same input.\n    // This is crucial for cross-protocol security and preventing collisions between different applications.\n    let elements = Vec::from_slice([1, 2, 3]);\n    let domain1 = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let domain2 = [\n        0x41, 0x42, 0x43, 0x45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n\n    let mut sponge1 = SafeSponge::start(io_pattern, domain1);\n    sponge1.absorb(elements);\n    let output1 = sponge1.squeeze();\n    sponge1.finish();\n\n    let mut sponge2 = SafeSponge::start(io_pattern, domain2);\n    sponge2.absorb(elements);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output1.len() == 1);\n    assert(output2.len() == 1);\n    assert(output1.get(0) != output2.get(0)); // Different domain separators should produce different outputs\n}\n\n#[test]\nfn test_multiple_squeeze() {\n    // Verifies that multiple field elements can be squeezed in a single operation.\n    // Tests pattern ABSORB(3) + SQUEEZE(2) to ensure proper state management.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice([1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(2)\n    let io_pattern = [0x80000003, 0x00000002];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(elements);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 2);\n    assert(output.get(0) != 0);\n    assert(output.get(1) != 0);\n    assert(output.get(0) != output.get(1)); // Different squeeze outputs should be different\n}\n\n#[test]\nfn test_zero_length_operations() {\n    // Verifies that zero-length ABSORB and SQUEEZE operations are handled correctly.\n    // Tests pattern ABSORB(0) + SQUEEZE(1) to ensure proper state transitions.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Pattern: ABSORB(0), SQUEEZE(1)\n    let io_pattern = [0x80000000, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(Vec::new());\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n}\n\n#[test]\nfn test_tag_computation() {\n    // Verifies the tag computation algorithm using the example from the SAFE specification.\n    // Pattern: ABSORB(3), ABSORB(3), SQUEEZE(3)\n    // Should aggregate to: ABSORB(6), SQUEEZE(3)\n    // Encoded as: [0x80000006, 0x00000003]\n    // Tests determinism and pattern differentiation.\n\n    let io_pattern = [0x80000003, 0x80000003, 0x00000003];\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test determinism\n    let tag2 = compute_tag(io_pattern, domain_separator);\n    assert(tag == tag2);\n\n    // Test that different patterns produce different tags\n    let io_pattern2 = [0x80000003, 0x00000003]; // ABSORB(3), SQUEEZE(3) - different pattern\n    let tag3 = compute_tag(io_pattern2, domain_separator);\n    assert(tag != tag3);\n}\n\n#[test]\nfn test_tag_computation_debug() {\n    println(\"=== SAFE Tag Computation Debug Test ===\");\n\n    // Test your specific pattern [2, 2, 2] (ABSORB(2), SQUEEZE(2), ABSORB(2))\n    let io_pattern = [0x80000002, 0x00000002, 0x80000002];\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    println(f\"Testing pattern: {io_pattern}\");\n    println(\n        f\"Expected to aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(2)\",\n    );\n    println(\n        f\"Expected encoded words: [0x80000002, 0x00000002, 0x80000002]\",\n    );\n    println(\"\");\n\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    println(f\"=== Expected Rust Output ===\");\n    println(\"Pattern [2, 2, 2] (ABSORB(2), SQUEEZE(2), ABSORB(2))\");\n    println(\"Domain separator: 0x41424344...\");\n    println(\"Tag: 0xce3bb9ee4b2d41c42e9cdda38afe8b6a\");\n    println(\"\");\n\n    println(f\"=== Noir Output ===\");\n    println(f\"Tag: {tag}\");\n    println(\"\");\n\n    println(\"Compare the tag values above with Rust script!\");\n}\n\n#[test]\nfn test_consecutive_absorb_aggregation() {\n    // Test that consecutive ABSORB operations are properly aggregated\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1) should aggregate to ABSORB(2), SQUEEZE(1)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), ABSORB(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001];\n\n    // This should aggregate to: ABSORB(2), SQUEEZE(1) = [0x80000002, 0x00000001]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag ABSORB(2), SQUEEZE(1)\n    let aggregated_pattern = [0x80000002, 0x00000001];\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(tag == aggregated_tag, \"Consecutive ABSORB operations should aggregate to the same tag\");\n\n    // Test that a different pattern produces a different tag\n    let different_pattern = [0x80000001, 0x00000001, 0x80000001]; // ABSORB(1), SQUEEZE(1), ABSORB(1)\n    let different_tag = compute_tag(different_pattern, domain_separator);\n\n    // This should be different because it doesn't have consecutive ABSORB operations\n    assert(tag != different_tag, \"Different patterns should produce different tags\");\n\n    println(\"=== Consecutive ABSORB Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x80000001, 0x00000001] (ABSORB(1), ABSORB(1), SQUEEZE(1))\",\n    );\n    println(\n        f\"Aggregated pattern: [0x80000002, 0x00000001] (ABSORB(2), SQUEEZE(1))\",\n    );\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Different pattern tag: {different_tag}\");\n}\n\n#[test]\nfn test_consecutive_squeeze_aggregation() {\n    // Test that consecutive SQUEEZE operations are properly aggregated\n    // Pattern: ABSORB(1), SQUEEZE(1), SQUEEZE(1) should aggregate to ABSORB(1), SQUEEZE(2)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), SQUEEZE(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x00000001, 0x00000001];\n\n    // This should aggregate to: ABSORB(1), SQUEEZE(2) = [0x80000001, 0x00000002]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag ABSORB(1), SQUEEZE(2)\n    let aggregated_pattern = [0x80000001, 0x00000002];\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(\n        tag == aggregated_tag,\n        \"Consecutive SQUEEZE operations should aggregate to the same tag\",\n    );\n\n    // Test that a different pattern produces a different tag\n    let different_pattern = [0x80000001, 0x00000001, 0x80000001]; // ABSORB(1), SQUEEZE(1), ABSORB(1)\n    let different_tag = compute_tag(different_pattern, domain_separator);\n\n    // This should be different because it doesn't have consecutive SQUEEZE operations\n    assert(tag != different_tag, \"Different patterns should produce different tags\");\n\n    println(\"=== Consecutive SQUEEZE Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x00000001, 0x00000001] (ABSORB(1), SQUEEZE(1), SQUEEZE(1))\",\n    );\n    println(\n        f\"Aggregated pattern: [0x80000001, 0x00000002] (ABSORB(1), SQUEEZE(2))\",\n    );\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Different pattern tag: {different_tag}\");\n}\n\n#[test]\nfn test_mixed_consecutive_aggregation() {\n    // Test that both consecutive ABSORB and SQUEEZE operations are properly aggregated\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1)\n    // Should aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(1)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001, 0x00000001, 0x80000001];\n\n    // This should aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(1) = [0x80000002, 0x00000002, 0x80000001]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag\n    let aggregated_pattern = [0x80000002, 0x00000002, 0x80000001]; // ABSORB(2), SQUEEZE(2), ABSORB(1)\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(tag == aggregated_tag, \"Mixed consecutive operations should aggregate to the same tag\");\n\n    println(\"=== Mixed Consecutive Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x80000001, 0x00000001, 0x00000001, 0x80000001]\",\n    );\n    println(\n        f\"  (ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1))\",\n    );\n    println(f\"Aggregated pattern: [0x80000002, 0x00000002, 0x80000001]\");\n    println(f\"  (ABSORB(2), SQUEEZE(2), ABSORB(1))\");\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n}\n\n#[test]\nfn test_large_io_pattern() {\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Create pattern with 48 alternating ABSORB(1) and SQUEEZE(1) operations\n    // This is the maximum supported (48 words * 4 bytes = 192 bytes, leaving 64 for domain separator)\n    let mut io_pattern = [0u32; 48];\n    for i in 0..48 {\n        if i % 2 == 0 {\n            io_pattern[i] = ABSORB_FLAG | 1; // ABSORB(1)\n        } else {\n            io_pattern[i] = SQUEEZE_FLAG | 1; // SQUEEZE(1)\n        }\n    }\n\n    let tag = compute_tag(io_pattern, domain_separator);\n    assert(tag != 0);\n}\n\n#[test]\nfn test_domain_separator_not_truncated() {\n    // This test verifies that the domain separator is always included in the tag computation,\n    // even for large IO patterns. If the domain separator were truncated, different domain\n    // separators would produce the same tag for large patterns.\n\n    let domain_separator_a = [\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41,\n    ]; // All 'A's\n\n    let domain_separator_b = [\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42,\n    ]; // All 'B's\n\n    // Create pattern with 48 alternating operations (max supported: 192 bytes of IO pattern)\n    let mut io_pattern = [0u32; 48];\n    for i in 0..48 {\n        if i % 2 == 0 {\n            io_pattern[i] = ABSORB_FLAG | 1;\n        } else {\n            io_pattern[i] = SQUEEZE_FLAG | 1;\n        }\n    }\n\n    let tag_a = compute_tag(io_pattern, domain_separator_a);\n    let tag_b = compute_tag(io_pattern, domain_separator_b);\n\n    // Tags MUST be different because domain separators are different.\n    // If they were the same, it would mean the domain separator was truncated/ignored.\n    assert(tag_a != tag_b, \"Domain separator must affect tag even for large IO patterns\");\n}\n",
      "path": "/Users/ctrlc03/Documents/zk/enclave/circuits/lib/src/math/safe.nr"
    }
  },
  "expression_width": { "Bounded": { "width": 4 } }
}
