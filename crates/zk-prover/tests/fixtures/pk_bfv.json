{
  "noir_version": "1.0.0-beta.14+60ccd48e18ad8ce50d5ecda9baf813b712145051",
  "hash": "7834455569795577208",
  "abi": {
    "parameters": [
      {
        "name": "pk0is",
        "type": {
          "kind": "array",
          "length": 1,
          "type": {
            "kind": "struct",
            "path": "lib::math::polynomial::Polynomial",
            "fields": [{ "name": "coefficients", "type": { "kind": "array", "length": 512, "type": { "kind": "field" } } }]
          }
        },
        "visibility": "private"
      },
      {
        "name": "pk1is",
        "type": {
          "kind": "array",
          "length": 1,
          "type": {
            "kind": "struct",
            "path": "lib::math::polynomial::Polynomial",
            "fields": [{ "name": "coefficients", "type": { "kind": "array", "length": 512, "type": { "kind": "field" } } }]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" },
    "error_types": {}
  },
  "bytecode": "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",
  "debug_symbols": "pdjRThtJEEbhd/E1F11/9XRP51VWq8ghJrJkGeTASivEu6/BdQpYaUYEcjOAM0f2TH3TLT9ufu5+PPz6vj/e3P7efPvrcfPjtD8c9r++H26vt/f72+P5r49PVxt+/X5/2u3Of9q8ef181t32tDveb74dHw6Hq80/28PDy3/6fbc9vhzvt6fzq+Vqszv+PB/PwZv9Yff809PV69ll+dQ6T3FyHXOePr0/35bPtzIrAmbVs9DeF7RcaBojCs2n8VoY7wq+UihtpmBWlgp1ueBlouClTVno5eOF6lnoY6nQlgvT+V8Upmkunyk0y0KTf6pQShbMvlpQXSqszYN3PkWrrqW7afblgTB9eSLWEx8aCatfnonVxMeGYj3xoan4cOJzY1E9HxPTmzfx/3s61t5EzzfRtZjQyuOyl5lEL2PxamptOM2Uwzm9uaftw4lpHo0PMsq8mFh5Zg6rXM5hoy4mVu5prc1YO94uHjb+4Fq0vKkq/TPX4l1C+tTlHPX1ctbld7E2FyauRTdffFxoZTp7ywHv5wlfehdevnxT3b5+U9c+yOxczj736d27+Pv82/Z6f3q3DdqUc/D8kLLLQZeDXw71cpguh3Y59MthvhxGnE4mOhYhi5JFyqJlEbOoWeQseoqeeF/RU/QUPUVP0VP0FD1Fz6Pn0XM+aPQ8eh49j55Hz6Pn0avRq9Gr0atcuejV6NXo1ejV6NXoTdGbojdFb4rexK2I3hS9KXpT9Kbotei16LXotei16DXubfRa9Fr0WvR69Hr0evR69Hr0evQ6wxK9Hr0evTl6c/Tm6M3Rm6M3R2+O3sz0RW+O3ojeiN6I3ojeiN6I3ojeiN5gnHOeGejCRBdGujDThaEuTHVhrAtzXRjsQvmVCuXEklqSS3pJMCkmyWDGQGNKhZRxY8Ax5Bh0DDsGHkOPwcfwY57AKUPIMGQgMhQZjAxHBiRDkkHJaj47KKPJ4GR4MkAZogxShikDlaHKpnwsUQaWIcugZdgycBm6DF6GLwOYtXziUcaYgcxQZjAznBnQDGkGNcOa9XyYUoab4c0AZ4gzyBnmDHSGOoOdzfmcpow8g55hz8Bn6DP4Gf4MgIZAG7kE5BrAIoBBYVAYFAaFQWFQGBQGhUFZLi+UMSgMCoPCoDAoDAqDynUrF67XlYtyrl25eOXqlctXrl+5gGFQGBQG5bkoUsagMCgMCoPCoDAoDAqDwqBqrreUMSgMCoPCoDAoDAqDwqAwqCmXcsoYFAaFQWFQGBQGhUFhUBhUy10CZQwKg8KgMCgMCoPCoDAoDKrnBoQyBoVBYVAYFAaFQWFQGBQGNefehjIGhUFhUBgUBoVBYVAYFAY1ctuU+yY2Thh0DDoGHYOOQcegY9Ax6Bh0yy0ZZQw6Bh2DjkHHoGPQMegYdAy6crdHGYOOQcegY9Ax6Bj03EXmNjL3ka8bScq5lcy9ZG4mczeZ20kMOgb92aDr+Qc9//D0vNc/7bc/Drv41vLm4Xj95kvM+3/veIWvOe9Ot9e7nw+n3fNO/+W1897/Pw==",
  "file_map": {
    "19": {
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n",
      "path": "std/hash/mod.nr"
    },
    "50": {
      "source": "// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse lib::configs::insecure::bfv::{L, N, PK_BFV_BIT_PK};\nuse lib::core::bfv_pk::BfvPkCommit;\nuse lib::math::polynomial::Polynomial;\n\nfn main(pk0is: [Polynomial<N>; L], pk1is: [Polynomial<N>; L]) -> pub Field {\n    let pk_bfv: BfvPkCommit<N, L, PK_BFV_BIT_PK> = BfvPkCommit::new(pk0is, pk1is);\n    pk_bfv.verify()\n}\n",
      "path": "/Users/ctrlc03/Documents/zk/enclave/circuits/bin/insecure/pk_bfv/src/main.nr"
    },
    "60": {
      "source": "// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse crate::math::commitments::compute_pk_bfv_commitment;\nuse crate::math::polynomial::Polynomial;\n\n/// BFV Public Key Commitment Circuit (Circuit 0).\n///\n/// commit to the BFV public key for later verification.\n/// No validation of pk correctness - that's caught by decryption failures in Circuit 4.\npub struct BfvPkCommit<let N: u32, let L: u32, let BIT_PK: u32> {\n    /// BFV public key components (public input)\n    /// pk0[i] is the first component for modulus i\n    pk0: [Polynomial<N>; L],\n    /// pk1[i] is the second component for modulus i\n    pk1: [Polynomial<N>; L],\n}\n\nimpl<let N: u32, let L: u32, let BIT_PK: u32> BfvPkCommit<N, L, BIT_PK> {\n    pub fn new(pk0: [Polynomial<N>; L], pk1: [Polynomial<N>; L]) -> Self {\n        BfvPkCommit { pk0, pk1 }\n    }\n\n    /// Main verification function\n    /// Returns commitment to BFV public key\n    pub fn verify(self) -> Field {\n        compute_pk_bfv_commitment::<N, L, BIT_PK>(self.pk0, self.pk1)\n    }\n}\n",
      "path": "/Users/ctrlc03/Documents/zk/enclave/circuits/lib/src/core/bfv_pk.nr"
    },
    "69": {
      "source": "// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse crate::math::helpers::{compute_safe, flatten};\nuse crate::math::polynomial::Polynomial;\n\n/// DOMAIN SEPARATORS\n\n// Domain separator - \"PK_BFV\"\npub global DS_PK_BFV: [u8; 64] = [\n    0x50, 0x4b, 0x5f, 0x42, 0x46, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"PK_TRBFV\"\npub global DS_PK_TRBFV: [u8; 64] = [\n    0x50, 0x4b, 0x5f, 0x54, 0x52, 0x42, 0x46, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"SECRET\"\npub global DS_SECRET: [u8; 64] = [\n    0x53, 0x45, 0x43, 0x52, 0x45, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"SPM\"\npub global DS_SPM: [u8; 64] = [\n    0x53, 0x50, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"AGG_SHARES\"\npub global DS_AGG_SHARES: [u8; 64] = [\n    0x41, 0x47, 0x47, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"PK_AGG\"\npub global DS_PK_AGG: [u8; 64] = [\n    0x50, 0x4b, 0x5f, 0x41, 0x47, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"AGGREGATION\"\npub global DS_AGGREGATION: [u8; 64] = [\n    0x41, 0x47, 0x47, 0x72, 0x65, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_PK_TRBFV\"\npub global DS_CLG_PK_TRBFV: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x50, 0x4b, 0x5f, 0x54, 0x52, 0x42, 0x46, 0x56, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_ENC_BFV\"\npub global DS_CLG_ENC_BFV: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x45, 0x4e, 0x43, 0x5f, 0x42, 0x46, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_GRECO\"\npub global DS_CLG_GRECO: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x47, 0x72, 0x65, 0x63, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_DEC_SHARE\"\npub global DS_CLG_DEC_SHARE: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x44, 0x65, 0x63, 0x53, 0x68, 0x61, 0x72, 0x65, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n\n/// WRAPPERS\n\npub fn compute_commitments(\n    payload: Vec<Field>,\n    domain_separator: [u8; 64],\n    io_pattern: [u32; 2],\n) -> Vec<Field> {\n    compute_safe(domain_separator, payload, io_pattern)\n}\n\npub fn single_polynomial_payload<let N: u32, let BIT_POLY: u32>(\n    payload: Vec<Field>,\n    input: Polynomial<N>,\n) -> Vec<Field> {\n    flatten::<_, _, BIT_POLY>(payload, [input])\n}\n\npub fn multiple_polynomial_payload<let N: u32, let L: u32, let BIT_POLY: u32>(\n    payload: Vec<Field>,\n    inputs: [Polynomial<N>; L],\n) -> Vec<Field> {\n    flatten::<_, _, BIT_POLY>(payload, inputs)\n}\n\n/// COMMITMENTS\n\npub fn compute_pk_bfv_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);\n    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);\n\n    compute_commitments(payload, DS_PK_BFV, [0x80000000 | payload.len(), 1]).get(0)\n}\n\npub fn compute_pk_trbfv_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);\n    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);\n\n    compute_commitments(payload, DS_PK_TRBFV, [0x80000000 | payload.len(), 1]).get(0)\n}\n\npub fn compute_secret_sk_commitment<let N: u32, let BIT_SK: u32>(sk: Polynomial<N>) -> Field {\n    let mut payload = single_polynomial_payload::<N, BIT_SK>(Vec::new(), sk);\n    compute_commitments(payload, DS_SECRET, [0x80000000 | payload.len(), 1]).get(0)\n}\n\npub fn compute_secret_e_sm_commitment<let N: u32, let L: u32, let BIT_E_SM: u32>(\n    e_sm: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_E_SM>(Vec::new(), e_sm);\n    compute_commitments(payload, DS_SECRET, [0x80000000 | payload.len(), 1]).get(0)\n}\n\npub fn compute_spm_commitment_from_message<let N: u32, let BIT_MSG: u32>(\n    message: Polynomial<N>,\n) -> Field {\n    let mut payload = single_polynomial_payload::<N, BIT_MSG>(Vec::new(), message);\n    compute_commitments(payload, DS_SPM, [0x80000000 | payload.len(), 1]).get(0)\n}\n\npub fn compute_spm_commitment_from_shares<let N: u32, let L: u32, let N_PARTIES: u32>(\n    y: [[[Field; N_PARTIES + 1]; L]; N],\n    party_idx: u32,\n    mod_idx: u32,\n) -> Field {\n    let mut payload = Vec::new();\n\n    for coeff_idx in 0..N {\n        payload.push(y[coeff_idx][mod_idx][party_idx + 1]);\n    }\n\n    // Include party_idx and mod_idx in the hash\n    payload.push(party_idx as Field);\n    payload.push(mod_idx as Field);\n\n    compute_commitments(payload, DS_SPM, [0x80000000 | payload.len(), 1]).get(0)\n}\n\npub fn compute_aggregated_shares_commitment<let N: u32, let L: u32, let BIT_MSG: u32>(\n    agg_shares: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_MSG>(Vec::new(), agg_shares);\n    compute_commitments(payload, DS_AGG_SHARES, [0x80000000 | payload.len(), 1]).get(0)\n}\n\npub fn compute_pk_agg_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);\n    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);\n\n    compute_commitments(payload, DS_PK_AGG, [0x80000000 | payload.len(), 1]).get(0)\n}\n\npub fn compute_aggregation_commitment(payload: Vec<Field>) -> Field {\n    compute_safe(DS_AGGREGATION, payload, [0x80000000 | payload.len(), 1]).get(0)\n}\n\n/// COMMITMENTS FOR CHALLENGES\n\npub fn compute_pk_trbfv_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {\n    compute_commitments(\n        payload,\n        DS_CLG_PK_TRBFV,\n        [0x80000000 | payload.len(), 2 * L],\n    )\n}\n\npub fn compute_bfv_enc_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {\n    compute_commitments(payload, DS_CLG_ENC_BFV, [0x80000000 | payload.len(), 2 * L])\n}\n\npub fn compute_greco_challenge_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0is: [Polynomial<N>; L],\n    pk1is: [Polynomial<N>; L],\n    gammas_payload: Vec<Field>,\n    pk_commitment: Field,\n) -> Vec<Field> {\n    assert(compute_pk_agg_commitment::<N, L, BIT_PK>(pk0is, pk1is) == pk_commitment);\n\n    compute_commitments(\n        gammas_payload,\n        DS_CLG_GRECO,\n        [0x80000000 | gammas_payload.len(), 2 * L],\n    )\n}\n\npub fn compute_dec_share_challenge<let L: u32>(payload: Vec<Field>) -> Field {\n    compute_commitments(payload, DS_CLG_DEC_SHARE, [0x80000000 | payload.len(), 1]).get(0)\n}\n",
      "path": "/Users/ctrlc03/Documents/zk/enclave/circuits/lib/src/math/commitments.nr"
    },
    "70": {
      "source": "// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\n//! Helper functions for circuit construction and cryptographic operations.\nuse crate::math::polynomial::Polynomial;\nuse crate::math::safe::SafeSponge;\n\n/// Compute hex-aligned packing parameters for a given `BIT`.\n///\n/// # Purpose\n/// Returns `(nibble_bits, group)` for use by pack/flatten so layout stays consistent.\n/// - `nibble_bits`: ceil (`BIT`) to the next multiple of 4 (nibble alignment).\n///   - Examples: `BIT = 7 -> 8`, `BIT = 8 -> 8`, `BIT = 9 -> 12`, `BIT = 10 -> 12`, `BIT = 11 -> 12`,\n///     `BIT=16 -> 16`, `BIT = 17 -> 20`.\n/// - `group`: max number of encoded limbs that fit in one BN254 field element,\n///            when each limb uses an extra 4 bits (see below).\n///\n/// # Rationale\n/// - We align to nibbles so powers of two are hex-friendly and deterministic.\n/// - We reserve one extra nibble (4 bits) per stored value to lift signed\n///   coefficients into the non-negative range (e.g., store `v + 2^nibble_bits`),\n///   which implies a radix of `2^(nibble_bits + 4)`.\n///\n/// # Safety\n/// - Asserts `nibble_bits + 4 <= 254` to avoid mod-p wrap on BN254.\n/// - Ensures at least one limb fits: `group >= 1`.\nfn packing_layout<let BIT: u32>() -> (u32, u32) {\n    // Ceil BIT up to the next multiple of 4 (nibble alignment).\n    let nibble_bits = ((BIT + 3) / 4) * 4;\n\n    // Each stored limb uses an extra nibble because negative coefficients\n    // will be shifted to positive, so radix = 2^(nibble_bits+4).\n    assert(nibble_bits + 4 <= 254);\n\n    // Maximum limbs that fit in one BN254 element without wrap.\n    let group = 254 / (nibble_bits + 4);\n    assert(group >= 1);\n    (nibble_bits, group)\n}\n\n/// Flatten `L` polynomials into a single linear stream of packed `Field` carriers.\n///\n/// ## What this does\n/// - For each CRT limb `j` in `0..L`, it packs the coefficients of `poly[j]`\n///   with `pack::<A, BIT>` and appends all resulting carriers to `inputs`.\n/// - The packing layout (nibble-aligned width and `group` size) is taken from\n///   `packing_layout::<BIT>()` and must match what `pack` uses.\n///\n/// ## Determinism & order\n/// - Preserves a stable order: iterate `j = 0..L`, then for each `j` append\n///   carriers in ascending chunk index `i = 0..num_chunks`.\n/// - This ensures transcripts remain deterministic across runs.\n///\n/// ## Generics\n/// - `A`: polynomial degree (number of coefficients per polynomial).\n/// - `L`: number of CRT bases (polynomials).\n/// - `BIT`: per-coefficient bit bound used by the packing layout (compile-time).\n///\n/// ## Returns\n/// - The same `inputs` vector, extended with all carriers in deterministic order.\npub fn flatten<let A: u32, let L: u32, let BIT: u32>(\n    mut inputs: Vec<Field>,\n    poly: [Polynomial<A>; L],\n) -> Vec<Field> {\n    for j in 0..L {\n        // Pack its A coefficients into `num_chunks` carriers using the same BIT layout.\n        let packed = pack::<A, BIT>(poly[j].coefficients);\n\n        // Append carriers in-order to `inputs` to keep a stable transcript layout.\n        for i in 0..packed.len() {\n            inputs.push(packed.get(i));\n        }\n    }\n\n    // Return the extended input stream.\n    inputs\n}\n\n/// Pack `A` values into a `Vec<Field>` of carriers using the shared hex-aligned layout.\n///\n/// ## What this does\n/// - Computes `(nibble_bits, group)` via `packing_layout::<BIT>()`.\n/// - Encodes each value as a limb `digit = v + 2^nibble_bits` and concatenates\n///   limbs in base `radix = 2^(nibble_bits + 4)` (one extra nibble of headroom).\n/// - Packs up to `group` limbs per carrier (fits within BN254 254-bit capacity).\n/// - Pads the last, partial carrier with `digit = 2^nibble_bits` to keep a stable layout.\n///\n/// ## Determinism & order\n/// - Processes values in increasing index order and emits carriers in chunk order\n///   (`chunk = 0..num_chunks`). Padding is deterministic.\n///\n/// ## Generics\n/// - `A`: number of input values.\n/// - `BIT`: per-value bit bound; rounded up to `nibble_bits` by `packing_layout`.\n///\n/// ## Preconditions / Notes\n/// - Call with the raw coefficients whose magnitudes already satisfy the BIT bound\n///   (as enforced by the upstream range checks); `pack` performs the signed -> unsigned\n///   shift internally via `v + base`.\n/// - `group >= 1` is enforced by `packing_layout::<BIT>()`.\n/// - Padding with `digit = 2^nibble_bits` encodes `zero limb` consistently.\n///\n/// ## Returns\n/// - A `Vec<Field>` where each element is a concatenation of up to `group` limbs,\n///   suitable for hashing or transcript I/O.\npub fn pack<let A: u32, let BIT: u32>(values: [Field; A]) -> Vec<Field> {\n    // Layout parameters: nibble-aligned width and limbs-per-carrier group size.\n    let (nibble_bits, group) = packing_layout::<BIT>();\n\n    let base = 2.pow_32(nibble_bits as Field); // 2^nibble_bits\n    let radix = 2.pow_32((nibble_bits + 4) as Field); // 2^(nibble_bits + 4)\n\n    // Number of chunks to emit: ceil(A / group).\n    let num_chunks = (A + group - 1) / group;\n    let mut out = Vec::new();\n\n    // Process in fixed-size chunks of `group` limbs.\n    for chunk in 0..num_chunks {\n        // How many real values go into this chunk.\n        let remain = A - (chunk * group);\n        let take = if remain < group { remain } else { group };\n\n        // Build field element accumulator (big-endian concatenation in `radix`).\n        let mut acc = 0;\n        for i in 0..take {\n            let v = values[chunk * group + i];\n            acc = acc * radix + (v + base);\n        }\n\n        // Pad remaining limb slots with the canonical zero-limb `digit = base`.\n        for _ in 0..(group - take) {\n            acc = acc * radix + base;\n        }\n\n        out.push(acc);\n    }\n    out\n}\n\n/// Computes a cryptographic hash using the SAFE (Sponge API for Field Elements) protocol.\n///\n/// This is a convenience wrapper around the SAFE sponge API that handles the full\n/// lifecycle: initialization, absorption, squeezing, and finalization. It's designed\n/// for use in Fiat-Shamir challenge generation and commitment schemes within zero-knowledge circuits.\n///\n/// # Arguments\n/// * `domain_separator` - A 64-byte domain separator used to differentiate between\n///                        different protocol instances and prevent cross-protocol attacks.\n/// * `inputs` - Vector of field elements to be absorbed into the sponge.\n/// * `io_pattern` - A 2-element array encoding the I/O pattern:\n///                 - `io_pattern[0]`: Encoded ABSORB operation (MSB=1, lower 31 bits = length)\n///                 - `io_pattern[1]`: Encoded SQUEEZE operation (MSB=0, lower 31 bits = length)\n///\n/// # Returns\n/// A vector of field elements squeezed from the sponge, with length determined by\n/// the SQUEEZE operation in the IO pattern.\npub fn compute_safe(\n    domain_separator: [u8; 64],\n    inputs: Vec<Field>,\n    io_pattern: [u32; 2],\n) -> Vec<Field> {\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(inputs);\n    let digests = sponge.squeeze();\n    sponge.finish();\n\n    digests\n}\n\n#[test]\nfn test_flatten() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([1, 2, 3]); // degree 2\n    let poly2 = Polynomial::new([4, -16, 6]); // degree 2\n    let poly3 = Polynomial::new([-7, 8, 9]); // degree 2\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 4>(inputs, polynomials);\n\n    // Verify the flattened coefficients are in the correct positions\n    // Every value shifted 1 nibble incase of negative integers\n    assert(result.get(0) == 0x11121310101010101010101010101010101010101010101010101010101010);\n    assert(result.get(1) == 0x14001610101010101010101010101010101010101010101010101010101010); // -16 became 00 at  0x 14 00 16,\n    assert(result.get(2) == 0x09181910101010101010101010101010101010101010101010101010101010); // -7 became 09 at 0x 09 18 19(16 - 7 = 9)\n}\n\n#[test]\nfn test_flatten_big() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([\n        1791218451968394,\n        21888242871839275222246405745257275088548364400416034343698198265248580087864,\n        21888242871839275222246405745257275088548364400416034343698200542108324633466,\n        5430119342984413,\n        704811298945172,\n        8901715723925099,\n        21888242871839275222246405745257275088548364400416034343698203098124042812559,\n        21888242871839275222246405745257275088548364400416034343698200215091693880034,\n    ]);\n    let poly2 = Polynomial::new([\n        21888242871839275222246405745257275088548364400416034343698200314078269634250,\n        21888242871839275222246405745257275088548364400416034343698200967285641915872,\n        2909990636858607,\n        7896103832076587,\n        2078397209533893,\n        21888242871839275222246405745257275088548364400416034343698199792421452734531,\n        614400389245817,\n        8290314119277588,\n    ]);\n    let poly3 = Polynomial::new([\n        21888242871839275222246405745257275088548364400416034343698201373175279892906,\n        21888242871839275222246405745257275088548364400416034343698201087241869723721,\n        6768789983786188,\n        635797784303388,\n        7610153424227556,\n        4633893206538324,\n        2016269760615332,\n        21888242871839275222246405745257275088548364400416034343698201007080554428142,\n    ]);\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 54>(inputs, polynomials);\n\n    // Verify the flattened coefficients are in the correct positions\n    // Every value shifted 1 nibble incase of negative integers\n\n    // For the first index of result operation goes like this,\n\n    // First four index of poly1\n    // 1791218451968394,\n    // 21888242871839275222246405745257275088548364400416034343698198265248580087864,\n    // 21888242871839275222246405745257275088548364400416034343698200542108324633466,\n    // 5430119342984413,\n\n    // base + 1791218451968394 = 0x1065d1a8b8b718a\n    // base - 5921327228407753 = 0xeaf69591f3b037 (negative coefficient shifted)\n    // base - 3644467483862151 = 0xf30d604a3a9b79 (negative coefficient shifted)\n    // base + 5430119342984413 = 0x1134aaa2e86ccdd\n    assert(result.get(0) == 0x1065d1a8b8b718a0eaf69591f3b0370f30d604a3a9b791134aaa2e86ccdd);\n    assert(result.get(1) == 0x1028105ab1b789411fa010339db66b0fc220f1326bc8e0f1e3f4cc1e02e1);\n    assert(result.get(2) == 0x0f23dfbe7cd76c90f4901299312ddf10a569efe35acef11c0d76f005412b);\n    assert(result.get(3) == 0x107624a8f605dc50f0638a368960421022ecb3cf36b7911d73ff2c27ec14);\n    assert(result.get(4) == 0x0f6013a24e1b9a90f4fd2c158a08481180c2dba8af4cc10242413515171c);\n    assert(result.get(5) == 0x11b0964eb898ce411076805680b85410729c962da53a40f4b44412d0f6ed);\n}\n\n#[test]\nfn test_flatten_small() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([712345, 104857, 999999, 500001, 123, 654321, 77]);\n    let poly2 = Polynomial::new([1, 524287, 888888, 23456, 34567, 765432, 0]);\n    let poly3 = Polynomial::new([444444, 333333, 222222, 111111, 987654, 246810, 13579]);\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 20>(inputs, polynomials);\n\n    assert(result.get(0) == 0x1ade991199991f423f17a12110007b19fbf110004d100000100000100000);\n    assert(result.get(1) == 0x10000117ffff1d9038105ba01087071badf8100000100000100000100000);\n    assert(result.get(2) == 0x16c81c15161513640e11b2071f120613c41a10350b100000100000100000);\n}\n\n#[test]\nfn test_safe_hashing_with_safe_helper() {\n    // Verifies basic hash functionality with a simple ABSORB(3) + SQUEEZE(1) pattern.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice(&[1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let digests1 = compute_safe(domain_separator, elements, io_pattern);\n\n    assert(digests1.len() == 1);\n    assert(digests1.get(0) != 0);\n\n    // Test determinism\n    let digests2 = compute_safe(domain_separator, elements, io_pattern);\n\n    assert(digests2.len() == 1);\n    assert(digests2.get(0) != 0);\n    assert(digests2.get(0) == digests1.get(0));\n}\n\n#[test]\nfn test_pack() {\n    // Test pack function directly with small values\n    let values = [1, 2, 3, 4];\n    let packed = pack::<4, 4>(values);\n\n    // With BIT=4, nibble_bits=4, group should be floor(254/(4+4)) = 31\n    // So all 4 values should fit in one carrier\n    assert(packed.len() >= 1);\n\n    // Test with negative values\n    let values_neg = [-1, 2, -3, 4];\n    let packed_neg = pack::<4, 4>(values_neg);\n    assert(packed_neg.len() >= 1);\n}\n\n#[test]\nfn test_pack_single_value() {\n    // Test packing a single value\n    let values = [42];\n    let packed = pack::<1, 8>(values);\n    assert(packed.len() == 1);\n    assert(packed.get(0) != 0);\n}\n\n#[test]\nfn test_pack_determinism() {\n    // Test that packing is deterministic\n    let values = [10, 20, 30];\n    let packed1 = pack::<3, 8>(values);\n    let packed2 = pack::<3, 8>(values);\n\n    assert(packed1.len() == packed2.len());\n    for i in 0..packed1.len() {\n        assert(packed1.get(i) == packed2.get(i));\n    }\n}\n",
      "path": "/Users/ctrlc03/Documents/zk/enclave/circuits/lib/src/math/helpers.nr"
    },
    "76": {
      "source": "// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse keccak256::keccak256;\nuse poseidon::poseidon2_permutation;\n\n/// SAFE (Sponge API for Field Elements)\n///\n/// This module provides a complete implementation of the SAFE API in Noir as defined in:\n/// \"SAFE (Sponge API for Field Elements) - A Toolbox for ZK Hash Applications\"\n/// see https://hackmd.io/bHgsH6mMStCVibM_wYvb2w#22-Sponge-state for more details.\n///\n/// SAFE provides a unified interface for cryptographic sponge functions that can be\n/// instantiated with various permutations to create hash functions, MACs, authenticated\n/// encryption schemes, and other cryptographic primitives for ZK proof systems.\n///\n/// This implementation follows the SAFE specification exactly, providing:\n/// - Complete API: START, ABSORB, SQUEEZE, FINISH operations.\n/// - Full security: Domain separation, tag computation, IO pattern validation.\n/// - Poseidon2 integration: Field-friendly permutation for ZK systems.\n/// - Specification compliance: All operations follow SAFE spec 2.4 exactly.\n/// - Natural API design: Variable-length inputs, automatic length detection from IO patterns.\n///\n/// # API Design\n///\n/// The API is designed for natural usage while maintaining type safety:\n/// - `absorb(input: [Field])`: Accepts variable-length arrays, no padding required.\n/// - `squeeze()`: Returns a vector with field element(s).\n/// - IO patterns automatically determine operation lengths for validation.\n\n/// Rate parameter for the sponge construction (number of field elements that can be absorbed per permutation call).\nglobal RATE: u32 = 3;\n\n/// Capacity parameter for the sponge construction (security parameter, typically 1-2 field elements).\nglobal CAPACITY: u32 = 1;\n\n/// Total state size (rate + capacity) in field elements.\nglobal STATE_SIZE: u32 = RATE + CAPACITY;\n\n/// IO Pattern encoding constants (from SAFE spec 2.3).\n///\n/// These constants are used for encoding operation types in the 32-bit word format:\n/// - MSB set to 1 for ABSORB operations\n/// - MSB set to 0 for SQUEEZE operations\n\n/// Flag for ABSORB operations (MSB = 1)\nglobal ABSORB_FLAG: u32 = 0x80000000;\n\n/// Flag for SQUEEZE operations (MSB = 0)\nglobal SQUEEZE_FLAG: u32 = 0x00000000;\n\n/// SAFE Sponge State (following spec 2.2)\n///\n/// The sponge state consists of the permutation state, tag, position counters,\n/// and IO pattern tracking as defined in the SAFE specification.\n///\n/// # Generic Parameters\n/// - `L`: The length of the IO pattern array\n///\n/// # Fields\n/// - `state`: Permutation state V in F^n (rate + capacity elements)\n/// - `tag`: Parameter tag T used for instance differentiation\n/// - `absorb_pos`: Current absorb position (<= n-c)\n/// - `squeeze_pos`: Current squeeze position (<= n-c)\n/// - `io_pattern`: Expected IO pattern for validation (encoded 32-bit words)\n/// - `io_count`: Current operation count for pattern tracking\npub struct SafeSponge<let L: u32> {\n    /// Permutation state V in F^n (rate + capacity elements).\n    state: [Field; STATE_SIZE],\n    /// Parameter tag T used for instance differentiation.\n    tag: Field,\n    /// Current absorb position (<= n-c).\n    absorb_pos: u32,\n    /// Current squeeze position (<= n-c).\n    squeeze_pos: u32,\n    /// Expected IO pattern for validation.\n    io_pattern: [u32; L],\n    /// Current operation count for pattern tracking (spec 2.4: io_count).\n    io_count: u32,\n}\n\nimpl<let L: u32> SafeSponge<L> {\n    /// Initializes a new SAFE sponge instance with the given IO pattern and domain separator (following spec 2.4).\n    ///\n    /// # Arguments\n    /// - `io_pattern`: Array of 32-bit encoded operations defining the expected sequence of ABSORB/SQUEEZE calls.\n    ///               Each word has MSB=1 for ABSORB operations, MSB=0 for SQUEEZE operations.\n    /// - `domain_separator`: 64-byte domain separator for cross-protocol security.\n    ///\n    /// # Returns\n    /// A new `SafeSponge` instance with initialized state\n    pub fn start(io_pattern: [u32; L], domain_separator: [u8; 64]) -> SafeSponge<L> {\n        // Compute tag from IO pattern and domain separator (spec 2.3).\n        let tag = compute_tag(io_pattern, domain_separator);\n\n        let mut state = [0; STATE_SIZE];\n        // Initialize capacity with tag (spec 2.4).\n        // Add T to the first 128 bits of the state.\n        state[0] = tag;\n\n        SafeSponge { state, tag, absorb_pos: 0, squeeze_pos: 0, io_pattern, io_count: 0 }\n    }\n\n    /// Absorbs field elements into the sponge state, interleaving permutation calls as needed (following spec 2.4).\n    ///\n    /// The number of elements to absorb is automatically validated against the IO pattern.\n    /// This method accepts variable-length arrays, making it natural to use without padding.\n    ///\n    /// # Arguments\n    /// - `input`: Array of field elements to absorb (variable length, must match IO pattern)\n    pub fn absorb(&mut self, input: Vec<Field>) {\n        let length = input.len() as u32;\n\n        // Validate against IO pattern.\n        assert(self.io_count < L);\n\n        // Parse expected operation from io_pattern (encoded word)\n        let expected_encoded_word = self.io_pattern[self.io_count];\n        let is_expected_absorb = (expected_encoded_word & ABSORB_FLAG) != 0;\n        let expected_length = expected_encoded_word & 0x7FFFFFFF;\n\n        // Validate operation type and length\n        assert(is_expected_absorb, \"Expected ABSORB operation\");\n        assert(expected_length == length, \"Length mismatch\");\n\n        // Process each element naturally (no unnecessary iterations).\n        for i in 0..length {\n            // If absorb_pos == (n-c) then permute and reset (spec 2.4).\n            if self.absorb_pos == RATE {\n                // n-c = RATE.\n                self.state = self.permute();\n                self.absorb_pos = 0;\n            }\n\n            // Add X[i] to state at absorb_pos (spec 2.4).\n            // Note: absorb_pos is the rate position, not capacity position.\n            self.state[self.absorb_pos + CAPACITY] =\n                self.state[self.absorb_pos + CAPACITY] + input.get(i);\n            self.absorb_pos += 1;\n        }\n\n        // Verify that the encoded word matches the expected pattern.\n        let encoded_word = ABSORB_FLAG | length;\n        assert(encoded_word == expected_encoded_word);\n\n        self.io_count += 1;\n\n        // Force permute at start of next SQUEEZE (spec 2.4).\n        self.squeeze_pos = RATE;\n    }\n\n    /// Extracts field elements from the sponge state, interleaving permutation calls as needed (following spec 2.4).\n    ///\n    /// The number of elements to squeeze is automatically determined from the IO pattern.\n    pub fn squeeze(&mut self) -> Vec<Field> {\n        // Validate against IO pattern.\n        assert(self.io_count < L);\n\n        // Parse expected operation from io_pattern (encoded word)\n        let expected_encoded_word = self.io_pattern[self.io_count];\n        let is_expected_squeeze = (expected_encoded_word & ABSORB_FLAG) == 0;\n        let length = expected_encoded_word & 0x7FFFFFFF;\n\n        // Validate operation type\n        assert(is_expected_squeeze, \"Expected SQUEEZE operation\");\n\n        let mut output = Vec::new();\n\n        // SQUEEZE implementation following spec 2.4.\n        // If length==0, loop won't execute (spec 2.4).\n        for _ in 0..length {\n            // If squeeze_pos==(n-c) then permute and reset (spec 2.4).\n            if self.squeeze_pos == RATE {\n                // n-c = RATE.\n                self.state = self.permute();\n                self.squeeze_pos = 0;\n                self.absorb_pos = 0;\n            }\n            // Set Y[i] to state element at squeeze_pos (spec 2.4).\n            output.push(self.state[self.squeeze_pos + CAPACITY]);\n            self.squeeze_pos += 1;\n        }\n\n        // Verify that the encoded word matches the expected pattern.\n        let encoded_word = SQUEEZE_FLAG | length;\n        assert(encoded_word == expected_encoded_word);\n\n        self.io_count += 1;\n        output\n    }\n\n    /// Finalizes the sponge instance, verifying that all expected operations have been performed and clearing the internal state for security (following spec 2.4).\n    ///\n    /// This function is used to ensure that the sponge instance has been used correctly and to prevent information leakage.\n    pub fn finish(&mut self) {\n        // Check that io_count equals the length of the IO pattern expected (spec 2.4).\n        assert(self.io_count == L, \"IO pattern not completed\");\n\n        // Erase the state and its variables (spec 2.4).\n        self.state = [0; STATE_SIZE];\n        self.absorb_pos = 0;\n        self.squeeze_pos = 0;\n        self.io_count = 0;\n    }\n\n    /// Permute the state using Poseidon2 (following spec 2.4).\n    ///\n    /// Applies the Poseidon2 permutation to the current state.\n    /// This is the core cryptographic primitive of the sponge construction.\n    ///\n    /// # Returns\n    /// New state after permutation\n    fn permute(self) -> [Field; STATE_SIZE] {\n        poseidon2_permutation(self.state, STATE_SIZE)\n    }\n}\n\n/// Computes a unique tag for a sponge instance based on its IO pattern and domain separator.\n/// The tag is used to ensure that distinct instances behave like distinct functions.\n///\n/// # Arguments\n/// - `io_pattern`: Array of 32-bit encoded operations defining the sponge's usage pattern.\n///               Each word has MSB=1 for ABSORB operations, MSB=0 for SQUEEZE operations.\n/// - `domain_separator`: 64-byte domain separator for cross-protocol security.\n///\n/// # Returns\n/// A field element representing the 128-bit tag.\npub fn compute_tag<let L: u32>(io_pattern: [u32; L], domain_separator: [u8; 64]) -> Field {\n    // Step 1: Parse and aggregate consecutive operations of the same type\n    let mut encoded_words = [0; L]; // Support up to L operations.\n    let mut word_count = 0;\n    let mut current_absorb_sum = 0;\n    let mut current_squeeze_sum = 0;\n    let mut last_was_absorb = false;\n\n    for i in 0..L {\n        if io_pattern[i] > 0 {\n            // Parse operation type from MSB and length from lower 31 bits\n            let is_absorb = (io_pattern[i] & ABSORB_FLAG) != 0;\n            let length = io_pattern[i] & 0x7FFFFFFF; // Clear MSB to get length\n\n            if is_absorb {\n                if last_was_absorb {\n                    // Aggregate consecutive ABSORB operations\n                    current_absorb_sum += length;\n                } else {\n                    // Start new ABSORB sequence\n                    if current_squeeze_sum > 0 {\n                        // Flush previous SQUEEZE sequence\n                        encoded_words[word_count] = SQUEEZE_FLAG | current_squeeze_sum;\n                        word_count += 1;\n                        current_squeeze_sum = 0;\n                    }\n                    current_absorb_sum = length;\n                }\n                last_was_absorb = true;\n            } else {\n                if !last_was_absorb {\n                    // Aggregate consecutive SQUEEZE operations\n                    current_squeeze_sum += length;\n                } else {\n                    // Start new SQUEEZE sequence\n                    if current_absorb_sum > 0 {\n                        // Flush previous ABSORB sequence\n                        encoded_words[word_count] = ABSORB_FLAG | current_absorb_sum;\n                        word_count += 1;\n                        current_absorb_sum = 0;\n                    }\n                    current_squeeze_sum = length;\n                }\n                last_was_absorb = false;\n            }\n        }\n    }\n\n    // Flush remaining operations\n    if current_absorb_sum > 0 {\n        encoded_words[word_count] = ABSORB_FLAG | current_absorb_sum;\n        word_count += 1;\n    }\n    if current_squeeze_sum > 0 {\n        encoded_words[word_count] = SQUEEZE_FLAG | current_squeeze_sum;\n        word_count += 1;\n    }\n\n    // Step 2: Serialize to byte string and append domain separator (following SAFE spec 2.3).\n    // Buffer is 256 bytes: max 192 bytes for IO pattern (48 words) + 64 bytes for domain separator.\n    // Note: We must use a fixed-size array because Noir's keccak256 requires [u8; N], not Vec<u8>.\n    let max_io_pattern_bytes: u32 = 192; // 256 - 64 (domain separator)\n    let io_pattern_bytes = word_count * 4;\n    assert(\n        io_pattern_bytes <= max_io_pattern_bytes,\n        \"IO pattern too large: max 48 aggregated words supported\",\n    );\n\n    let mut input_bytes = [0u8; 256];\n    let mut byte_count: u32 = 0;\n\n    // Serialize encoded words to bytes (big-endian as per SAFE spec).\n    // Note: Noir requires compile-time loop bounds, so we iterate over L (the array size)\n    // instead of word_count (runtime value). The condition `i < word_count` ensures we only\n    // process valid encoded words. This is safe because word_count <= L always holds\n    // (we can have at most L encoded words from L input operations).\n    for i in 0..L {\n        if i < word_count {\n            let word = encoded_words[i];\n            input_bytes[byte_count] = (word >> 24) as u8;\n            input_bytes[byte_count + 1] = (word >> 16) as u8;\n            input_bytes[byte_count + 2] = (word >> 8) as u8;\n            input_bytes[byte_count + 3] = word as u8;\n            byte_count += 4;\n        }\n    }\n\n    // Append full 64-byte domain separator.\n    for i in 0..64 {\n        input_bytes[byte_count] = domain_separator[i];\n        byte_count += 1;\n    }\n\n    // Step 3: Hash with Keccak-256 and truncate to 128 bits.\n    // Note: The SAFE spec uses SHA3-256, but we use Keccak-256 for Noir compatibility.\n    // Keccak-256 differs from SHA3-256 in padding, but both provide equivalent security.\n    let hash_bytes = keccak256(input_bytes, byte_count);\n\n    // Convert first 128 bits (16 bytes) to field element.\n    let mut tag_value: Field = 0;\n    for i in 0..16 {\n        tag_value = tag_value * 256 + (hash_bytes[i] as Field);\n    }\n\n    tag_value\n}\n\n#[test]\nfn test_safe_hashing() {\n    // Verifies basic hash functionality with a simple ABSORB(3) + SQUEEZE(1) pattern.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice(&[1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(elements);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(elements);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_merkle_node() {\n    // Verifies SAFE can be used for Merkle tree node hashing with pattern ABSORB(1) + ABSORB(1) + SQUEEZE(1).\n    // Tests the ability to absorb multiple inputs before squeezing output.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let left = Vec::from_slice([123]);\n    let right = Vec::from_slice([456]);\n\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(left);\n    sponge.absorb(right);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(left);\n    sponge2.absorb(right);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_commitment_scheme() {\n    // Verifies SAFE can be used for commitment schemes with pattern ABSORB(3) + SQUEEZE(1).\n    // Tests the ability to create deterministic commitments from multiple field elements.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let values = Vec::from_slice([10, 20, 30]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(values);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(values);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_domain_separation() {\n    // Verifies that different domain separators produce different outputs for the same input.\n    // This is crucial for cross-protocol security and preventing collisions between different applications.\n    let elements = Vec::from_slice([1, 2, 3]);\n    let domain1 = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let domain2 = [\n        0x41, 0x42, 0x43, 0x45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n\n    let mut sponge1 = SafeSponge::start(io_pattern, domain1);\n    sponge1.absorb(elements);\n    let output1 = sponge1.squeeze();\n    sponge1.finish();\n\n    let mut sponge2 = SafeSponge::start(io_pattern, domain2);\n    sponge2.absorb(elements);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output1.len() == 1);\n    assert(output2.len() == 1);\n    assert(output1.get(0) != output2.get(0)); // Different domain separators should produce different outputs\n}\n\n#[test]\nfn test_multiple_squeeze() {\n    // Verifies that multiple field elements can be squeezed in a single operation.\n    // Tests pattern ABSORB(3) + SQUEEZE(2) to ensure proper state management.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice([1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(2)\n    let io_pattern = [0x80000003, 0x00000002];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(elements);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 2);\n    assert(output.get(0) != 0);\n    assert(output.get(1) != 0);\n    assert(output.get(0) != output.get(1)); // Different squeeze outputs should be different\n}\n\n#[test]\nfn test_zero_length_operations() {\n    // Verifies that zero-length ABSORB and SQUEEZE operations are handled correctly.\n    // Tests pattern ABSORB(0) + SQUEEZE(1) to ensure proper state transitions.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Pattern: ABSORB(0), SQUEEZE(1)\n    let io_pattern = [0x80000000, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(Vec::new());\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n}\n\n#[test]\nfn test_tag_computation() {\n    // Verifies the tag computation algorithm using the example from the SAFE specification.\n    // Pattern: ABSORB(3), ABSORB(3), SQUEEZE(3)\n    // Should aggregate to: ABSORB(6), SQUEEZE(3)\n    // Encoded as: [0x80000006, 0x00000003]\n    // Tests determinism and pattern differentiation.\n\n    let io_pattern = [0x80000003, 0x80000003, 0x00000003];\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test determinism\n    let tag2 = compute_tag(io_pattern, domain_separator);\n    assert(tag == tag2);\n\n    // Test that different patterns produce different tags\n    let io_pattern2 = [0x80000003, 0x00000003]; // ABSORB(3), SQUEEZE(3) - different pattern\n    let tag3 = compute_tag(io_pattern2, domain_separator);\n    assert(tag != tag3);\n}\n\n#[test]\nfn test_tag_computation_debug() {\n    println(\"=== SAFE Tag Computation Debug Test ===\");\n\n    // Test your specific pattern [2, 2, 2] (ABSORB(2), SQUEEZE(2), ABSORB(2))\n    let io_pattern = [0x80000002, 0x00000002, 0x80000002];\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    println(f\"Testing pattern: {io_pattern}\");\n    println(\n        f\"Expected to aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(2)\",\n    );\n    println(\n        f\"Expected encoded words: [0x80000002, 0x00000002, 0x80000002]\",\n    );\n    println(\"\");\n\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    println(f\"=== Expected Rust Output ===\");\n    println(\"Pattern [2, 2, 2] (ABSORB(2), SQUEEZE(2), ABSORB(2))\");\n    println(\"Domain separator: 0x41424344...\");\n    println(\"Tag: 0xce3bb9ee4b2d41c42e9cdda38afe8b6a\");\n    println(\"\");\n\n    println(f\"=== Noir Output ===\");\n    println(f\"Tag: {tag}\");\n    println(\"\");\n\n    println(\"Compare the tag values above with Rust script!\");\n}\n\n#[test]\nfn test_consecutive_absorb_aggregation() {\n    // Test that consecutive ABSORB operations are properly aggregated\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1) should aggregate to ABSORB(2), SQUEEZE(1)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), ABSORB(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001];\n\n    // This should aggregate to: ABSORB(2), SQUEEZE(1) = [0x80000002, 0x00000001]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag ABSORB(2), SQUEEZE(1)\n    let aggregated_pattern = [0x80000002, 0x00000001];\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(tag == aggregated_tag, \"Consecutive ABSORB operations should aggregate to the same tag\");\n\n    // Test that a different pattern produces a different tag\n    let different_pattern = [0x80000001, 0x00000001, 0x80000001]; // ABSORB(1), SQUEEZE(1), ABSORB(1)\n    let different_tag = compute_tag(different_pattern, domain_separator);\n\n    // This should be different because it doesn't have consecutive ABSORB operations\n    assert(tag != different_tag, \"Different patterns should produce different tags\");\n\n    println(\"=== Consecutive ABSORB Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x80000001, 0x00000001] (ABSORB(1), ABSORB(1), SQUEEZE(1))\",\n    );\n    println(\n        f\"Aggregated pattern: [0x80000002, 0x00000001] (ABSORB(2), SQUEEZE(1))\",\n    );\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Different pattern tag: {different_tag}\");\n}\n\n#[test]\nfn test_consecutive_squeeze_aggregation() {\n    // Test that consecutive SQUEEZE operations are properly aggregated\n    // Pattern: ABSORB(1), SQUEEZE(1), SQUEEZE(1) should aggregate to ABSORB(1), SQUEEZE(2)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), SQUEEZE(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x00000001, 0x00000001];\n\n    // This should aggregate to: ABSORB(1), SQUEEZE(2) = [0x80000001, 0x00000002]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag ABSORB(1), SQUEEZE(2)\n    let aggregated_pattern = [0x80000001, 0x00000002];\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(\n        tag == aggregated_tag,\n        \"Consecutive SQUEEZE operations should aggregate to the same tag\",\n    );\n\n    // Test that a different pattern produces a different tag\n    let different_pattern = [0x80000001, 0x00000001, 0x80000001]; // ABSORB(1), SQUEEZE(1), ABSORB(1)\n    let different_tag = compute_tag(different_pattern, domain_separator);\n\n    // This should be different because it doesn't have consecutive SQUEEZE operations\n    assert(tag != different_tag, \"Different patterns should produce different tags\");\n\n    println(\"=== Consecutive SQUEEZE Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x00000001, 0x00000001] (ABSORB(1), SQUEEZE(1), SQUEEZE(1))\",\n    );\n    println(\n        f\"Aggregated pattern: [0x80000001, 0x00000002] (ABSORB(1), SQUEEZE(2))\",\n    );\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Different pattern tag: {different_tag}\");\n}\n\n#[test]\nfn test_mixed_consecutive_aggregation() {\n    // Test that both consecutive ABSORB and SQUEEZE operations are properly aggregated\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1)\n    // Should aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(1)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001, 0x00000001, 0x80000001];\n\n    // This should aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(1) = [0x80000002, 0x00000002, 0x80000001]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag\n    let aggregated_pattern = [0x80000002, 0x00000002, 0x80000001]; // ABSORB(2), SQUEEZE(2), ABSORB(1)\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(tag == aggregated_tag, \"Mixed consecutive operations should aggregate to the same tag\");\n\n    println(\"=== Mixed Consecutive Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x80000001, 0x00000001, 0x00000001, 0x80000001]\",\n    );\n    println(\n        f\"  (ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1))\",\n    );\n    println(f\"Aggregated pattern: [0x80000002, 0x00000002, 0x80000001]\");\n    println(f\"  (ABSORB(2), SQUEEZE(2), ABSORB(1))\");\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n}\n\n#[test]\nfn test_large_io_pattern() {\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Create pattern with 48 alternating ABSORB(1) and SQUEEZE(1) operations\n    // This is the maximum supported (48 words * 4 bytes = 192 bytes, leaving 64 for domain separator)\n    let mut io_pattern = [0u32; 48];\n    for i in 0..48 {\n        if i % 2 == 0 {\n            io_pattern[i] = ABSORB_FLAG | 1; // ABSORB(1)\n        } else {\n            io_pattern[i] = SQUEEZE_FLAG | 1; // SQUEEZE(1)\n        }\n    }\n\n    let tag = compute_tag(io_pattern, domain_separator);\n    assert(tag != 0);\n}\n\n#[test]\nfn test_domain_separator_not_truncated() {\n    // This test verifies that the domain separator is always included in the tag computation,\n    // even for large IO patterns. If the domain separator were truncated, different domain\n    // separators would produce the same tag for large patterns.\n\n    let domain_separator_a = [\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41,\n    ]; // All 'A's\n\n    let domain_separator_b = [\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42,\n    ]; // All 'B's\n\n    // Create pattern with 48 alternating operations (max supported: 192 bytes of IO pattern)\n    let mut io_pattern = [0u32; 48];\n    for i in 0..48 {\n        if i % 2 == 0 {\n            io_pattern[i] = ABSORB_FLAG | 1;\n        } else {\n            io_pattern[i] = SQUEEZE_FLAG | 1;\n        }\n    }\n\n    let tag_a = compute_tag(io_pattern, domain_separator_a);\n    let tag_b = compute_tag(io_pattern, domain_separator_b);\n\n    // Tags MUST be different because domain separators are different.\n    // If they were the same, it would mean the domain separator was truncated/ignored.\n    assert(tag_a != tag_b, \"Domain separator must affect tag even for large IO patterns\");\n}\n",
      "path": "/Users/ctrlc03/Documents/zk/enclave/circuits/lib/src/math/safe.nr"
    }
  },
  "expression_width": { "Bounded": { "width": 4 } }
}
