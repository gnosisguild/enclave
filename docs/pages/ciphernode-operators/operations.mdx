---
title: 'Running a Ciphernode'
---

# Running a Ciphernode

This guide walks you through setting up and running a ciphernode, then explains the complete
computation flow from E3 request to plaintext decryption.

## Deployment paths

### DAppNode UI (IPFS package)

If you're already running DAppNode, install the packaged service instead of hand-building
containers:

1. Open **Packages → Install from IPFS hash** in the DAppNode UI, then paste
   `QmeX7jxDFcwbW7kAbs8Tgn5T4vonYxe4WmemUQsaca8xDQ`. This pulls
   `enclave-ciphernode.public.dappnode.eth@0.1.0`.
2. After the download finishes, click **Configure** on the package tile to launch the wizard.
3. Fill the wizard fields with the same addresses listed in the contract table on this page. The
   following values keep you in-sync with the public Sepolia network:

| Wizard field | Value / Notes |
| --- | --- |
| `Network` | `sepolia` (mainnet + localhost are also available) |
| `RPC URL` | WebSocket endpoint, e.g. `wss://ethereum-sepolia.publicnode.com` |
| `Node Address` | Operator address funded with ENCL and the stable token (ETK backing) |
| `Private Key` | Matches `Node Address`; stored as a secret in the container |
| `Bootstrap Peers` | `/dnsaddr/bootstrap.enclave.gg` (add more comma-separated peers as needed) |
| `Node Role` | `ciphernode` (switch to `aggregator` only if this host should aggregate plaintext) |
| `Enclave / CiphernodeRegistry / BondingRegistry` | Use the Sepolia addresses from this doc or your deployment artifact |
| `*_DEPLOY_BLOCK` | Block numbers for each contract (Sepolia example: Enclave `9615399`) |
| `ENCRYPTION_PASSWORD`, `NETWORK_PRIVATE_KEY` | Provide values to keep deterministic peer IDs across restarts; leave blank to auto-generate |

The wizard writes `config.yaml` from `config.template.yaml`, injects your answers as environment
variables, and persists `/data` so restarts do not erase the node database. After the wizard
completes:

- Click **Start** to boot the service. DAppNode automatically runs `enclave start -v` with your
  config.
- Use the **Logs** tab or `docker logs -f enclave-ciphernode.public.dappnode.eth` to watch the
  bootstrap process.
- To override CLI arguments, edit the package's `EXTRA_OPTS` field (for example, to add
  `--peer /dnsaddr/bootstrap.enclave.gg` while testing new peers).
- When you need to refresh secrets, stop the service, update the wizard values, and start it again.

### Standalone Docker container

Prefer to run a single node outside DAppNode? Build from the repo and mount your config + secrets:

```bash
# From the repository root
docker build -f crates/Dockerfile -t enclave-ciphernode:latest .

mkdir -p ops/enclave/config ops/enclave/data
cat <<'EOF' > ops/enclave/config/enclave.config.yaml
node:
  address: '0xYourOperator'
  quic_port: 9201
  peers:
    - '/dnsaddr/bootstrap.enclave.gg'
  autonetkey: true
  autopassword: true
chains:
  - name: sepolia
    rpc_url: 'wss://ethereum-sepolia.publicnode.com'
    contracts:
      enclave:
        address: '0x1E8BD97F15Cd94f250a4dd567d2fd2114303FAa6'
        deploy_block: 9615399
      ciphernode_registry:
        address: '0x11F647479bEd47cd0dd10276DDc04F2d4B20b1C7'
      bonding_registry:
        address: '0x56368bB545Ab2D6811b4dffa8Ad4B8AF560406E3'
      fee_token:
        address: '0xB58B762748c64f1a36B34012d1C52503617f4De0'
EOF

cat <<'EOF' > ops/enclave/secrets.json
{
  "password": "choose-a-long-passphrase",
  "private_key": "0x<operator-private-key>",
  "network_private_key": "0x<libp2p-ed25519-key>"
}
EOF

docker run -d --name enclave-cn1 --restart unless-stopped \
  -p 9201:9201/udp \
  -v $PWD/ops/enclave/config:/home/ciphernode/.config/enclave \
  -v $PWD/ops/enclave/data:/home/ciphernode/.local/share/enclave \
  -v $PWD/ops/enclave/secrets.json:/run/secrets/secrets.json:ro \
  -e AGGREGATOR=false \
  enclave-ciphernode:latest
```

- The entrypoint reads `/run/secrets/secrets.json`, sets your password + keys, and then runs
  `enclave start -v --config /home/ciphernode/.config/enclave/config.yaml`.
- Switch `AGGREGATOR=true` for plaintext aggregators.
- Mount any additional configs (TLS certs, Grafana agents, etc.) under the same directory and
  reference them from `enclave.config.yaml`.
- To run CLI commands inside the container, use
  `docker exec -it enclave-cn1 enclave ciphernode status --chain sepolia`.

## Manual setup: initialize your ciphernode

Start by running `enclave init` to create the initial configuration:

```bash
enclave init
```

This command will:

- Create `~/.config/enclave/config.yaml` with your node configuration
- Generate a network keypair in `~/.config/enclave/key`
- Set up the data directory at `~/.local/share/enclave/`

During initialization, you'll be prompted for:

- Your Ethereum address (the address that will participate in committees)
- A password to encrypt sensitive data
- RPC URL for the chain you want to connect to

## Configuration

After initialization, edit your `~/.config/enclave/config.yaml` to configure:

### 1. Contract Addresses

Update the contract addresses to match the network you're connecting to:

```yaml
chains:
  - name: sepolia
    rpc_url: 'wss://ethereum-sepolia.publicnode.com'
    contracts:
      enclave:
        address: '0x1E8B…FAa6'
        deploy_block: 9615399
      ciphernode_registry:
        address: '0x11F6…0b1C7'
      bonding_registry:
        address: '0x5636…406E3'
      fee_token:
        address: '0xB58B…4De0'
```

### 2. Bootstrap Peers

Add the bootstrap peer to join the network:

```yaml
node:
  address: '0xYourAddress'
  quic_port: 9201
  peers:
    - '/dnsaddr/bootstrap.enclave.gg'
  autonetkey: true
  autopassword: true
```

### 3. Set Your Wallet

Configure your private key to sign transactions:

```bash
enclave wallet set --private-key "0xYourPrivateKey"
```

**Warning:** Never share your private key. Keep it secure.

## Starting Your Node

Once configured, start your ciphernode:

```bash
enclave start
```

Your node will:

- Connect to the bootstrap peer(s)
- Subscribe to blockchain events
- Begin participating in sortition when E3s are requested

## CLI lifecycle after deployment

With the node running (via DAppNode, Docker, or bare metal) and your wallet already funded with the
required ENCL + stable tokens, move through the registry lifecycle using the CLI. Every command
accepts `--chain <name>` to select the chain entry from your config file and `--config <path>` if you
store configs outside the default.

| Goal | Command | Result |
| --- | --- | --- |
| Bond ENCL license collateral | `enclave ciphernode license bond --amount 100 --chain sepolia` | Approves + bonds ENCL into the BondingRegistry |
| Deposit ticket backing (stablecoin) | `enclave ciphernode tickets buy --amount 100 --chain sepolia` | Approves fee token, mints ETK tickets |
| Register the operator | `enclave ciphernode register --chain sepolia` | Calls `registerOperator()` and unlocks sortition eligibility |
| Force an activation check | `enclave ciphernode activate --chain sepolia` | Replays `registerOperator()` if status drifted |
| Inspect state | `enclave ciphernode status --chain sepolia` | Prints bonded amounts, tickets, exits, and requirements |
| Remove stake during an exit | `enclave ciphernode deactivate --tickets 10 --license 20 --chain sepolia` | Withdraws tickets / unbonds license into the exit queue |
| Deregister completely | `enclave ciphernode deregister --proof 0xabc,0xdef --chain sepolia` | Calls `deregisterOperator()`, burning tickets immediately |
| Claim finished exits | `enclave ciphernode license claim --max-ticket 100 --max-license 100 --chain sepolia` | Calls `claimExits()` to pull unlocked funds |

- For `tickets buy` and `license bond`, the CLI automatically checks ERC20 allowances and submits
  approvals before calling the BondingRegistry.
- Capture the IMT siblings emitted in `CiphernodeAdded` to reuse later with the `--proof` flag.
- When running inside Docker/DAppNode, wrap commands with `docker exec -it <container>` so they can
  access the mounted config and keystore.
- The lifecycle diagram in `ciphernode-operators/index.mdx` matches the sequence above: bond →
  register → add tickets → stay active → deactivate/deregister → claim exits.

## The Complete E3 Flow

Here's what happens when an E3 (Encrypted Execution Environment) computation is requested:

### Phase 1: E3 Request

1. Someone calls `request()` on the Enclave contract with computation parameters
2. A new E3 ID is created with a random seed
3. The contract emits an `E3Requested` event

### Phase 2: Committee Selection (Sortition)

1. **Ticket Submission**: Your ciphernode listens for `E3Requested` events
2. **Score Calculation**: Your node calculates a sortition score based on:
   - The E3 seed
   - Your tickets/stake
   - Your node's tickets
3. **Committee Finalization**: The top N nodes with the best scores are selected
4. If selected, you'll receive a `CommitteeFinalized` event with your party ID

### Phase 3: Keyshare Generation

When your node is selected for a committee:

1. **Generate Secret**: Your node generates a secret key share and public key share
2. **Publish Keyshare**: The public key share is broadcast via libp2p and published onchain
3. **Storage**: The secret is encrypted and stored in `~/.local/share/enclave/jobs/<e3_id>/`

### Phase 4: Public Key Aggregation

1. **Collect Keyshares**: An aggregator node collects all N public key shares from the committee
2. **Aggregate**: Once all shares are received, they're combined into a single public encryption key
3. **Publish**: The aggregated public key is published onchain via `publishPublicKey()`
4. The contract emits `PublicKeyAggregated` event
5. The E3 is now activated and ready to receive encrypted inputs

### Phase 5: Input Window

During this phase:

1. Data providers encrypt their inputs using the aggregated public key
2. They submit encrypted data to the contract via `publishInput()`
3. The E3 Program validates each input
4. Input hashes are added to a Merkle tree onchain

### Phase 6: Computation

1. **Deadline Passes**: Once the input window closes, computation can begin
2. **Compute Provider Execution**: A compute provider (or E3 program) retrieves all encrypted inputs
3. **FHE Computation**: The computation runs entirely on encrypted data
4. **Output Generation**: The result is produced as encrypted ciphertext with a ZK proof

### Phase 7: Ciphertext Publishing

1. The compute provider calls `publishCiphertextOutput()` with the encrypted result and proof
2. The contract verifies the proof
3. Contract emits `CiphertextOutputPublished` event
4. All committee members are notified to begin decryption

### Phase 8: Decryption Share Generation

When your ciphernode receives `CiphertextOutputPublished`:

1. **Load Secret**: Your node retrieves the encrypted secret key share from storage
2. **Decrypt Secret**: The secret is decrypted using your node's cipher
3. **Generate Share**: Your node creates a decryption share by partially decrypting the ciphertext
4. **Publish Share**: The decryption share is broadcast via libp2p and published onchain
5. Your node emits `DecryptionshareCreated` event

### Phase 9: Plaintext Aggregation

1. **Collect Shares**: An aggregator node collects decryption shares from committee members
2. **Threshold Met**: Once M-of-N threshold shares are received (e.g., 3 of 5)
3. **Aggregate**: The aggregator combines the shares to decrypt the final plaintext
4. **Publish Result**: The plaintext is published onchain via `publishPlaintextOutput()`
5. Contract emits `PlaintextOutputPublished` event
6. **Rewards**: Committee members receive their rewards for successful completion

### Phase 10: Completion

1. The plaintext output is now available onchain
2. Anyone can query `getE3()` to retrieve the result
3. Your node clears the secret from memory
4. The E3 round is complete

## Monitoring Your Node

### Check Node Status

View your node's logs depending on how you're running it:

```bash
# If running as a systemd service
journalctl -u enclave -f

# If running directly or in a container, check the process
ps aux | grep enclave

# Or check container logs if using Docker
docker logs -f <container_name>
```

### What to Watch For

Your node logs will show:

- `E3Requested` - New computation request detected
- `TicketGenerated` - Your sortition ticket was calculated
- `CiphernodeSelected` - You were selected for a committee
- `KeyshareCreated` - Your keyshare was generated
- `PublicKeyAggregated` - Committee public key is ready
- `CiphertextOutputPublished` - Time to generate decryption share
- `DecryptionshareCreated` - Your decryption share was published
- `PlaintextAggregated` - Final result is available

## Important Notes

### Stay Online

- Your node must be online and responsive during all phases of an E3 you're selected for
- Missing keyshare publication or decryption share submission may result in slashing

### Network Connectivity

- Ensure your `quic_port` (UDP) is accessible from the internet
- Maintain stable connections to bootstrap peers
- Consider running your own bootstrap node for redundancy

### RPC Reliability

- Use reliable RPC endpoints (consider running your own node)
- Have backup RPC URLs configured
- Monitor RPC connectivity and switch if needed

### Data Persistence

- The `~/.local/share/enclave/` directory contains critical job data
- Back up this directory regularly
- Do not delete data for active E3s

### Key Security

- Your network keypair is stored in `~/.config/enclave/key`
- Your wallet private key is encrypted in the config
- Never share these files or your private keys
