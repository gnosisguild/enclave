---
title: 'CRISP Introduction'
description: 'Coercion-Resistant Impartial Selection Protocol - A complete E3 program example'
---

# Introduction to CRISP

CRISP (Coercion-Resistant Impartial Selection Protocol) is a secure protocol for digital
decision-making, leveraging fully homomorphic encryption (FHE) and distributed threshold
cryptography (DTC) to enable verifiable secret ballots. Built with Enclave, CRISP safeguards
democratic systems and decision-making applications against coercion, manipulation, and other
vulnerabilities.

This project serves as a comprehensive example of an E3 Program, demonstrating secure and impartial
decision-making processes with a modern Hardhat-based architecture. It showcases a complete
full-stack implementation including frontend, backend, smart contracts, and zkVM components.

## Why CRISP?

Open ballots are known to produce suboptimal outcomes, exposing participants to bribery and
coercion. CRISP mitigates these risks through:

- **Secret ballots**: Votes remain encrypted throughout the process
- **Receipt-free voting**: No proof of vote can be generated for coercion
- **Verifiable results**: Zero-knowledge proofs ensure computation integrity
- **Distributed trust**: No single point of failure or control

## Project Structure

CRISP follows a modern Hardhat-based structure with clear separation of concerns:

```
CRISP/
├── client/                  # React frontend application (Vite + @crisp-e3/sdk)
├── server/                  # Rust coordination server & CLI
├── program/                 # RISC Zero guest + prover control plane
├── packages/
│   ├── crisp-contracts/     # Hardhat deployment + helpers
│   └── crisp-sdk/                 # CRISP-specific TypeScript helpers to generate a ZK proof
├── crates/                  # Rust libraries for the CLI + services
├── circuits/                # Noir circuits + verifiers (see [Noir Circuits](/noir-circuits))
├── scripts/                 # dev.sh, setup.sh, compile_circuits.sh, etc.
├── enclave.config.yaml      # Ciphernodes + aggregator config
└── docker-compose.yaml      # Optional multi-node deployment
```

---

### **Client Application** (`/client`)

The client is a React application built with TypeScript that provides a voting interface and reuses
the shared [CRISP SDK](/sdk):

- Wallet connection with MetaMask and other wallets
- Vote encryption using WebAssembly-based FHE encryption before submission
- Noir zero-knowledge proof generation for vote validation
- Real-time updates on voting status and results

---

### **Coordination Server** (`/server`)

The server is a Rust-based coordination service that manages the E3 lifecycle and drives the same
SDK from a privileged wallet:

- Listens to blockchain events and coordinates protocol progression
- Collects encrypted votes from the Smart Contract
- Triggers FHE computations after the voting round is closed.
- Publishes results back to the blockchain
- RESTful API for client interactions

---

### **ZK Program + Noir Circuits** (`/program`, `/circuits`)

- `program/`: Rust guest code compiled to the RISC Zero zkVM image that runs the CRISP tally logic
- `circuits/`: Noir circuits + SAFE/GRECO libraries used for membership proofs and encryption checks
- `scripts/compile_circuits.sh`: compiles Noir circuits, writes verification keys, and emits the
  `CRISPVerifier.sol` contract used by `packages/crisp-contracts`

---

### **Smart Contracts** (`/packages/crisp-contracts`)

Solidity contracts implementing the E3 program interface:

#### **CRISPProgram.sol**

Main E3 program contract implementing the `IE3Program` interface:

- `validate()`: Validates voting parameters and setup
- `verify()`: Verifies zkVM proofs of computation
- `validateInput()`: Handles vote validation and zero-knowledge proof verification:
  - Validates encrypted vote format
  - Verifies voter eligibility proofs
  - Ensures vote uniqueness

#### **CRISPVerifier.sol**

Noir verifier for proof of correct encryption:

- Verifies if the vote was encrypted correctly
- Verifies if the vote is valid

#### **CRISPPolicy.sol**

Manages voting policies and governance:

- Defines voting rules and constraints
- Manages voter registration

#### **CRISPChecker.sol**

Additional verification and checking logic:

- Vote format validation
- Eligibility checking
- Result verification

---

## Next Steps

To get started with CRISP:

1. **[Setup](/CRISP/setup)**: Install dependencies and configure your environment
2. **[Running E3](/CRISP/running-e3)**: Deploy and run the complete CRISP protocol
3. **Study the code**: Examine the implementation for your own E3 programs

CRISP demonstrates the full potential of E3 programs for privacy-preserving applications, providing
a complete reference implementation for developers building with Enclave.
