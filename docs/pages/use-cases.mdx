---
title: 'Use Cases'
---

# Unlocking Enclave Use Cases

Leading confidential-compute platforms such as Ritual, Fhenix, and Olas showcase their ecosystems by
highlighting concrete scenarios, personas, and playbooks. This page borrows that structure so you
can quickly map Enclave building blocks to the outcomes you need.

## Confidential Governance (CRISP-style)

- **Problem**: Public DAOs struggle to keep tallies, delegations, and vote rationales private during
  sensitive decisions.
- **Pattern**: Use the CRISP template (client, Rust server, Noir circuits) with the Enclave SDK.
- **Flow**: DAO admins request an E3 round, contributors encrypt ballots in the browser, and
  Ciphernodes publish a verifiable plaintext tally once the compute provider finishes.
- **Extras**: Plug Synpress or Playwright into the client for scripted voting drills.

## Private Auctions & Matching Markets

- **Problem**: Sealed-bid auctions or RFQ desks cannot run on public ledgers without leaking prices.
- **Pattern**: Model each bid as an input validated by account-specific ZKPs (range/whitelist) and
  aggregate them off-chain using BFV-friendly arithmetic in your Secure Process.
- **Flow**: Traders submit encrypted bids, the compute provider selects the clearing price, and the
  plaintext output unlocks settlement logic.
- **Extras**: Pair with Foundry scripts (similar to Fhenix's CoFHE quick starts) to simulate extreme
  bidding volumes before mainnet.

## AI Agent Coordination

- **Problem**: Networks such as Ritual and Olas expose agent marketplaces; those agents still need a
  privacy-preserving substrate for sensitive scoring, routing, or risk checks.
- **Pattern**: Treat each agent as a Data Provider, push policy enforcement into an
  `IInputValidator`, and let Enclave host shared state transitions (e.g., allocating budget or
  updating trust scores).
- **Flow**: Agents encrypt telemetry, the Secure Process derives rankings, and downstream contracts
  or marketplaces read the published plaintext.
- **Extras**: Use `customParams` inside `E3RequestParams` to tag rounds per agent vertical (NFT
  curation, wallet assistants, on-chain AI retrieval).

## Identity, Compliance, and Scoring

- **Problem**: Identity attestations or credit scores leak sensitive attributes when stored directly
  on-chain.
- **Pattern**: Build circuits that validate proofs of residency, KYC, or AML results without
  revealing raw data; only the computed risk vector is decrypted.
- **Flow**: Validators encrypt attestations, the Secure Process derives the minimal disclosure blob,
  and downstream protocols pull the plaintext via `PlaintextOutputPublished`.
- **Extras**: Combine with `customParams` to pin jurisdictional policy, similar to how Fhenix
  exposes "Key Considerations" per sector.

## Solution Matrix

| Scenario                | Typical Inputs              | Secure Process Focus                 | Output Consumers                  |
| ----------------------- | --------------------------- | ------------------------------------ | --------------------------------- |
| Confidential Governance | Wallet + ballot selections  | Vote aggregation, quorum, randomness | DAO front-ends, multi-sigs        |
| Private Auctions        | Bid amount, bidder proofs   | Price discovery, winner selection    | Settlement contracts              |
| AI Agent Coordination   | Agent telemetry, task queue | Ranking, budget splits               | Agent marketplaces, orchestrators |
| Identity / Compliance   | Encrypted attestations      | Risk flag derivation                 | On-chain registries, bridges      |

Next, explore the [Best Practices](/best-practices) and
[Putting It All Together](/putting-it-together) guides to tailor these patterns to your app.
