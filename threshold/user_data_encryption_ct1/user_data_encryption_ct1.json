{"noir_version":"1.0.0-beta.16+2d46fca7203545cbbfb31a0d0328de6c10a8db95","hash":"1952841675897176234","abi":{"parameters":[{"name":"pk1is","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":512,"type":{"kind":"field"}}}]}},"visibility":"private"},{"name":"ct1is","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":512,"type":{"kind":"field"}}}]}},"visibility":"private"},{"name":"u","type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":512,"type":{"kind":"field"}}}]},"visibility":"private"},{"name":"e1","type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":512,"type":{"kind":"field"}}}]},"visibility":"private"},{"name":"p1is","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":1023,"type":{"kind":"field"}}}]}},"visibility":"private"},{"name":"p2is","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":511,"type":{"kind":"field"}}}]}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"18258692384630939949":{"error_kind":"string","string":"ct1 encryption check failed"}}},"bytecode":"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","debug_symbols":"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eDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYdLPFzi4RIPl3i4xMMlHi7xcImHSzxc4uESD5d4uMTDJR4u8XCJh0s8XOLhEg+XeLjEwyUeLvFwiYe7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7t4uIuHu3i4i4e7eLiLh7s/PNzJH1fG1R9nnP5x5VwFH02uLh8trpqPzl79mfOvj/6Z8+fq8FHnKvhocnX5aHHVfHT26jLHZY7LHJc5LnNc5rjMcZnjMsdljmKOYo5ijmKOYo5ijmKOYo5ijmKOZo5mjmaOZo5mjmaOZo5mjmaOZo5hjmGOYY5hjmGOYY5hjmGOYY7ZOX54uB8f/eHhnqvDR52r4KPJ1eWjxVXz0Z3jh4f7+qgZV4ePOlfBR5Ory0eLq+ajzHGY4zDHYY7DHIc5DnMc5jjMcZjjMIczhzOHM4czhzOHM4czhzOHM4czBzk/5PyQ80PODzk/5PyQ80PODzk/5PyQ80PODzk/5PyQ80PODzk/5PyQ80PODzk/5PyQ80PODzk/5PyQ80PODzk/5PyQ80PODzk/5PyQ80PODzk/5PyQ80PODzk/5PyQ80PODzk/5PyQ80PODzk/5PyQ80PODzk/5PyQ80PODzk/5PyQ80POnZw7OXdy7uTcybmTcyfnTs6dnDs5d3Lu5NzJuZNzJ+dOzp2cOzl3cu7k3Mm5k3Mn507OnZw7OXdy7uTcybmTcyfnTs6dnDs5d3Lu5NzJuZNzJ+dOzp2cOzl3cu7k3Mm5k3Mn507OnZw7OXdy7uTcybmTcyfnTs6dnDs5d3Lu5NzJuZNzJ+dOzp2cOzl3cu7k3Mm5k3Mn507OnZw7OXdy7uTcybmTcyfnTs6dnDs5d3Lu5NzJuZNzJ+dOzp2cOzl3cu7k3Mm5k3Mn507OnZw7OXdy7uQ8yHmQ8yDnQc6DnAc5D3Ie5DzIeZDzIOdBzoOcBzkPch7kPMh5kPMg50HOg5wHOQ9yHuQ8yHmQ8yDnQc6DnAc5D3Ie5DzIeZDzIOdBzoOcBzkPch7kPMh5kPMg50HOg5wHOQ9yHuQ8yHmQ8yDnQc6DnAc5D3Ie5DzIeZDzIOdBzoOcBzkPch7kPMh5kPMg50HOg5wHOQ9yHuQ8yHmQ8yDnQc6DnAc5D3Ie5DzIeZDzIOdBzoOcBzkPch7kPMh5kPMg50HOg5wHOQ9yHuQ8yHmQ8yDnQc6TnCc5T3Ke5DzJeZLzJOdJzpOcJzlPcp7kPMl5kvMk50nOk5wnOU9ynuQ8yXmS8yTnSc6TnCc5T3Ke5DzJeZLzJOdJzpOcJzlPcp7kPMl5kvMk50nOk5wnOU9ynuQ8yXmS8yTnSc6TnCc5T3Ke5DzJeZLzJOdJzpOcJzlPcp7kPMl5kvMk50nOk5wnOU9ynuQ8yXmS8yTnSc6TnCc5T3Ke5DzJeZLzJOdJzpOcJzlPcp7kPMl5kvMk50nOk5wnOU9ynuQ8yXmS8yTnSc6TnCc5T3Ke5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5PyS80vOLzm/5LzIeZHzIudFzoucFzkvcl7kvMh5kfMi50XOi5wXOS9yXuS8yHmR8yLnRc6LnBc5L3Je5LzIeZHzIudFzoucFzkvcl7kvMh5kfMi50XOi5wXOS9yXuS8yHmR8yLnRc6LnBc5L3Je5LzIeZHzIudFzoucFzkvcl7kvMh5kfMi50XOi5wXOS9yXuS8yHmR8yLnRc6LnBc5L3Je5LzIeZHzIudFzoucFzkvcl7kvMh5kfMi50XOi5wXOS9yXuS8yHmR8yLnRc6LnBc5L3Je5LzIeZHzIudFzpucNzlvct7kvMl5k/Mm503Om5w3OW9y3uS8yXmT8ybnTc6bnDc5b3Le5LzJeZPzJudNzpucNzlvct7kvMl5k/Mm503Om5w3OW9y3uS8yXmT8ybnTc6bnDc5b3Le5LzJeZPzJudNzpucNzlvct7kvMl5k/Mm503Om5w3OW9y3uS8yXmT8ybnTc6bnDc5b3Le5LzJeZPzJudNzpucNzlvct7kvMl5k/Mm503Om5w3OW9y3uS8yXmT8ybnTc6bnDc5b3Le5LzJeZPzJudNzpucNzlvct7kfMj5kPMh50POh5wPOR9yPuR8yPmQ8yHnQ86HnA85H3I+5HzI+ZDzIedDzoecDzkfcj7kfMj5kPMh50POh5wPOR9yPuR8yPmQ8yHnQ86HnA85H3I+5HzI+ZDzIedDzoecDzkfcj7kfMj5kPMh50POh5wPOR9yPuR8yPmQ8yHnQ86HnA85H3I+5HzI+ZDzIedDzoecDzkfcj7kfMj5kPMh50POh5wPOR9yPuR8yPmQ8yHnQ86HnA85H3I+5HzI+ZDzIedDzoecDzkfcj7kfMj5kPMh57M5r8/mvD6b8/pszuuzOa/P5rw+m/P6bM7rszmvz+a8Ppvz+mzO67M5r8/mvD6b8/pszuuzOa/P5rw+m/P6bM7rY8xxmOMwx2GOwxyHOQ5zHOY4zHGY4zCHM4czhzOHM4czhzOHM4czhzOHM0cwRzBHMEcwRzBHMEcwRzBHMEcwRzJHMkcyRzJHMkcyRzJHMkcyRzLHZY7LHJc5LnNc5rjMcZnjMsdljsscxRzFHMUcxRzFHMUcxRzFHMUcxRzNHM0czRzNHM0czRzNHM0czRzNHMMcwxzDHMMcwxzDHMMcwxzDHOTcyLmRcyPnRs6NnBs5N3Ju5NzIuZFzI+dGzo2cGzk3cm7k3Mi5kXMj50bOjZwbOTdybuTcyLmRcyPnRs6NnBs5N3Ju5NzIuZFzI+dGzo2cGzk3cm7kHA9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7Zl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL7XZl9rsS232pTb7Upt9qc2+1GZfarMvtdmX2uxLbfalNvtSm32pzb7UZl9qsy+12Zfa7Ett9qU2+1KbfanNvtRmX2qzL3XYlzrsSx32pQ77Uod9qcO+1GFf6rAvddiXOuxLHfalDvtSh32pw77UYV/qsC912Jc67Esd9qUO+1KHfanDvtRhX+qwL3XYlzrsSx32pQ77Uod9qcO+1GFf6rAvddiXOuxLHfalDvtSh32pw77UYV/qsC912Jc67Esd9qUO+1KHfanDvtRhX+qwL3XYlzrsSx32pQ77Uod9qcO+1GFf6rAvddiXOuxLHfalDvtSh32pw77UYV/qsC912Jc67Esd9qUO+1KHfanDvtRhX+qwL3XYlzrsSx32pQ77Uod9qcO+1GFf6rAvddiXOuxLHfalDvtSh32pw77UYV/qsC912Jc67Esd9qUO+1KHfanDvtRhX+qwL3XYlzrsSx32pQ77Uod9qcO+1GFf6rAvddiXOuxLHfalDvtSh32pw77UYV/qsC912Jc67Esd9qUO+1KHfanDvtRhX+qwL3XYlzrsSx32pQ77Uod9qcO+1GFf6rAvddiXOuxLHfalDvtSh32pw77UYV/qsC912Jc67Esd9qUO+1LHyLmRcyPnRs6NnBs5N3Ju5NzIuZFzI+dGzo2cGzk3cm7k3Mi5kXMj50bOjZwbOTdybuTcyLmRcyPnRs6NnBs5N3Ju5NzIuZFzI+dGzo2cGzk3cm7k3Mi5kXMj50bO8XCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMN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qS5JdUmqS1JdkuqSVJekuiTVJakuSXVJqktSXZLqklSXpLok1SWpLkl1SapLUl2S6pJUl6S6JNUlqS5JdUmqS1JdkuqSVJekuiTVJakuSXVJqktSXZLqklSXpLok1SWpLkl1SapLUl2S6pJUl6S6JNUlqS5JdUmqS1JdkuqSVJekuiTVJakuSXVJqktSXZLqklSXpLok1SWpLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy4pdUmpS0pdUuqSUpeUuqTUJaUuKXVJqUtKXVLqklKXlLqk1CWlLil1SalLSl1S6pJSl5S6pNQlpS4pdUmpS0pdUuqSUpeUuqTUJaUuKXVJqUtKXVLqklKXlLqk1CWlLil1SalLSl1S6pJSl5S6pNQlpS4pdUmpS0pdUuqSUpeUuqTUJaUuKXVJqUtKXVLqklKXlLqk1CWlLil1SalLSl1S6pJSl5S6pNQlpS4pdUmpS0pdUuqSUpeUuqTUJaUuKXVJqUtKXVLqklKXlLqk1CWlLil1SalLSl1S6pJSl5S6pNQlpS4pdUmpS0pdUuqSVpe0uqTVJa0uaXVJq0taXdLqklaXtLqk1SWtLml1SatLWl3S6pJWl7S6pNUlrS5pdUmrS1pd0uqSVpe0uqTVJa0uaXVJq0taXdLqklaXtLqk1SWtLml1SatLWl3S6pJWl7S6pNUlrS5pdUmrS1pd0uqSVpe0uqTVJa0uaXVJq0taXdLqklaXtLqk1SWtLml1SatLWl3S6pJWl7S6pNUlrS5pdUmrS1pd0uqSVpe0uqTVJa0uaXVJq0taXdLqklaXtLqk1SWtLml1SatLWl3S6pJWl7S6pNUlrS5pdUmrS1pd0uqSVpe0uqTVJa0uGXXJqEtGXTLqklGXjLpk1CWjLhl1yahLRl0y6pJRl4y6ZNQloy4ZdcmoS0ZdMuqSUZeMumTUJaMuGXXJqEtGXTLqklGXjLpk1CWjLhl1yahLRl0y6pJRl4y6ZNQloy4ZdcmoS0ZdMuqSUZeMumTUJaMuGXXJqEtGXTLqklGXjLpk1CWjLhl1yahLRl0y6pJRl4y6ZNQloy4ZdcmoS0ZdMuqSUZeMumTUJaMuGXXJqEtGXTLqklGXjLpk1CWjLhl1yahLRl0y6pJRl4y6ZNQloy4ZdcmoS0ZdMuqSUZeMumTUJaMuGXXJqEtGXSL3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKvR+71yL0eudcj93rkXo/c65F7PXKv54d7Pfl1Wbr847TTX5fD5Z9d8vyBP7tkL4/+gOsy9AdSl1d/oHTZ+gPD5Z9d8vyBP7tkL4/+gOsy9AdSl5ptNNtotmG2H+716w/8cK97efQHXJehP5C6vPoDpcvWH2C2H+71+QNmujz6A67L0B9IXV79gdJl6w9otqPZjmY7mu1otqPZjmY7mu1otqPZjmZzzeaazTWbazbXbK7ZXLO5ZnPN5potNFtottBsodlCs4VmC80Wmi00W2i21Gyp2VKzpWZLzZaaLTVbarbUbKnZrma7mu1qtqvZrma7mu1qtqvZrma7mq00W2m20myl2UqzlWZTl7i6xNUlri5xdYmrS1xd4uoSV5e4usTVJa4ucXWJq0tcXeLqEleXuLrE1SWuLnF1iatLXF3i6pJQl4S6JNQloS4JdUmoS0JdEuqSUJeEuiTUJaEuCXVJqEtCXRLqklCXhLok1CWhLgl1SahLQl0S6pJQl4S6JNQloS4JdUmoS0JdEuqSUJeEuiTUJaEuCXVJqEtCXRLqklCXhLok1CWhLgl1SahLQl0S6pJQl4S6JNQloS4JdUmoS0JdEuqSUJeEuiTUJaEuCXVJqEtCXRLqklCXhLok1CWhLgl1SahLQl0S6pJQl4S6JNQloS4JdUmoS0JdEuqSUJeEuiTUJaEuCXVJqEtCXRLqklCXhLok1CWhLgl1SahLQl0S6pJQl4S6JNQloS5JdUmqS1JdkuqSVJekuiTVJakuSXVJqktSXZLqklSXpLok1SWpLkl1SapLUl2S6pJUl6S6JNUlqS5JdUmqS1JdkuqSVJekuiTVJakuSXVJqktSXZLqklSXpLok1SWpLkl1SapLUl2S6pJUl6S6JNUlqS5JdUmqS1JdkuqSVJekuiTVJakuSXVJqktSXZLqklSXpLok1SWpLkl1SapLUl2S6pJUl6S6JNUlqS5JdUmqS1JdkuqSVJekuiTVJakuSXVJqktSXZLqklSXpLok1SWpLkl1SapLUl2S6pJUl6S6JNUlqS5JdUmqS1JdkuqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqklKXlLqk1CWlLil1SalLSl1S6pJSl5S6pNQlpS4pdUmpS0pdUuqSUpeUuqTUJaUuKXVJqUtKXVLqklKXlLqk1CWlLil1SalLSl1S6pJSl5S6pNQlpS4pdUmpS0pdUuqSUpeUuqTUJaUuKXVJqUtKXVLqklKXlLqk1CWlLil1SalLSl1S6pJSl5S6pNQlpS4pdUmpS0pdUuqSUpeUuqTUJaUuKXVJqUtKXVLqklKXlLqk1CWlLil1SalLSl1S6pJSl5S6pNQlpS4pdUmpS0pdUuqSUpeUuqTUJaUuKXVJqUtKXVLqklKXlLqk1CWlLml1SatLWl3S6pJWl7S6pNUlrS5pdUmrS1pd0uqSVpe0uqTVJa0uaXVJq0taXdLqklaXtLqk1SWtLml1SatLWl3S6pJWl7S6pNUlrS5pdUmrS1pd0uqSVpe0uqTVJa0uaXVJq0taXdLqklaXtLqk1SWtLml1SatLWl3S6pJWl7S6pNUlrS5pdUmrS1pd0uqSVpe0uqTVJa0uaXVJq0taXdLqklaXtLqk1SWtLml1SatLWl3S6pJWl7S6pNUlrS5pdUmrS1pd0uqSVpe0uqTVJa0uaXVJq0taXdLqklaXtLqk1SWtLml1SatLWl3S6pJRl4y6ZNQloy4ZdcmoS0ZdMuqSUZeMumTUJaMuGXXJqEtGXTLqklGXjLpk1CWjLhl1yahLRl0y6pJRl4y6ZNQloy4ZdcmoS0ZdMuqSUZeMumTUJaMuGXXJqEtGXTLqklGXjLpk1CWjLhl1yahLRl0y6pJRl4y6ZNQloy4ZdcmoS0ZdMuqSUZeMumTUJaMuGXXJqEtGXTLqklGXjLpk1CWjLhl1yahLRl0y6pJRl4y6ZNQloy4ZdcmoS0ZdMuqSUZeMumTUJaMuGXXJqEtGXTLqklGXjLpk1CWjLhl1yahLRl0y6pJRl4y6ZNQlQ5f4hy7xD13iH7rEP3SJf+gS/9Al/qFL/EOX+Icu8Q9d4h+6xD90iX/oEv/QJf6hS/xDl/iHLvEPXeIfusQ/ptmOZjua7Wi2o9mOZjua7Wi2o9mOZjuazTWbazbXbK7ZXLO5ZnPN5prNNZtrttBsodlCs4VmC80Wmi00W2i20Gyh2VKzpWZLzZaaLTVbarbUbKnZUrOlZrua7Wq2q9muZrua7Wq2q9muZrua7Wq20myl2UqzlWYrzVaarTRbabbSbKXZWrO1ZmvN1pqtNVtrttZsrdlas7VmG802mm0022i20Wyj2UazjWYbzaYuMXWJqUtMXWLqElOXmLrE1CWmLjF1ialLTF1i6hJTl5i6xNQlpi4xdYmpS0xdYuoSU5eYusTUJaYuMXWJqUtMXWLqElOXmLrE1CWmLjF1ialLTF1i6hJTl5i6xNQlpi4xdYmpS0xdYuoSU5eYusTUJaYuMXWJqUtMXWLqElOXmLrE1CWmLjF1ialLTF1i6hJTl5i6xNQlpi4xdYmpS0xdYuoSU5eYusTUJaYuMXWJqUtMXWLqElOXmLrE1CWmLjF1ialLTF1i6hJTl5i6xNQlpi4xdYmpS0xdYuoSU5eYusTUJaYuMXWJqUtMXWLqkqMuOeqSoy456pKjLjnqkqMuOeqSoy456pKjLjnqkqMuOeqSoy456pKjLjnqkqMuOeqSoy456pKjLjnqkqMuOeqSoy456pKjLjnqkqMuOeqSoy456pKjLjnqkqMuOeqSoy456pKjLjnqkqMuOeqSoy456pKjLjnqkqMuOeqSoy456pKjLjnqkqMuOeqSoy456pKjLjnqkqMuOeqSoy456pKjLjnqkqMuOeqSoy456pKjLjnqkqMuOeqSoy456hK5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3sNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQew2515B7DbnXkHsNudeQe40f7jXq69J0eXTpugxdpi6vLkuXrcvh0nWa6zTXaa7TXKe5TnOd5jrNdZrrtNBpodNCp4VOC50WOi10Wui00Gmh01KnpU5LnZY6LXVa6rTUaanTUqelTrs67eq0q9OuTrs67eq0q9OuTrs67eq00mml00qnlU4rnVY6rXRa6bTSaaXTWqe1Tmud1jqtdVrrtNZprdNap7VOG502Om102ui00Wmj00anjU4bnTac9sO97qXp8ujSdRm6TF1eXZYuW5c6zXSa6TTTaabTTKeZTjOdZjrNdJrpNHVJqEtCXRLqklCXhLok1CWhLgl1SahLQl0S6pJQl4S6JNQloS4JdUmoS0JdEuqSUJeEuiTUJaEuCXVJqEtCXRLqklCXhLok1CWhLgl1SahLQl0S6pJQl4S6JNQloS4JdUmoS0JdEuqSUJeEuiTUJaEuCXVJqEtCXRLqklCXhLok1CWhLgl1SahLQl0S6pJQl4S6JNQloS4JdUmoS0JdEuqSUJeEuiTUJaEuCXVJqEtCXRLqklCXhLok1CWhLkl1SapLUl2S6pJUl6S6JNUlqS5JdUmqS1JdkuqSVJekuiTVJakuSXVJqktSXZLqklSXpLok1SWpLkl1SapLUl2S6pJUl6S6JNUlqS5JdUmqS1JdkuqSVJekuiTVJakuSXVJqktSXZLqklSXpLok1SWpLkl1yQ/3mvHj8s8u2cs/Tiv/ujy6dF2GLlOXV5ely9blcPlnl+ylTrs67eq0q9OuTrs67eq0q9OuTiudVjqtdFrptNJppdNKp5VOK51WOq11Wuu01mmt01qntU5rndY6rXVa67TRaaPTRqeNThudNjptdNrotNFpw2k/3Otemi6PLl2XocvU5dVl6bJ1qdNMp5lOM51mOs10muk002mm00ynmU47Ou3otKPTjk47Ou3otKPTjk47Ou3oNNdprtNcp7lOc53mOs11mus012mu00KnhU4LnRY6LXRa6LTQaaHTQqeFTkudpi656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy656pKrLrnqkqsuueqSqy4pdUmpS0pdUuqSUpeUuqTUJaUuKXVJqUtKXVLqklKXlLqk1CWlLil1SalLSl1S6pJSl5S6pNQlpS4pdUmpS0pdUuqSUpeUuqTUJaUuKXVJqUtKXVLqklKXlLqk1CWlLil1SalLSl1S6pJSl5S6pNQlpS4pdUmpS0pdUuqSUpeUuqTUJaUuKXVJqUtKXVLqklKXlLqk1CWlLil1SalLSl1S6pJSl5S6pNQlpS4pdUmpS0pdUuqSUpeUuqTUJaUu+eFe+/N1abr847Tpr0vXZegydXl1WbpsXQ6Xf3bJXpouddrotNFpo9NGp41OG502nPbDve6l6fLo8o/T/ngE/HUdr+t8Xf9x4B9PNL+u63Xdr+vR9Y/1fXttr+vzuvbXdbyu83X9Otde59rrXHude17nnte553XueZ17Xuee17nnde55nXte557Xuf4611/n+utcf53rr3P9da6/zvXXuf4611/nxuvceJ0br3PjdW68zo3XufE6N17nxuvceJ2br3PzdW6+zs3Xufk6N1/n5uvcfJ2br3Pzde59nXtf597Xufd17n2de1/n3te593XufZ17X+fW69x6nVuvc+t1br3Orde59Tq3XufW69x6nduvc/t1br/O7de5/Tq3X+f269x+nduvc/t17rzOnde58zp3XufO69x5nTuvc+d17rzOHZ37A9Zyba/r87r213W8rvN1fV/X9bru1/Xr3Fdfzauv5tVX8+qrefXVvPpqXn01r76aV1/Nq6/m1Vfz6qt59dW8+mpefTWvvppXX82rr+bVV/Pqq3n11bz6al59Na++mldfzauv5tVX8+qrefXVvPpqXn01r76aV1/Nq6/m1Vfz6qt59dW8+mpefTWvvppXX82rr+bVV/Pqq3n11bz6al59Na++mldfzauv5tVX8+qrefXVvPpqXn01r76aV1/Nq6/m1Vfz6qt59dW8+mpefTWvvppXX82rr+bVV/Pqq3n11bz6al59Na++mldfzauv5tVX8+qrefXVvPpqXn01r76aV1/Nq6/m1Vfz6qt59dW8+mpefTWvvppXX436Kj/qq/yor/KjvsqP+io/6qv8qK/yo77Kj/oqP+qr/Hxe59rrXHuda69z7XWuvc6117n2Otde59rrXHude17nnte553XueZ17Xuee17nnde55nXte557Xuf4611/n+utcf53rr3P9da6/zvXXuf4611/nxuvceJ0br3PjdW68zo3XufE6N17nxuvceJ2br3PzdW6+zs3Xufk6N1/n5uvcfJ2br3Pzde59nXtf597Xuf9fU3eQa1uSm2d0Lmq7ccgIkkHPxRAkuWwUUFAJZcmAYdTcpfdeZp7V48VpfL3VuYF/N92m23SbbtNtuk136A7doTt0h+7QHbpDd+gO3Uf30X10H91H99F9dB/dR/fRXbpLd+ku3aW7dJfu0l26eBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXj18+HyfwH56z7cl7u4f3Tv+3UP9+Pe7/3Tq9/v4E7uw/2jW/HrLu7mHu7Hvd/7p1e/38Gd3Ieb7tAdukN36A7dR/fRfXQf3Uf30X10H91H99Fdukt36S7dpbt0l+7SXbr77f586PzHHdzJfbgvd3E393A/brpBN+gG3aAbdINu0A26QTfoJt2km3STbtJNukk36SbdpHvoHrqH7qF76B66h+6he+geupfupXvpXrqX7qV76V66l+6lW3SLbtEtukW36Bbdolt0i27TbbpNt+ni1cGrg1cHrw5eHbw6eHXw6uDVwauDVwevDl4dvDp4dfDq4NXBq4NXB68OXh28Onh18Org1cGrg1cHrw5eHbw6eHXw6uDVwauDVwevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfGq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq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/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/225f99mW/fdlvX/bbl/32Zb992W9f9tuX/fZlv33Zb1/2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8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8WrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8Grw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dVv79vr1/2zu7/uH90fO/8/7std3M093I97v/cf35v4cQd3ctNdukt36S7dpbvf7n4+3MGd3If7chd3cw/346YbdINu0A26QTfoBt2gG3SDbtJNukk36SbdpJt0k27STbqH7qF76B66h+6he+geuofuoXvpXrqX7qV76V66l+6le+leukW36Bbdolt0i27RLbpFt+g23abbdJtu0226TbfpNt2mO3SH7tAdukN36A7doTt0h+6j++g+uni1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1X6/i8/UqPl+v4vP1Kj5fr+Lz9So+X6/i8/UqPl+v4vP1Kj4fukE36AbdoBt0g27QDbpBN+gm3aSbdJNu0k26STfpJt2ke+geuofuoXvoHrqH7qF76B66l+6le+leupfupXvpXrqX7qVbdItu0S26RbfoFt2iW3SLbtNtuk236Tbdptt0m27TbbpDd+gO3aE7dIfu0B26Q3foPrqP7qP76D66j+6j++g+uo/u0l26S3fpLt2lu3SX7tLFq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKuDVwevDl4dvDp4dfDq4NXBq4NXB68OXh28Onh18Org1cGrg1cHrw5eHbw6eHXw6uDVwauDVwevDl4dvDp4dfDq4NXBq4NXB68OXh28Onh18Org1cGrg1cHrw5eHbw6eHXw6uDVwauDVwevDl4dvDp4dfDq4NXBq4NXB68OXh28Onh18Org1cGrg1cHrw5eHbw6eHXw6uDVwauDVwevDl4dvDp4dfDq4NXBq4NXB68OXh28Onh18Org1cGrg1cHrw5eHbw6ePXrffuPb/j+uH9269f9s/v+/t/+4f/+09/+/E///Jc//Z9/+O///7/+/F//8a//8u9//uu//vbnv/+/f/v9l3/+25//8pc//+9//Le//fVf/vQ//+Nvf/rHv/z1X37+9vf/8ff/BA==","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse lib::configs::default::threshold::{\n    L, N, USER_DATA_ENCRYPTION_BIT_CT, USER_DATA_ENCRYPTION_BIT_E1, USER_DATA_ENCRYPTION_BIT_P1,\n    USER_DATA_ENCRYPTION_BIT_P2, USER_DATA_ENCRYPTION_BIT_PK, USER_DATA_ENCRYPTION_BIT_U,\n    USER_DATA_ENCRYPTION_CT1_CONFIGS,\n};\nuse lib::core::threshold::user_data_encryption_ct1::UserDataEncryptionCt1;\nuse lib::math::polynomial::Polynomial;\n\nfn main(\n    pk1is: [Polynomial<N>; L],\n    ct1is: [Polynomial<N>; L],\n    u: Polynomial<N>,\n    e1: Polynomial<N>,\n    p1is: [Polynomial<(2 * N) - 1>; L],\n    p2is: [Polynomial<N - 1>; L],\n) -> pub (Field, Field, Field) {\n    let circuit: UserDataEncryptionCt1<N, L, USER_DATA_ENCRYPTION_BIT_PK, USER_DATA_ENCRYPTION_BIT_CT, USER_DATA_ENCRYPTION_BIT_U, USER_DATA_ENCRYPTION_BIT_E1, USER_DATA_ENCRYPTION_BIT_P1, USER_DATA_ENCRYPTION_BIT_P2> = UserDataEncryptionCt1::new(\n        USER_DATA_ENCRYPTION_CT1_CONFIGS,\n        pk1is,\n        ct1is,\n        u,\n        e1,\n        p1is,\n        p2is,\n    );\n\n    circuit.execute()\n}\n","path":"enclave/circuits/bin/threshold/user_data_encryption_ct1/src/main.nr"},"74":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\n//user data encryption for ct1- the second part of the ciphertext\nuse crate::math::commitments::compute_multiple_polynomial_commitment;\nuse crate::math::commitments::compute_single_polynomial_commitment;\nuse crate::math::commitments::compute_user_data_encryption_ct1_challenge;\nuse crate::math::commitments::DS_CIPHERTEXT;\nuse crate::math::commitments::DS_PK_AGGREGATION;\nuse crate::math::commitments::DS_USER_DATA_ENCRYPTION_COMMITMENT;\nuse crate::math::helpers::flatten;\nuse crate::math::polynomial::Polynomial;\n\npub struct Configs<let N: u32, let L: u32> {\n    pub qis: [Field; L],\n    pub e1_bound: Field,\n    pub u_bound: Field,\n    pub p1_bounds: [Field; L],\n    pub p2_bounds: [Field; L],\n}\nimpl<let N: u32, let L: u32> Configs<N, L> {\n    pub fn new(\n        qis: [Field; L],\n        e1_bound: Field,\n        u_bound: Field,\n        p1_bounds: [Field; L],\n        p2_bounds: [Field; L],\n    ) -> Self {\n        Configs { qis, e1_bound, u_bound, p1_bounds, p2_bounds }\n    }\n}\n\npub struct UserDataEncryptionCt1<let N: u32, let L: u32, let BIT_PK: u32, let BIT_CT: u32, let BIT_U: u32, let BIT_E1: u32, let BIT_P1: u32, let BIT_P2: u32> {\n    configs: Configs<N, L>,\n    pk1is: [Polynomial<N>; L],\n    ct1is: [Polynomial<N>; L],\n    /// Re-witnessed privately, checked against commit_u from Circuit A\n    u: Polynomial<N>,\n    e1: Polynomial<N>,\n    p1is: [Polynomial<(2 * N) - 1>; L],\n    p2is: [Polynomial<N - 1>; L],\n}\n\nimpl<let N: u32, let L: u32, let BIT_PK: u32, let BIT_CT: u32, let BIT_U: u32, let BIT_E1: u32, let BIT_P1: u32, let BIT_P2: u32> UserDataEncryptionCt1<N, L, BIT_PK, BIT_CT, BIT_U, BIT_E1, BIT_P1, BIT_P2> {\n\n    pub fn new(\n        configs: Configs<N, L>,\n        pk1is: [Polynomial<N>; L],\n        ct1is: [Polynomial<N>; L],\n        u: Polynomial<N>,\n        e1: Polynomial<N>,\n        p1is: [Polynomial<2 * N - 1>; L],\n        p2is: [Polynomial<N - 1>; L],\n    ) -> Self {\n        UserDataEncryptionCt1 { configs, pk1is, ct1is, u, e1, p1is, p2is }\n    }\n\n    fn check_range_bounds(self) {\n        self.e1.range_check_2bounds::<BIT_E1>(self.configs.e1_bound, self.configs.e1_bound);\n\n        for i in 0..L {\n            self.p1is[i].range_check_2bounds::<BIT_P1>(\n                self.configs.p1_bounds[i],\n                self.configs.p1_bounds[i],\n            );\n            self.p2is[i].range_check_2bounds::<BIT_P2>(\n                self.configs.p2_bounds[i],\n                self.configs.p2_bounds[i],\n            );\n        }\n    }\n\n    fn generate_commitments(self) -> (Field, Field, Field) {\n        let pk1_commitment =\n            compute_multiple_polynomial_commitment::<N, L, BIT_PK>(self.pk1is, DS_PK_AGGREGATION);\n        let ct1_commitment =\n            compute_multiple_polynomial_commitment::<N, L, BIT_CT>(self.ct1is, DS_CIPHERTEXT);\n        let u_commitment = compute_single_polynomial_commitment::<N, BIT_U>(\n            self.u,\n            DS_USER_DATA_ENCRYPTION_COMMITMENT,\n        );\n\n        (pk1_commitment, ct1_commitment, u_commitment)\n    }\n\n    fn generate_challenge(\n        self,\n        pk1_commitment: Field,\n        ct1_commitment: Field,\n        u_commitment: Field,\n    ) -> Vec<Field> {\n        let mut payload = Vec::new();\n\n        payload.push(pk1_commitment);\n        payload.push(ct1_commitment);\n        payload.push(u_commitment);\n\n        payload = flatten::<_, _, BIT_E1>(payload, [self.e1]);\n        payload = flatten::<_, _, BIT_P1>(payload, self.p1is);\n        payload = flatten::<_, _, BIT_P2>(payload, self.p2is);\n\n        compute_user_data_encryption_ct1_challenge::<L>(payload)\n    }\n\n    fn verify_evaluations(self, gammas: Vec<Field>) -> bool {\n        let gamma = gammas.get(0);\n        let cyclo_at_gamma = gamma.pow_32(N as Field) + 1;\n        let u_at_gamma = self.u.eval(gamma);\n        let e1_at_gamma = self.e1.eval(gamma);\n\n        let mut sum = (0, 0);\n        for i in 0..L {\n            let pk1is_at_gamma = self.pk1is[i].eval(gamma);\n            let p1is_at_gamma = self.p1is[i].eval(gamma);\n            let p2is_at_gamma = self.p2is[i].eval(gamma);\n\n            let mut ct1_rhs = pk1is_at_gamma * u_at_gamma + e1_at_gamma;\n            ct1_rhs += p1is_at_gamma * self.configs.qis[i];\n            ct1_rhs += p2is_at_gamma * cyclo_at_gamma;\n\n            let ct1_lhs = self.ct1is[i].eval(gamma);\n            let gamma_i = gammas.get(i + L);\n\n            sum = (sum.0 + ct1_lhs * gamma_i, sum.1 + ct1_rhs * gamma_i);\n        }\n\n        sum.0 == sum.1\n    }\n\n    /// Returns pk1_commitment, ct1_commitment and u_commitment\n    pub fn execute(self) -> (Field, Field, Field) {\n        self.check_range_bounds();\n\n        let (pk1_commitment, ct1_commitment, u_commitment) = self.generate_commitments();\n\n        let gammas = self.generate_challenge(pk1_commitment, ct1_commitment, u_commitment);\n\n        assert(self.verify_evaluations(gammas), \"ct1 encryption check failed\");\n\n        (pk1_commitment, ct1_commitment, u_commitment)\n    }\n}\n","path":"enclave/circuits/lib/src/core/threshold/user_data_encryption_ct1.nr"},"76":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse crate::math::helpers::{compute_safe, flatten};\nuse crate::math::polynomial::Polynomial;\n\n/// DOMAIN SEPARATORS\n\n// Domain separator - \"PK\"\npub global DS_PK: [u8; 64] = [\n    0x50, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"PK_GENERATION\"\npub global DS_PK_GENERATION: [u8; 64] = [\n    0x50, 0x4b, 0x5f, 0x47, 0x45, 0x4e, 0x45, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"SHARE_COMPUTATION\"\npub global DS_SHARE_COMPUTATION: [u8; 64] = [\n    0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x43, 0x4f, 0x4d, 0x50, 0x55, 0x54, 0x41, 0x54, 0x49, 0x4f,\n    0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"SHARE_ENCRYPTION\"\npub global DS_SHARE_ENCRYPTION: [u8; 64] = [\n    0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x45, 0x4e, 0x43, 0x52, 0x59, 0x50, 0x54, 0x49, 0x4f, 0x4e,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"PK_AGGREGATION\"\npub global DS_PK_AGGREGATION: [u8; 64] = [\n    0x50, 0x4b, 0x5f, 0x41, 0x47, 0x47, 0x52, 0x45, 0x47, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CIPHERTEXT\"\npub global DS_CIPHERTEXT: [u8; 64] = [\n    0x43, 0x49, 0x50, 0x48, 0x45, 0x52, 0x54, 0x45, 0x58, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"AGGREGATED_SHARES\"\npub global DS_AGGREGATED_SHARES: [u8; 64] = [\n    0x41, 0x47, 0x47, 0x52, 0x45, 0x47, 0x41, 0x54, 0x45, 0x44, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45,\n    0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"RECURSIVE_AGGREGATION\"\npub global DS_RECURSIVE_AGGREGATION: [u8; 64] = [\n    0x52, 0x45, 0x43, 0x55, 0x52, 0x53, 0x49, 0x56, 0x45, 0x5f, 0x41, 0x47, 0x47, 0x52, 0x45, 0x47,\n    0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_PK_GENERATION\"\npub global DS_CLG_PK_GENERATION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x50, 0x4b, 0x5f, 0x47, 0x45, 0x4e, 0x45, 0x52, 0x41, 0x54, 0x49, 0x4f,\n    0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_SHARE_ENCRYPTION\"\npub global DS_CLG_SHARE_ENCRYPTION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x45, 0x4e, 0x43, 0x52, 0x59, 0x50,\n    0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_USER_DATA_ENCRYPTION\"\npub global DS_CLG_USER_DATA_ENCRYPTION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x55, 0x53, 0x45, 0x52, 0x5f, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x45, 0x4e,\n    0x43, 0x52, 0x59, 0x50, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_SHARE_DECRYPTION\"\npub global DS_CLG_SHARE_DECRYPTION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x44, 0x45, 0x43, 0x52, 0x59, 0x50,\n    0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n\n// Domain separator - \"USER_DATA_ENCRYPTION_COMMITMENT\"\npub global DS_USER_DATA_ENCRYPTION_COMMITMENT: [u8; 64] = [\n    0x55, 0x53, 0x45, 0x52, 0x5f, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x45, 0x4e, 0x43, 0x52, 0x59, 0x50,\n    0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x43, 0x4f, 0x4d, 0x4d, 0x49, 0x54, 0x4d, 0x45, 0x4e, 0x54, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n\n/// WRAPPERS\n\npub fn compute_commitment(inputs: Vec<Field>, domain_separator: [u8; 64]) -> Field {\n    compute_safe(domain_separator, inputs, [0x80000000 | inputs.len(), 1]).get(0)\n}\n\npub fn compute_single_polynomial_commitment<let N: u32, let BIT: u32>(\n    polynomial: Polynomial<N>,\n    domain_separator: [u8; 64],\n) -> Field {\n    let mut payload = single_polynomial_payload::<N, BIT>(Vec::new(), polynomial);\n    compute_commitment(payload, domain_separator)\n}\n\npub fn compute_multiple_polynomial_commitment<let N: u32, let L: u32, let BIT: u32>(\n    polynomials: [Polynomial<N>; L],\n    domain_separator: [u8; 64],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT>(Vec::new(), polynomials);\n    compute_commitment(payload, domain_separator)\n}\n\npub fn compute_challenge<let L: u32>(inputs: Vec<Field>, domain_separator: [u8; 64]) -> Vec<Field> {\n    compute_safe(domain_separator, inputs, [0x80000000 | inputs.len(), 2 * L])\n}\n\npub fn single_polynomial_payload<let N: u32, let BIT_POLY: u32>(\n    payload: Vec<Field>,\n    input: Polynomial<N>,\n) -> Vec<Field> {\n    flatten::<_, _, BIT_POLY>(payload, [input])\n}\n\npub fn multiple_polynomial_payload<let N: u32, let L: u32, let BIT_POLY: u32>(\n    payload: Vec<Field>,\n    inputs: [Polynomial<N>; L],\n) -> Vec<Field> {\n    flatten::<_, _, BIT_POLY>(payload, inputs)\n}\n\n/// COMMITMENTS\n\npub fn compute_dkg_pk_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);\n    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);\n\n    compute_commitment(payload, DS_PK)\n}\n\npub fn compute_threshold_pk_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);\n    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);\n\n    compute_commitment(payload, DS_PK_GENERATION)\n}\n\npub fn compute_share_computation_sk_commitment<let N: u32, let BIT_SK: u32>(\n    sk: Polynomial<N>,\n) -> Field {\n    let mut payload = single_polynomial_payload::<N, BIT_SK>(Vec::new(), sk);\n    compute_commitment(payload, DS_SHARE_COMPUTATION)\n}\n\npub fn compute_share_computation_e_sm_commitment<let N: u32, let L: u32, let BIT_E_SM: u32>(\n    e_sm: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_E_SM>(Vec::new(), e_sm);\n    compute_commitment(payload, DS_SHARE_COMPUTATION)\n}\n\npub fn compute_share_encryption_commitment_from_message<let N: u32, let BIT_MSG: u32>(\n    message: Polynomial<N>,\n) -> Field {\n    let mut payload = single_polynomial_payload::<N, BIT_MSG>(Vec::new(), message);\n    compute_commitment(payload, DS_SHARE_ENCRYPTION)\n}\n\npub fn compute_share_encryption_commitment_from_shares<let N: u32, let L: u32, let N_PARTIES: u32>(\n    y: [[[Field; N_PARTIES + 1]; L]; N],\n    party_idx: u32,\n    mod_idx: u32,\n) -> Field {\n    let mut payload = Vec::new();\n\n    for coeff_idx in 0..N {\n        payload.push(y[coeff_idx][mod_idx][party_idx + 1]);\n    }\n\n    // Include party_idx and mod_idx in the hash\n    payload.push(party_idx as Field);\n    payload.push(mod_idx as Field);\n\n    compute_commitment(payload, DS_SHARE_ENCRYPTION)\n}\n\npub fn compute_aggregated_shares_commitment<let N: u32, let L: u32, let BIT_MSG: u32>(\n    agg_shares: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_MSG>(Vec::new(), agg_shares);\n    compute_commitment(payload, DS_AGGREGATED_SHARES)\n}\n\npub fn compute_pk_aggregation_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let commit_pk0 = compute_multiple_polynomial_commitment::<N, L, BIT_PK>(pk0, DS_PK_AGGREGATION);\n    let commit_pk1 = compute_multiple_polynomial_commitment::<N, L, BIT_PK>(pk1, DS_PK_AGGREGATION);\n\n    let mut inputs = Vec::new();\n    inputs.push(commit_pk0);\n    inputs.push(commit_pk1);\n\n    compute_commitment(inputs, DS_PK_AGGREGATION)\n}\n\npub fn compute_recursive_aggregation_commitment(payload: Vec<Field>) -> Field {\n    compute_commitment(payload, DS_RECURSIVE_AGGREGATION)\n}\n\npub fn compute_ciphertext_commitment<let N: u32, let L: u32, let BIT_CT: u32>(\n    ct0: [Polynomial<N>; L],\n    ct1: [Polynomial<N>; L],\n) -> Field {\n    let commit_ct0 = compute_multiple_polynomial_commitment::<N, L, BIT_CT>(ct0, DS_CIPHERTEXT);\n    let commit_ct1 = compute_multiple_polynomial_commitment::<N, L, BIT_CT>(ct1, DS_CIPHERTEXT);\n\n    let mut inputs = Vec::new();\n    inputs.push(commit_ct0);\n    inputs.push(commit_ct1);\n\n    compute_commitment(inputs, DS_CIPHERTEXT)\n}\n\n/// COMMITMENTS FOR CHALLENGES\n\npub fn compute_threshold_pk_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {\n    compute_challenge::<L>(payload, DS_CLG_PK_GENERATION)\n}\n\npub fn compute_share_encryption_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {\n    compute_challenge::<L>(payload, DS_CLG_SHARE_ENCRYPTION)\n}\n\npub fn compute_threshold_share_decryption_challenge<let L: u32>(payload: Vec<Field>) -> Field {\n    compute_challenge::<L>(payload, DS_CLG_SHARE_DECRYPTION).get(0)\n}\n\npub fn compute_user_data_encryption_ct0_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {\n    compute_challenge::<L>(payload, DS_CLG_USER_DATA_ENCRYPTION)\n}\n\npub fn compute_user_data_encryption_ct1_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {\n    compute_challenge::<L>(payload, DS_CLG_USER_DATA_ENCRYPTION)\n}\n","path":"enclave/circuits/lib/src/math/commitments.nr"},"77":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\n//! Helper functions for circuit construction and cryptographic operations.\nuse crate::math::polynomial::Polynomial;\nuse crate::math::safe::SafeSponge;\n\n/// Compute hex-aligned packing parameters for a given `BIT`.\n///\n/// # Purpose\n/// Returns `(nibble_bits, group)` for use by pack/flatten so layout stays consistent.\n/// - `nibble_bits`: ceil (`BIT`) to the next multiple of 4 (nibble alignment).\n///   - Examples: `BIT = 7 -> 8`, `BIT = 8 -> 8`, `BIT = 9 -> 12`, `BIT = 10 -> 12`, `BIT = 11 -> 12`,\n///     `BIT=16 -> 16`, `BIT = 17 -> 20`.\n/// - `group`: max number of encoded limbs that fit in one BN254 field element,\n///            when each limb uses an extra 4 bits (see below).\n///\n/// # Rationale\n/// - We align to nibbles so powers of two are hex-friendly and deterministic.\n/// - We reserve one extra nibble (4 bits) per stored value to lift signed\n///   coefficients into the non-negative range (e.g., store `v + 2^nibble_bits`),\n///   which implies a radix of `2^(nibble_bits + 4)`.\n///\n/// # Safety\n/// - Asserts `nibble_bits + 4 <= 254` to avoid mod-p wrap on BN254.\n/// - Ensures at least one limb fits: `group >= 1`.\nfn packing_layout<let BIT: u32>() -> (u32, u32) {\n    // Ceil BIT up to the next multiple of 4 (nibble alignment).\n    let nibble_bits = ((BIT + 3) / 4) * 4;\n\n    // Each stored limb uses an extra nibble because negative coefficients\n    // will be shifted to positive, so radix = 2^(nibble_bits+4).\n    assert(nibble_bits + 4 <= 254);\n\n    // Maximum limbs that fit in one BN254 element without wrap.\n    let group = 254 / (nibble_bits + 4);\n    assert(group >= 1);\n    (nibble_bits, group)\n}\n\n/// Flatten `L` polynomials into a single linear stream of packed `Field` carriers.\n///\n/// ## What this does\n/// - For each CRT limb `j` in `0..L`, it packs the coefficients of `poly[j]`\n///   with `pack::<A, BIT>` and appends all resulting carriers to `inputs`.\n/// - The packing layout (nibble-aligned width and `group` size) is taken from\n///   `packing_layout::<BIT>()` and must match what `pack` uses.\n///\n/// ## Determinism & order\n/// - Preserves a stable order: iterate `j = 0..L`, then for each `j` append\n///   carriers in ascending chunk index `i = 0..num_chunks`.\n/// - This ensures transcripts remain deterministic across runs.\n///\n/// ## Generics\n/// - `A`: polynomial degree (number of coefficients per polynomial).\n/// - `L`: number of CRT bases (polynomials).\n/// - `BIT`: per-coefficient bit bound used by the packing layout (compile-time).\n///\n/// ## Returns\n/// - The same `inputs` vector, extended with all carriers in deterministic order.\npub fn flatten<let A: u32, let L: u32, let BIT: u32>(\n    mut inputs: Vec<Field>,\n    poly: [Polynomial<A>; L],\n) -> Vec<Field> {\n    for j in 0..L {\n        // Pack its A coefficients into `num_chunks` carriers using the same BIT layout.\n        let packed = pack::<A, BIT>(poly[j].coefficients);\n\n        // Append carriers in-order to `inputs` to keep a stable transcript layout.\n        for i in 0..packed.len() {\n            inputs.push(packed.get(i));\n        }\n    }\n\n    // Return the extended input stream.\n    inputs\n}\n\n/// Pack `A` values into a `Vec<Field>` of carriers using the shared hex-aligned layout.\n///\n/// ## What this does\n/// - Computes `(nibble_bits, group)` via `packing_layout::<BIT>()`.\n/// - Encodes each value as a limb `digit = v + 2^nibble_bits` and concatenates\n///   limbs in base `radix = 2^(nibble_bits + 4)` (one extra nibble of headroom).\n/// - Packs up to `group` limbs per carrier (fits within BN254 254-bit capacity).\n/// - Pads the last, partial carrier with `digit = 2^nibble_bits` to keep a stable layout.\n///\n/// ## Determinism & order\n/// - Processes values in increasing index order and emits carriers in chunk order\n///   (`chunk = 0..num_chunks`). Padding is deterministic.\n///\n/// ## Generics\n/// - `A`: number of input values.\n/// - `BIT`: per-value bit bound; rounded up to `nibble_bits` by `packing_layout`.\n///\n/// ## Preconditions / Notes\n/// - Call with the raw coefficients whose magnitudes already satisfy the BIT bound\n///   (as enforced by the upstream range checks); `pack` performs the signed -> unsigned\n///   shift internally via `v + base`.\n/// - `group >= 1` is enforced by `packing_layout::<BIT>()`.\n/// - Padding with `digit = 2^nibble_bits` encodes `zero limb` consistently.\n///\n/// ## Returns\n/// - A `Vec<Field>` where each element is a concatenation of up to `group` limbs,\n///   suitable for hashing or transcript I/O.\npub fn pack<let A: u32, let BIT: u32>(values: [Field; A]) -> Vec<Field> {\n    // Layout parameters: nibble-aligned width and limbs-per-carrier group size.\n    let (nibble_bits, group) = packing_layout::<BIT>();\n\n    let base = 2.pow_32(nibble_bits as Field); // 2^nibble_bits\n    let radix = 2.pow_32((nibble_bits + 4) as Field); // 2^(nibble_bits + 4)\n\n    // Number of chunks to emit: ceil(A / group).\n    let num_chunks = (A + group - 1) / group;\n    let mut out = Vec::new();\n\n    // Process in fixed-size chunks of `group` limbs.\n    for chunk in 0..num_chunks {\n        // How many real values go into this chunk.\n        let remain = A - (chunk * group);\n        let take = if remain < group { remain } else { group };\n\n        // Build field element accumulator (big-endian concatenation in `radix`).\n        let mut acc = 0;\n        for i in 0..take {\n            let v = values[chunk * group + i];\n            acc = acc * radix + (v + base);\n        }\n\n        // Pad remaining limb slots with the canonical zero-limb `digit = base`.\n        for _ in 0..(group - take) {\n            acc = acc * radix + base;\n        }\n\n        out.push(acc);\n    }\n    out\n}\n\n/// Computes a cryptographic hash using the SAFE (Sponge API for Field Elements) protocol.\n///\n/// This is a convenience wrapper around the SAFE sponge API that handles the full\n/// lifecycle: initialization, absorption, squeezing, and finalization. It's designed\n/// for use in Fiat-Shamir challenge generation and commitment schemes within zero-knowledge circuits.\n///\n/// # Arguments\n/// * `domain_separator` - A 64-byte domain separator used to differentiate between\n///                        different protocol instances and prevent cross-protocol attacks.\n/// * `inputs` - Vector of field elements to be absorbed into the sponge.\n/// * `io_pattern` - A 2-element array encoding the I/O pattern:\n///                 - `io_pattern[0]`: Encoded ABSORB operation (MSB=1, lower 31 bits = length)\n///                 - `io_pattern[1]`: Encoded SQUEEZE operation (MSB=0, lower 31 bits = length)\n///\n/// # Returns\n/// A vector of field elements squeezed from the sponge, with length determined by\n/// the SQUEEZE operation in the IO pattern.\npub fn compute_safe(\n    domain_separator: [u8; 64],\n    inputs: Vec<Field>,\n    io_pattern: [u32; 2],\n) -> Vec<Field> {\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(inputs);\n    let digests = sponge.squeeze();\n    sponge.finish();\n\n    digests\n}\n\n#[test]\nfn test_flatten() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([1, 2, 3]); // degree 2\n    let poly2 = Polynomial::new([4, -16, 6]); // degree 2\n    let poly3 = Polynomial::new([-7, 8, 9]); // degree 2\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 4>(inputs, polynomials);\n\n    // Verify the flattened coefficients are in the correct positions\n    // Every value shifted 1 nibble incase of negative integers\n    assert(result.get(0) == 0x11121310101010101010101010101010101010101010101010101010101010);\n    assert(result.get(1) == 0x14001610101010101010101010101010101010101010101010101010101010); // -16 became 00 at  0x 14 00 16,\n    assert(result.get(2) == 0x09181910101010101010101010101010101010101010101010101010101010); // -7 became 09 at 0x 09 18 19(16 - 7 = 9)\n}\n\n#[test]\nfn test_flatten_big() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([\n        1791218451968394,\n        21888242871839275222246405745257275088548364400416034343698198265248580087864,\n        21888242871839275222246405745257275088548364400416034343698200542108324633466,\n        5430119342984413,\n        704811298945172,\n        8901715723925099,\n        21888242871839275222246405745257275088548364400416034343698203098124042812559,\n        21888242871839275222246405745257275088548364400416034343698200215091693880034,\n    ]);\n    let poly2 = Polynomial::new([\n        21888242871839275222246405745257275088548364400416034343698200314078269634250,\n        21888242871839275222246405745257275088548364400416034343698200967285641915872,\n        2909990636858607,\n        7896103832076587,\n        2078397209533893,\n        21888242871839275222246405745257275088548364400416034343698199792421452734531,\n        614400389245817,\n        8290314119277588,\n    ]);\n    let poly3 = Polynomial::new([\n        21888242871839275222246405745257275088548364400416034343698201373175279892906,\n        21888242871839275222246405745257275088548364400416034343698201087241869723721,\n        6768789983786188,\n        635797784303388,\n        7610153424227556,\n        4633893206538324,\n        2016269760615332,\n        21888242871839275222246405745257275088548364400416034343698201007080554428142,\n    ]);\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 54>(inputs, polynomials);\n\n    // Verify the flattened coefficients are in the correct positions\n    // Every value shifted 1 nibble incase of negative integers\n\n    // For the first index of result operation goes like this,\n\n    // First four index of poly1\n    // 1791218451968394,\n    // 21888242871839275222246405745257275088548364400416034343698198265248580087864,\n    // 21888242871839275222246405745257275088548364400416034343698200542108324633466,\n    // 5430119342984413,\n\n    // base + 1791218451968394 = 0x1065d1a8b8b718a\n    // base - 5921327228407753 = 0xeaf69591f3b037 (negative coefficient shifted)\n    // base - 3644467483862151 = 0xf30d604a3a9b79 (negative coefficient shifted)\n    // base + 5430119342984413 = 0x1134aaa2e86ccdd\n    assert(result.get(0) == 0x1065d1a8b8b718a0eaf69591f3b0370f30d604a3a9b791134aaa2e86ccdd);\n    assert(result.get(1) == 0x1028105ab1b789411fa010339db66b0fc220f1326bc8e0f1e3f4cc1e02e1);\n    assert(result.get(2) == 0x0f23dfbe7cd76c90f4901299312ddf10a569efe35acef11c0d76f005412b);\n    assert(result.get(3) == 0x107624a8f605dc50f0638a368960421022ecb3cf36b7911d73ff2c27ec14);\n    assert(result.get(4) == 0x0f6013a24e1b9a90f4fd2c158a08481180c2dba8af4cc10242413515171c);\n    assert(result.get(5) == 0x11b0964eb898ce411076805680b85410729c962da53a40f4b44412d0f6ed);\n}\n\n#[test]\nfn test_flatten_small() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([712345, 104857, 999999, 500001, 123, 654321, 77]);\n    let poly2 = Polynomial::new([1, 524287, 888888, 23456, 34567, 765432, 0]);\n    let poly3 = Polynomial::new([444444, 333333, 222222, 111111, 987654, 246810, 13579]);\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 20>(inputs, polynomials);\n\n    assert(result.get(0) == 0x1ade991199991f423f17a12110007b19fbf110004d100000100000100000);\n    assert(result.get(1) == 0x10000117ffff1d9038105ba01087071badf8100000100000100000100000);\n    assert(result.get(2) == 0x16c81c15161513640e11b2071f120613c41a10350b100000100000100000);\n}\n\n#[test]\nfn test_safe_hashing_with_safe_helper() {\n    // Verifies basic hash functionality with a simple ABSORB(3) + SQUEEZE(1) pattern.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice(&[1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let digests1 = compute_safe(domain_separator, elements, io_pattern);\n\n    assert(digests1.len() == 1);\n    assert(digests1.get(0) != 0);\n\n    // Test determinism\n    let digests2 = compute_safe(domain_separator, elements, io_pattern);\n\n    assert(digests2.len() == 1);\n    assert(digests2.get(0) != 0);\n    assert(digests2.get(0) == digests1.get(0));\n}\n\n#[test]\nfn test_pack() {\n    // Test pack function directly with small values\n    let values = [1, 2, 3, 4];\n    let packed = pack::<4, 4>(values);\n\n    // With BIT=4, nibble_bits=4, group should be floor(254/(4+4)) = 31\n    // So all 4 values should fit in one carrier\n    assert(packed.len() >= 1);\n\n    // Test with negative values\n    let values_neg = [-1, 2, -3, 4];\n    let packed_neg = pack::<4, 4>(values_neg);\n    assert(packed_neg.len() >= 1);\n}\n\n#[test]\nfn test_pack_single_value() {\n    // Test packing a single value\n    let values = [42];\n    let packed = pack::<1, 8>(values);\n    assert(packed.len() == 1);\n    assert(packed.get(0) != 0);\n}\n\n#[test]\nfn test_pack_determinism() {\n    // Test that packing is deterministic\n    let values = [10, 20, 30];\n    let packed1 = pack::<3, 8>(values);\n    let packed2 = pack::<3, 8>(values);\n\n    assert(packed1.len() == packed2.len());\n    for i in 0..packed1.len() {\n        assert(packed1.get(i) == packed2.get(i));\n    }\n}\n","path":"enclave/circuits/lib/src/math/helpers.nr"},"82":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse super::modulo::U128::ModU128;\n\n/// Polynomial structure representing a polynomial of degree N-1.\n///\n/// A polynomial P(X) = a_{N-1} * X^{N-1} + a_{N-2} * X^{N-2} + ... + a_1 * X + a_0\n/// is represented as an array of coefficients where coefficients[0] = a_{N-1} (highest degree)\n/// and coefficients[N-1] = a_0 (constant term).\npub struct Polynomial<let N: u32> {\n    /// Array of polynomial coefficients in descending degree order\n    /// coefficients[0] = coefficient of X^{N-1} (highest degree term)\n    /// coefficients[N-1] = constant term (degree 0)\n    pub coefficients: [Field; N],\n}\n\nimpl<let N: u32> Polynomial<N> {\n    /// Creates a new polynomial from an array of coefficients.\n    ///\n    /// # Arguments\n    /// * `coefficients` - Array of N coefficients in descending degree order\n    ///                    coefficients[0] = coefficient of X^{N-1}\n    ///                    coefficients[N-1] = constant term\n    ///\n    /// # Returns\n    /// A new Polynomial instance with the specified coefficients\n    pub fn new(coefficients: [Field; N]) -> Self {\n        Polynomial { coefficients }\n    }\n\n    /// Adds two polynomials.\n    ///\n    /// # Arguments\n    /// * `other` - The polynomial to add to the current polynomial.\n    ///\n    /// # Returns\n    /// A new polynomial with the coefficients added.\n    pub fn add(self, other: Self) -> Self {\n        let mut result = Self::new([0; N]);\n\n        for i in 0..N {\n            result.coefficients[i] = self.coefficients[i] + other.coefficients[i];\n        }\n\n        result\n    }\n\n    /// Subtracts two polynomials.\n    ///\n    /// # Arguments\n    /// * `other` - The polynomial to subtract from the current polynomial.\n    ///\n    /// # Returns\n    /// A new polynomial with the coefficients subtracted.\n    pub fn sub(self, other: Self) -> Self {\n        let mut result = Self::new([0; N]);\n\n        for i in 0..N {\n            result.coefficients[i] = self.coefficients[i] - other.coefficients[i];\n        }\n\n        result\n    }\n\n    /// Multiplies a polynomial by a scalar.\n    ///\n    /// # Arguments\n    /// * `scalar` - The scalar to multiply the polynomial by.\n    ///\n    /// # Returns\n    /// A new polynomial with the coefficients multiplied by the scalar.\n    pub fn mul_scalar(self, scalar: Field) -> Self {\n        let mut result = Self::new([0; N]);\n\n        for i in 0..N {\n            result.coefficients[i] = self.coefficients[i] * scalar;\n        }\n\n        result\n    }\n\n    /// Evaluates the polynomial at a given point using Horner's method.\n    ///\n    /// Horner's method computes P(x) = a_{N-1} * x^{N-1} + ... + a_1 * x + a_0\n    /// as ((...((a_{N-1} * x + a_{N-2}) * x + a_{N-3}) * x + ...) * x + a_0)\n    /// This approach require n multiplications and n additions to evaluate the polynomial.\n    ///\n    /// # Arguments\n    /// * `x` - The point at which to evaluate the polynomial.\n    ///\n    /// # Returns\n    /// The value of the polynomial at point x: P(x).\n    pub fn eval(self, x: Field) -> Field {\n        let mut result = self.coefficients[0];\n\n        for i in 1..self.coefficients.len() {\n            result = result * x + self.coefficients[i];\n        }\n\n        result\n    }\n\n    /// Evaluates the polynomial at a given point with modular reduction.\n    ///\n    /// This function computes `P(x) mod q` using Horner's method with intermediate\n    /// modular reductions to prevent overflow. The result is guaranteed to be in\n    /// the range `[0, q)`.\n    ///\n    /// The function performs modular reduction after each multiplication and addition\n    /// to ensure the accumulator always remains in the range `[0, q)`, preventing\n    /// any potential overflow issues.\n    ///\n    /// # Arguments\n    /// * `x` - The point at which to evaluate the polynomial\n    /// * `q` - The modular arithmetic context containing the modulus\n    ///\n    /// # Returns\n    /// The value `P(x) mod q` in the range `[0, q)`\n    pub fn eval_mod(self, x: Field, q: ModU128) -> Field {\n        let mut acc = self.coefficients[0];\n        let len = self.coefficients.len();\n\n        for i in 1..len {\n            acc = q.mul_mod(acc, x);\n            acc = q.add(acc, self.coefficients[i]);\n        }\n\n        acc\n    }\n\n    /// Performs range checking on polynomial coefficients using asymmetric bounds.\n    ///\n    /// This function constrains all polynomial coefficients to be in the range [-lower_bound, upper_bound],\n    /// where `lower_bound` is a non-negative magnitude.\n    /// It uses a shifting technique to handle negative numbers efficiently:\n    /// 1. Shifts each coefficient by adding `lower_bound`: c' = c + lower_bound\n    /// 2. Checks that shifted coefficients are in [0, upper_bound + lower_bound] using bit-size assertions\n    /// 3. This ensures original coefficients are in [-lower_bound, upper_bound]\n    ///\n    /// The function uses two bit-size checks per coefficient to ensure the value is within bounds:\n    /// - `shifted_coefficient.assert_max_bit_size::<BIT + 1>()` ensures c' >= 0\n    /// - `(range_size - shifted_coefficient).assert_max_bit_size::<BIT + 1>()` ensures c' <= range_size\n    ///\n    /// # Arguments\n    /// * `upper_bound` - The upper bound for coefficient range checking\n    /// * `lower_bound` - Non-negative magnitude of the negative bound\n    ///                   Coefficients must satisfy: -lower_bound <= c <= upper_bound\n    ///\n    /// # Generic Parameters\n    /// * `BIT` - The bit-length of the total range `upper_bound + lower_bound`\n    ///           (choose `BIT` so `upper_bound + lower_bound < 2^BIT`). Since all checked\n    ///           values lie in `[0, upper_bound + lower_bound]`, they cannot exceed `BIT + 1` bits.\n    ///\n    /// # Panics\n    /// This function will cause the circuit to fail if any coefficient is outside\n    /// the specified bounds.\n    pub fn range_check_2bounds<let BIT: u32>(self, upper_bound: Field, lower_bound: Field) {\n        let range_size = lower_bound + upper_bound;\n\n        for i in 0..self.coefficients.len() {\n            let shifted_coefficient = self.coefficients[i] + lower_bound;\n\n            shifted_coefficient.assert_max_bit_size::<BIT + 1>();\n            (range_size - shifted_coefficient).assert_max_bit_size::<BIT + 1>();\n        }\n    }\n\n    /// Performs range checking on polynomial coefficients for the range [0, upper_bound).\n    ///\n    /// This function constrains all polynomial coefficients to be non-negative and\n    /// strictly less than `upper_bound`. It uses bit-size assertions to verify that\n    /// coefficients are in the valid range.\n    ///\n    /// The function performs two checks per coefficient:\n    /// 1. `coeff.assert_max_bit_size::<BIT>()` ensures `coeff >= 0` and `coeff < 2^BIT`\n    /// 2. `(upper_bound - 1 - coeff).assert_max_bit_size::<BIT>()` ensures `coeff < upper_bound`\n    ///\n    /// # Arguments\n    /// * `upper_bound` - The exclusive upper bound for coefficient range checking.\n    ///                   Coefficients must satisfy: `0 <= c < upper_bound`\n    ///\n    /// # Generic Parameters\n    /// * `BIT` - The bit-length parameter. Must satisfy `upper_bound <= 2^BIT` for\n    ///           the range check to work correctly.\n    ///\n    /// # Panics\n    /// This function will cause the circuit to fail if any coefficient is outside\n    /// the range `[0, upper_bound)`.\n    pub fn range_check_standard<let BIT: u32>(self, upper_bound: Field) {\n        for i in 0..self.coefficients.len() {\n            let coeff = self.coefficients[i];\n            // Check coeff >= 0 and coeff < 2^BIT\n            coeff.assert_max_bit_size::<BIT>();\n            // Check coeff <= upper_bound - 1 (i.e., coeff < upper_bound)\n            (upper_bound - 1 - coeff).assert_max_bit_size::<BIT>();\n        }\n    }\n\n    /// Performs range checking on polynomial coefficients for the range [0, 2^BIT).\n    ///\n    /// This is a specialized range check for coefficients that must be non-negative\n    /// and less than a power of two. It's more efficient than `range_check_standard`\n    /// when the upper bound is exactly `2^BIT` because it only needs a single\n    /// bit-size assertion per coefficient.\n    ///\n    /// The function verifies that each coefficient satisfies:\n    /// - `coeff >= 0` (implicit from bit-size check)\n    /// - `coeff < 2^BIT` (enforced by `assert_max_bit_size::<BIT>()`)\n    ///\n    /// # Generic Parameters\n    /// * `BIT` - The bit-length parameter. Coefficients must satisfy: `0 <= c < 2^BIT`\n    ///\n    /// # Panics\n    /// This function will cause the circuit to fail if any coefficient is outside\n    /// the range `[0, 2^BIT)`.\n    pub fn range_check_power_of_two<let BIT: u32>(self) {\n        for i in 0..self.coefficients.len() {\n            self.coefficients[i].assert_max_bit_size::<BIT>();\n        }\n    }\n}\n\n#[test]\nfn test_polynomial_eval() {\n    let coeffs = [1, 2, 3]; // represents 1x^2 + 2x + 3\n    let poly = Polynomial::new(coeffs);\n\n    let x = 2; // evaluate at x = 2\n    let result = poly.eval(x);\n\n    // (1 * 2^2) + (2 * 2) + 3 = 4 + 4 + 3 = 11\n    assert(result == 11);\n}\n\n#[test]\nfn test_polynomial_eval_zero() {\n    let coeffs = [1, -2, 1]; // x^2 - 2x + 1 = (x-1)^2\n    let poly = Polynomial::new(coeffs);\n\n    let x = 1; // evaluate at x = 1, should be 0\n    let result = poly.eval(x);\n\n    assert(result == 0);\n}\n\n#[test]\nfn test_polynomial_bounds() {\n    let coeffs = [-16, 240, 242];\n    let poly = Polynomial::new(coeffs);\n\n    // Test double bounds check - constrains to [-240, 242]\n    poly.range_check_2bounds::<8>(242, 240);\n}\n\n#[test(should_fail_with = \"assert_max_bit_size\")]\nfn test_polynomial_out_of_bounds_coefficients() {\n    let coeffs = [-100];\n    let poly = Polynomial::new(coeffs);\n\n    // Test double bounds check - constrains to [-98, 99]\n    // Should fail because -100 is out of bounds.\n    poly.range_check_2bounds::<7>(99, 98);\n}\n\n#[test]\nfn test_polynomial_add() {\n    let coeffs1 = [1, 2, 3]; // 1x^2 + 2x + 3\n    let coeffs2 = [4, 5, 6]; // 4x^2 + 5x + 6\n    let poly1 = Polynomial::new(coeffs1);\n    let poly2 = Polynomial::new(coeffs2);\n\n    let result = poly1.add(poly2);\n\n    // Expected: (1+4)x^2 + (2+5)x + (3+6) = 5x^2 + 7x + 9\n    assert(result.coefficients[0] == 5);\n    assert(result.coefficients[1] == 7);\n    assert(result.coefficients[2] == 9);\n}\n\n#[test]\nfn test_polynomial_sub() {\n    let coeffs1 = [5, 7, 9]; // 5x^2 + 7x + 9\n    let coeffs2 = [1, 2, 3]; // 1x^2 + 2x + 3\n    let poly1 = Polynomial::new(coeffs1);\n    let poly2 = Polynomial::new(coeffs2);\n\n    let result = poly1.sub(poly2);\n\n    // Expected: (5-1)x^2 + (7-2)x + (9-3) = 4x^2 + 5x + 6\n    assert(result.coefficients[0] == 4);\n    assert(result.coefficients[1] == 5);\n    assert(result.coefficients[2] == 6);\n}\n\n#[test]\nfn test_polynomial_mul_scalar() {\n    let coeffs = [1, 2, 3]; // 1x^2 + 2x + 3\n    let poly = Polynomial::new(coeffs);\n    let scalar = 5;\n\n    let result = poly.mul_scalar(scalar);\n\n    // Expected: 5x^2 + 10x + 15\n    assert(result.coefficients[0] == 5);\n    assert(result.coefficients[1] == 10);\n    assert(result.coefficients[2] == 15);\n}\n\n#[test]\nfn test_polynomial_mul_scalar_zero() {\n    let coeffs = [1, 2, 3];\n    let poly = Polynomial::new(coeffs);\n    let scalar = 0;\n\n    let result = poly.mul_scalar(scalar);\n\n    // Expected: 0x^2 + 0x + 0 = 0\n    assert(result.coefficients[0] == 0);\n    assert(result.coefficients[1] == 0);\n    assert(result.coefficients[2] == 0);\n}\n\n#[test]\nfn test_eval_mod_simple() {\n    // Test without initial reduction - simple case\n    // p(x) = x + 1 at x=5od 7\n    // Expected: (5 + 1) mod 7 = 6\n    let q = ModU128::new(7);\n\n    let poly1 = Polynomial::new([1, 1]);\n    let result1 = poly1.eval_mod(5, q);\n    assert(result1 == 6);\n\n    // Test: p(x) = 2x + 3 at x=5od 7\n    // Expected: (10 + 3) mod 7 = 13 mod 7 = 6\n    let poly2 = Polynomial::new([2, 3]);\n    let result2 = poly2.eval_mod(5, q);\n    assert(result2 == 6);\n}\n\n#[test]\nfn test_eval_mod_degree_2() {\n    // p(x) = x^2 + 2x + 3 at x=5od 7\n    // Using Horner's method: ((1)*5 + 2)*5 + 3 = (5+2)*5 + 3 = 7*5 + 3 = 35 + 3 = 38\n    // 38 mod 7 = 3 (since 38 = 5*7 + 3)\n    let q = ModU128::new(7);\n\n    let poly = Polynomial::new([1, 2, 3]);\n    let result = poly.eval_mod(5, q);\n    assert(result == 3);\n}\n\n#[test]\nfn test_eval_mod() {\n    // Test 1: Simple polynomial x^2 + 2x + 3 at x=5od 7\n    // Expected: (25 + 10 + 3) mod 7 = 38 mod 7 = 3\n    let q = ModU128::new(7);\n\n    let poly1 = Polynomial::new([1, 2, 3]);\n    let result1 = poly1.eval_mod(5, q);\n    assert(result1 == 3);\n\n    // Test 2: Higher degree polynomialod small prime\n    // p(x) = x^3 + x^2 + x + 1 at x=2od 11\n    // Expected: (8 + 4 + 2 + 1) mod 11 = 15 mod 11 = 4\n    let q = ModU128::new(11);\n\n    let poly2 = Polynomial::new([1, 1, 1, 1]);\n    let result2 = poly2.eval_mod(2, q);\n    assert(result2 == 4);\n\n    // Test 3: Polynomial with larger coefficients\n    // p(x) = 100x^2 + 50x + 25 at x=10od 73\n    // Expected: (10000 + 500 + 25) mod 73 = 10525 mod 73 = 13\n    let q = ModU128::new(73);\n\n    let poly3 = Polynomial::new([100, 50, 25]);\n    let result3 = poly3.eval_mod(10, q);\n    assert(result3 == 13);\n\n    // Test 4: Result should be less than modulus\n    let poly4 = Polynomial::new([5, 3, 7]);\n    let q = ModU128::new(17);\n    let result4 = poly4.eval_mod(4, q);\n    assert(result4 as u128 < q.get_mod_field() as u128);\n\n    // Test 5: Compare with regular eval for small values\n    let poly5 = Polynomial::new([1, 2, 1]);\n    let x = 3;\n    let q = ModU128::new(1000);\n    let result5 = poly5.eval_mod(x, q);\n    let expected5 = poly5.eval(x);\n    assert(result5 == expected5);\n\n    // Test 6: Zero polynomial\n    let poly6 = Polynomial::new([0, 0, 0]);\n    let q = ModU128::new(13);\n    let result6 = poly6.eval_mod(100, q);\n    assert(result6 == 0);\n}\n\n#[test]\nfn test_large_party_ids_scenario() {\n    // Simulating party IDs in range [1, 100]\n    let party_id_1 = 42;\n    let party_id_2 = 73;\n    let m = ModU128::new(288230376151711717); // ~58 bits\n\n    // Operations that would be used in Lagrange coefficients\n    let product = m.mul_mod(party_id_1, party_id_2);\n    let diff = m.sub(party_id_2, party_id_1);\n\n    assert(product == 3066);\n    assert(diff == 31);\n}\n\n#[test]\nfn test_eval_vs_eval_mod() {\n    // Compare eval and eval_mod for small values where no reduction should occur\n    let poly = Polynomial::new([1, 2, 3]);\n    let x = 2;\n    let q = ModU128::new(1000); // Large enough that no reduction happens\n\n    let result_normal = poly.eval(x);\n    let result_mod = poly.eval_mod(x, q);\n\n    // They should be equal: (1)*2 + 2)*2 + 3 = (2+2)*2 + 3 = 4*2 + 3 = 11\n    assert(result_normal == 11);\n    assert(result_mod == 11);\n}\n\n#[test]\nfn test_eval_mod_step_by_step() {\n    // p(x) = x + 1 at x=5od 7\n    // Step by step: acc = 1, then acc = 1*5 + 1 = 6\n    let poly = Polynomial::new([1, 1]);\n\n    // Manually compute\n    let mut acc = 1; // coefficients[0]\n    acc = acc * 5 + 1; // = 6\n    assert(acc == 6);\n\n    // Now with reduce_mod\n    let m = ModU128::new(7);\n    let reduced = m.reduce_mod(acc);\n    assert(reduced == 6);\n\n    // Now test the actual function\n    let result = poly.eval_mod(5, m);\n    assert(result == 6);\n}\n","path":"enclave/circuits/lib/src/math/polynomial.nr"},"83":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse keccak256::keccak256;\nuse poseidon::poseidon2_permutation;\n\n/// SAFE (Sponge API for Field Elements)\n///\n/// This module provides a complete implementation of the SAFE API in Noir as defined in:\n/// \"SAFE (Sponge API for Field Elements) - A Toolbox for ZK Hash Applications\"\n/// see https://hackmd.io/bHgsH6mMStCVibM_wYvb2w#22-Sponge-state for more details.\n///\n/// SAFE provides a unified interface for cryptographic sponge functions that can be\n/// instantiated with various permutations to create hash functions, MACs, authenticated\n/// encryption schemes, and other cryptographic primitives for ZK proof systems.\n///\n/// This implementation follows the SAFE specification exactly, providing:\n/// - Complete API: START, ABSORB, SQUEEZE, FINISH operations.\n/// - Full security: Domain separation, tag computation, IO pattern validation.\n/// - Poseidon2 integration: Field-friendly permutation for ZK systems.\n/// - Specification compliance: All operations follow SAFE spec 2.4 exactly.\n/// - Natural API design: Variable-length inputs, automatic length detection from IO patterns.\n///\n/// # API Design\n///\n/// The API is designed for natural usage while maintaining type safety:\n/// - `absorb(input: [Field])`: Accepts variable-length arrays, no padding required.\n/// - `squeeze()`: Returns a vector with field element(s).\n/// - IO patterns automatically determine operation lengths for validation.\n\n/// Rate parameter for the sponge construction (number of field elements that can be absorbed per permutation call).\nglobal RATE: u32 = 3;\n\n/// Capacity parameter for the sponge construction (security parameter, typically 1-2 field elements).\nglobal CAPACITY: u32 = 1;\n\n/// Total state size (rate + capacity) in field elements.\nglobal STATE_SIZE: u32 = RATE + CAPACITY;\n\n/// IO Pattern encoding constants (from SAFE spec 2.3).\n///\n/// These constants are used for encoding operation types in the 32-bit word format:\n/// - MSB set to 1 for ABSORB operations\n/// - MSB set to 0 for SQUEEZE operations\n\n/// Flag for ABSORB operations (MSB = 1)\nglobal ABSORB_FLAG: u32 = 0x80000000;\n\n/// Flag for SQUEEZE operations (MSB = 0)\nglobal SQUEEZE_FLAG: u32 = 0x00000000;\n\n/// SAFE Sponge State (following spec 2.2)\n///\n/// The sponge state consists of the permutation state, tag, position counters,\n/// and IO pattern tracking as defined in the SAFE specification.\n///\n/// # Generic Parameters\n/// - `L`: The length of the IO pattern array\n///\n/// # Fields\n/// - `state`: Permutation state V in F^n (rate + capacity elements)\n/// - `tag`: Parameter tag T used for instance differentiation\n/// - `absorb_pos`: Current absorb position (<= n-c)\n/// - `squeeze_pos`: Current squeeze position (<= n-c)\n/// - `io_pattern`: Expected IO pattern for validation (encoded 32-bit words)\n/// - `io_count`: Current operation count for pattern tracking\npub struct SafeSponge<let L: u32> {\n    /// Permutation state V in F^n (rate + capacity elements).\n    state: [Field; STATE_SIZE],\n    /// Parameter tag T used for instance differentiation.\n    tag: Field,\n    /// Current absorb position (<= n-c).\n    absorb_pos: u32,\n    /// Current squeeze position (<= n-c).\n    squeeze_pos: u32,\n    /// Expected IO pattern for validation.\n    io_pattern: [u32; L],\n    /// Current operation count for pattern tracking (spec 2.4: io_count).\n    io_count: u32,\n}\n\nimpl<let L: u32> SafeSponge<L> {\n    /// Initializes a new SAFE sponge instance with the given IO pattern and domain separator (following spec 2.4).\n    ///\n    /// # Arguments\n    /// - `io_pattern`: Array of 32-bit encoded operations defining the expected sequence of ABSORB/SQUEEZE calls.\n    ///               Each word has MSB=1 for ABSORB operations, MSB=0 for SQUEEZE operations.\n    /// - `domain_separator`: 64-byte domain separator for cross-protocol security.\n    ///\n    /// # Returns\n    /// A new `SafeSponge` instance with initialized state\n    pub fn start(io_pattern: [u32; L], domain_separator: [u8; 64]) -> SafeSponge<L> {\n        // Compute tag from IO pattern and domain separator (spec 2.3).\n        let tag = compute_tag(io_pattern, domain_separator);\n\n        let mut state = [0; STATE_SIZE];\n        // Initialize capacity with tag (spec 2.4).\n        // Add T to the first 128 bits of the state.\n        state[0] = tag;\n\n        SafeSponge { state, tag, absorb_pos: 0, squeeze_pos: 0, io_pattern, io_count: 0 }\n    }\n\n    /// Absorbs field elements into the sponge state, interleaving permutation calls as needed (following spec 2.4).\n    ///\n    /// The number of elements to absorb is automatically validated against the IO pattern.\n    /// This method accepts variable-length arrays, making it natural to use without padding.\n    ///\n    /// # Arguments\n    /// - `input`: Array of field elements to absorb (variable length, must match IO pattern)\n    pub fn absorb(&mut self, input: Vec<Field>) {\n        let length = input.len() as u32;\n\n        // Validate against IO pattern.\n        assert(self.io_count < L);\n\n        // Parse expected operation from io_pattern (encoded word)\n        let expected_encoded_word = self.io_pattern[self.io_count];\n        let is_expected_absorb = (expected_encoded_word & ABSORB_FLAG) != 0;\n        let expected_length = expected_encoded_word & 0x7FFFFFFF;\n\n        // Validate operation type and length\n        assert(is_expected_absorb, \"Expected ABSORB operation\");\n        assert(expected_length == length, \"Length mismatch\");\n\n        // Process each element naturally (no unnecessary iterations).\n        for i in 0..length {\n            // If absorb_pos == (n-c) then permute and reset (spec 2.4).\n            if self.absorb_pos == RATE {\n                // n-c = RATE.\n                self.state = self.permute();\n                self.absorb_pos = 0;\n            }\n\n            // Add X[i] to state at absorb_pos (spec 2.4).\n            // Note: absorb_pos is the rate position, not capacity position.\n            self.state[self.absorb_pos + CAPACITY] =\n                self.state[self.absorb_pos + CAPACITY] + input.get(i);\n            self.absorb_pos += 1;\n        }\n\n        // Verify that the encoded word matches the expected pattern.\n        let encoded_word = ABSORB_FLAG | length;\n        assert(encoded_word == expected_encoded_word);\n\n        self.io_count += 1;\n\n        // Force permute at start of next SQUEEZE (spec 2.4).\n        self.squeeze_pos = RATE;\n    }\n\n    /// Extracts field elements from the sponge state, interleaving permutation calls as needed (following spec 2.4).\n    ///\n    /// The number of elements to squeeze is automatically determined from the IO pattern.\n    pub fn squeeze(&mut self) -> Vec<Field> {\n        // Validate against IO pattern.\n        assert(self.io_count < L);\n\n        // Parse expected operation from io_pattern (encoded word)\n        let expected_encoded_word = self.io_pattern[self.io_count];\n        let is_expected_squeeze = (expected_encoded_word & ABSORB_FLAG) == 0;\n        let length = expected_encoded_word & 0x7FFFFFFF;\n\n        // Validate operation type\n        assert(is_expected_squeeze, \"Expected SQUEEZE operation\");\n\n        let mut output = Vec::new();\n\n        // SQUEEZE implementation following spec 2.4.\n        // If length==0, loop won't execute (spec 2.4).\n        for _ in 0..length {\n            // If squeeze_pos==(n-c) then permute and reset (spec 2.4).\n            if self.squeeze_pos == RATE {\n                // n-c = RATE.\n                self.state = self.permute();\n                self.squeeze_pos = 0;\n                self.absorb_pos = 0;\n            }\n            // Set Y[i] to state element at squeeze_pos (spec 2.4).\n            output.push(self.state[self.squeeze_pos + CAPACITY]);\n            self.squeeze_pos += 1;\n        }\n\n        // Verify that the encoded word matches the expected pattern.\n        let encoded_word = SQUEEZE_FLAG | length;\n        assert(encoded_word == expected_encoded_word);\n\n        self.io_count += 1;\n        output\n    }\n\n    /// Finalizes the sponge instance, verifying that all expected operations have been performed and clearing the internal state for security (following spec 2.4).\n    ///\n    /// This function is used to ensure that the sponge instance has been used correctly and to prevent information leakage.\n    pub fn finish(&mut self) {\n        // Check that io_count equals the length of the IO pattern expected (spec 2.4).\n        assert(self.io_count == L, \"IO pattern not completed\");\n\n        // Erase the state and its variables (spec 2.4).\n        self.state = [0; STATE_SIZE];\n        self.absorb_pos = 0;\n        self.squeeze_pos = 0;\n        self.io_count = 0;\n    }\n\n    /// Permute the state using Poseidon2 (following spec 2.4).\n    ///\n    /// Applies the Poseidon2 permutation to the current state.\n    /// This is the core cryptographic primitive of the sponge construction.\n    ///\n    /// # Returns\n    /// New state after permutation\n    fn permute(self) -> [Field; STATE_SIZE] {\n        poseidon2_permutation(self.state, STATE_SIZE)\n    }\n}\n\n/// Computes a unique tag for a sponge instance based on its IO pattern and domain separator.\n/// The tag is used to ensure that distinct instances behave like distinct functions.\n///\n/// # Arguments\n/// - `io_pattern`: Array of 32-bit encoded operations defining the sponge's usage pattern.\n///               Each word has MSB=1 for ABSORB operations, MSB=0 for SQUEEZE operations.\n/// - `domain_separator`: 64-byte domain separator for cross-protocol security.\n///\n/// # Returns\n/// A field element representing the 128-bit tag.\npub fn compute_tag<let L: u32>(io_pattern: [u32; L], domain_separator: [u8; 64]) -> Field {\n    // Step 1: Parse and aggregate consecutive operations of the same type\n    let mut encoded_words = [0; L]; // Support up to L operations.\n    let mut word_count = 0;\n    let mut current_absorb_sum = 0;\n    let mut current_squeeze_sum = 0;\n    let mut last_was_absorb = false;\n\n    for i in 0..L {\n        if io_pattern[i] > 0 {\n            // Parse operation type from MSB and length from lower 31 bits\n            let is_absorb = (io_pattern[i] & ABSORB_FLAG) != 0;\n            let length = io_pattern[i] & 0x7FFFFFFF; // Clear MSB to get length\n\n            if is_absorb {\n                if last_was_absorb {\n                    // Aggregate consecutive ABSORB operations\n                    current_absorb_sum += length;\n                } else {\n                    // Start new ABSORB sequence\n                    if current_squeeze_sum > 0 {\n                        // Flush previous SQUEEZE sequence\n                        encoded_words[word_count] = SQUEEZE_FLAG | current_squeeze_sum;\n                        word_count += 1;\n                        current_squeeze_sum = 0;\n                    }\n                    current_absorb_sum = length;\n                }\n                last_was_absorb = true;\n            } else {\n                if !last_was_absorb {\n                    // Aggregate consecutive SQUEEZE operations\n                    current_squeeze_sum += length;\n                } else {\n                    // Start new SQUEEZE sequence\n                    if current_absorb_sum > 0 {\n                        // Flush previous ABSORB sequence\n                        encoded_words[word_count] = ABSORB_FLAG | current_absorb_sum;\n                        word_count += 1;\n                        current_absorb_sum = 0;\n                    }\n                    current_squeeze_sum = length;\n                }\n                last_was_absorb = false;\n            }\n        }\n    }\n\n    // Flush remaining operations\n    if current_absorb_sum > 0 {\n        encoded_words[word_count] = ABSORB_FLAG | current_absorb_sum;\n        word_count += 1;\n    }\n    if current_squeeze_sum > 0 {\n        encoded_words[word_count] = SQUEEZE_FLAG | current_squeeze_sum;\n        word_count += 1;\n    }\n\n    // Step 2: Serialize to byte string and append domain separator (following SAFE spec 2.3).\n    // Buffer is 256 bytes: max 192 bytes for IO pattern (48 words) + 64 bytes for domain separator.\n    // Note: We must use a fixed-size array because Noir's keccak256 requires [u8; N], not Vec<u8>.\n    let max_io_pattern_bytes: u32 = 192; // 256 - 64 (domain separator)\n    let io_pattern_bytes = word_count * 4;\n    assert(\n        io_pattern_bytes <= max_io_pattern_bytes,\n        \"IO pattern too large: max 48 aggregated words supported\",\n    );\n\n    let mut input_bytes = [0u8; 256];\n    let mut byte_count: u32 = 0;\n\n    // Serialize encoded words to bytes (big-endian as per SAFE spec).\n    // Note: Noir requires compile-time loop bounds, so we iterate over L (the array size)\n    // instead of word_count (runtime value). The condition `i < word_count` ensures we only\n    // process valid encoded words. This is safe because word_count <= L always holds\n    // (we can have at most L encoded words from L input operations).\n    for i in 0..L {\n        if i < word_count {\n            let word = encoded_words[i];\n            input_bytes[byte_count] = (word >> 24) as u8;\n            input_bytes[byte_count + 1] = (word >> 16) as u8;\n            input_bytes[byte_count + 2] = (word >> 8) as u8;\n            input_bytes[byte_count + 3] = word as u8;\n            byte_count += 4;\n        }\n    }\n\n    // Append full 64-byte domain separator.\n    for i in 0..64 {\n        input_bytes[byte_count] = domain_separator[i];\n        byte_count += 1;\n    }\n\n    // Step 3: Hash with Keccak-256 and truncate to 128 bits.\n    // Note: The SAFE spec uses SHA3-256, but we use Keccak-256 for Noir compatibility.\n    // Keccak-256 differs from SHA3-256 in padding, but both provide equivalent security.\n    let hash_bytes = keccak256(input_bytes, byte_count);\n\n    // Convert first 128 bits (16 bytes) to field element.\n    let mut tag_value: Field = 0;\n    for i in 0..16 {\n        tag_value = tag_value * 256 + (hash_bytes[i] as Field);\n    }\n\n    tag_value\n}\n\n#[test]\nfn test_safe_hashing() {\n    // Verifies basic hash functionality with a simple ABSORB(3) + SQUEEZE(1) pattern.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice(&[1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(elements);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(elements);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_merkle_node() {\n    // Verifies SAFE can be used for Merkle tree node hashing with pattern ABSORB(1) + ABSORB(1) + SQUEEZE(1).\n    // Tests the ability to absorb multiple inputs before squeezing output.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let left = Vec::from_slice([123]);\n    let right = Vec::from_slice([456]);\n\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(left);\n    sponge.absorb(right);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(left);\n    sponge2.absorb(right);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_commitment_scheme() {\n    // Verifies SAFE can be used for commitment schemes with pattern ABSORB(3) + SQUEEZE(1).\n    // Tests the ability to create deterministic commitments from multiple field elements.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let values = Vec::from_slice([10, 20, 30]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(values);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(values);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_domain_separation() {\n    // Verifies that different domain separators produce different outputs for the same input.\n    // This is crucial for cross-protocol security and preventing collisions between different applications.\n    let elements = Vec::from_slice([1, 2, 3]);\n    let domain1 = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let domain2 = [\n        0x41, 0x42, 0x43, 0x45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n\n    let mut sponge1 = SafeSponge::start(io_pattern, domain1);\n    sponge1.absorb(elements);\n    let output1 = sponge1.squeeze();\n    sponge1.finish();\n\n    let mut sponge2 = SafeSponge::start(io_pattern, domain2);\n    sponge2.absorb(elements);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output1.len() == 1);\n    assert(output2.len() == 1);\n    assert(output1.get(0) != output2.get(0)); // Different domain separators should produce different outputs\n}\n\n#[test]\nfn test_multiple_squeeze() {\n    // Verifies that multiple field elements can be squeezed in a single operation.\n    // Tests pattern ABSORB(3) + SQUEEZE(2) to ensure proper state management.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice([1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(2)\n    let io_pattern = [0x80000003, 0x00000002];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(elements);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 2);\n    assert(output.get(0) != 0);\n    assert(output.get(1) != 0);\n    assert(output.get(0) != output.get(1)); // Different squeeze outputs should be different\n}\n\n#[test]\nfn test_zero_length_operations() {\n    // Verifies that zero-length ABSORB and SQUEEZE operations are handled correctly.\n    // Tests pattern ABSORB(0) + SQUEEZE(1) to ensure proper state transitions.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Pattern: ABSORB(0), SQUEEZE(1)\n    let io_pattern = [0x80000000, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(Vec::new());\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n}\n\n#[test]\nfn test_tag_computation() {\n    // Verifies the tag computation algorithm using the example from the SAFE specification.\n    // Pattern: ABSORB(3), ABSORB(3), SQUEEZE(3)\n    // Should aggregate to: ABSORB(6), SQUEEZE(3)\n    // Encoded as: [0x80000006, 0x00000003]\n    // Tests determinism and pattern differentiation.\n\n    let io_pattern = [0x80000003, 0x80000003, 0x00000003];\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test determinism\n    let tag2 = compute_tag(io_pattern, domain_separator);\n    assert(tag == tag2);\n\n    // Test that different patterns produce different tags\n    let io_pattern2 = [0x80000003, 0x00000003]; // ABSORB(3), SQUEEZE(3) - different pattern\n    let tag3 = compute_tag(io_pattern2, domain_separator);\n    assert(tag != tag3);\n}\n\n#[test]\nfn test_tag_computation_debug() {\n    println(\"=== SAFE Tag Computation Debug Test ===\");\n\n    // Test your specific pattern [2, 2, 2] (ABSORB(2), SQUEEZE(2), ABSORB(2))\n    let io_pattern = [0x80000002, 0x00000002, 0x80000002];\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    println(f\"Testing pattern: {io_pattern}\");\n    println(\n        f\"Expected to aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(2)\",\n    );\n    println(\n        f\"Expected encoded words: [0x80000002, 0x00000002, 0x80000002]\",\n    );\n    println(\"\");\n\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    println(f\"=== Expected Rust Output ===\");\n    println(\"Pattern [2, 2, 2] (ABSORB(2), SQUEEZE(2), ABSORB(2))\");\n    println(\"Domain separator: 0x41424344...\");\n    println(\"Tag: 0xce3bb9ee4b2d41c42e9cdda38afe8b6a\");\n    println(\"\");\n\n    println(f\"=== Noir Output ===\");\n    println(f\"Tag: {tag}\");\n    println(\"\");\n\n    println(\"Compare the tag values above with Rust script!\");\n}\n\n#[test]\nfn test_consecutive_absorb_aggregation() {\n    // Test that consecutive ABSORB operations are properly aggregated\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1) should aggregate to ABSORB(2), SQUEEZE(1)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), ABSORB(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001];\n\n    // This should aggregate to: ABSORB(2), SQUEEZE(1) = [0x80000002, 0x00000001]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag ABSORB(2), SQUEEZE(1)\n    let aggregated_pattern = [0x80000002, 0x00000001];\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(tag == aggregated_tag, \"Consecutive ABSORB operations should aggregate to the same tag\");\n\n    // Test that a different pattern produces a different tag\n    let different_pattern = [0x80000001, 0x00000001, 0x80000001]; // ABSORB(1), SQUEEZE(1), ABSORB(1)\n    let different_tag = compute_tag(different_pattern, domain_separator);\n\n    // This should be different because it doesn't have consecutive ABSORB operations\n    assert(tag != different_tag, \"Different patterns should produce different tags\");\n\n    println(\"=== Consecutive ABSORB Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x80000001, 0x00000001] (ABSORB(1), ABSORB(1), SQUEEZE(1))\",\n    );\n    println(\n        f\"Aggregated pattern: [0x80000002, 0x00000001] (ABSORB(2), SQUEEZE(1))\",\n    );\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Different pattern tag: {different_tag}\");\n}\n\n#[test]\nfn test_consecutive_squeeze_aggregation() {\n    // Test that consecutive SQUEEZE operations are properly aggregated\n    // Pattern: ABSORB(1), SQUEEZE(1), SQUEEZE(1) should aggregate to ABSORB(1), SQUEEZE(2)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), SQUEEZE(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x00000001, 0x00000001];\n\n    // This should aggregate to: ABSORB(1), SQUEEZE(2) = [0x80000001, 0x00000002]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag ABSORB(1), SQUEEZE(2)\n    let aggregated_pattern = [0x80000001, 0x00000002];\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(\n        tag == aggregated_tag,\n        \"Consecutive SQUEEZE operations should aggregate to the same tag\",\n    );\n\n    // Test that a different pattern produces a different tag\n    let different_pattern = [0x80000001, 0x00000001, 0x80000001]; // ABSORB(1), SQUEEZE(1), ABSORB(1)\n    let different_tag = compute_tag(different_pattern, domain_separator);\n\n    // This should be different because it doesn't have consecutive SQUEEZE operations\n    assert(tag != different_tag, \"Different patterns should produce different tags\");\n\n    println(\"=== Consecutive SQUEEZE Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x00000001, 0x00000001] (ABSORB(1), SQUEEZE(1), SQUEEZE(1))\",\n    );\n    println(\n        f\"Aggregated pattern: [0x80000001, 0x00000002] (ABSORB(1), SQUEEZE(2))\",\n    );\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Different pattern tag: {different_tag}\");\n}\n\n#[test]\nfn test_mixed_consecutive_aggregation() {\n    // Test that both consecutive ABSORB and SQUEEZE operations are properly aggregated\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1)\n    // Should aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(1)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001, 0x00000001, 0x80000001];\n\n    // This should aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(1) = [0x80000002, 0x00000002, 0x80000001]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag\n    let aggregated_pattern = [0x80000002, 0x00000002, 0x80000001]; // ABSORB(2), SQUEEZE(2), ABSORB(1)\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(tag == aggregated_tag, \"Mixed consecutive operations should aggregate to the same tag\");\n\n    println(\"=== Mixed Consecutive Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x80000001, 0x00000001, 0x00000001, 0x80000001]\",\n    );\n    println(\n        f\"  (ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1))\",\n    );\n    println(f\"Aggregated pattern: [0x80000002, 0x00000002, 0x80000001]\");\n    println(f\"  (ABSORB(2), SQUEEZE(2), ABSORB(1))\");\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n}\n\n#[test]\nfn test_large_io_pattern() {\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Create pattern with 48 alternating ABSORB(1) and SQUEEZE(1) operations\n    // This is the maximum supported (48 words * 4 bytes = 192 bytes, leaving 64 for domain separator)\n    let mut io_pattern = [0u32; 48];\n    for i in 0..48 {\n        if i % 2 == 0 {\n            io_pattern[i] = ABSORB_FLAG | 1; // ABSORB(1)\n        } else {\n            io_pattern[i] = SQUEEZE_FLAG | 1; // SQUEEZE(1)\n        }\n    }\n\n    let tag = compute_tag(io_pattern, domain_separator);\n    assert(tag != 0);\n}\n\n#[test]\nfn test_domain_separator_not_truncated() {\n    // This test verifies that the domain separator is always included in the tag computation,\n    // even for large IO patterns. If the domain separator were truncated, different domain\n    // separators would produce the same tag for large patterns.\n\n    let domain_separator_a = [\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41,\n    ]; // All 'A's\n\n    let domain_separator_b = [\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42,\n    ]; // All 'B's\n\n    // Create pattern with 48 alternating operations (max supported: 192 bytes of IO pattern)\n    let mut io_pattern = [0u32; 48];\n    for i in 0..48 {\n        if i % 2 == 0 {\n            io_pattern[i] = ABSORB_FLAG | 1;\n        } else {\n            io_pattern[i] = SQUEEZE_FLAG | 1;\n        }\n    }\n\n    let tag_a = compute_tag(io_pattern, domain_separator_a);\n    let tag_b = compute_tag(io_pattern, domain_separator_b);\n\n    // Tags MUST be different because domain separators are different.\n    // If they were the same, it would mean the domain separator was truncated/ignored.\n    assert(tag_a != tag_b, \"Domain separator must affect tag even for large IO patterns\");\n}\n","path":"enclave/circuits/lib/src/math/safe.nr"}},"expression_width":{"Bounded":{"width":4}}}