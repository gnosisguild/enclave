{"noir_version":"1.0.0-beta.16+2d46fca7203545cbbfb31a0d0328de6c10a8db95","hash":"3947003804253803439","abi":{"parameters":[{"name":"expected_sk_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"expected_e_sm_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"ct0","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":512,"type":{"kind":"field"}}}]}},"visibility":"public"},{"name":"ct1","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":512,"type":{"kind":"field"}}}]}},"visibility":"public"},{"name":"sk","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":512,"type":{"kind":"field"}}}]}},"visibility":"private"},{"name":"e_sm","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":512,"type":{"kind":"field"}}}]}},"visibility":"private"},{"name":"r1","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":1023,"type":{"kind":"field"}}}]}},"visibility":"private"},{"name":"r2","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":511,"type":{"kind":"field"}}}]}},"visibility":"private"},{"name":"d","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":512,"type":{"kind":"field"}}}]}},"visibility":"private"}],"return_type":null,"error_types":{"790736725912586495":{"error_kind":"string","string":"Decryption share computation failed"},"7023503018538476324":{"error_kind":"string","string":"S commitment mismatch"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"13823868475309396004":{"error_kind":"string","string":"E commitment mismatch"}}},"bytecode":"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","debug_symbols":"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/7w6v2/w9w/+/Q9Zv3+I7/jx+4d8H853e/39Q70P9/1Svw/z+UvfN/j7B/v8pe8b/P1DvF/K9+G8X6r34b5f6vdhPn/p+wZ//2Cfv/R9g79/eF9zv6+539fc72vu9zX3+5r7fc3zvuZ5X/O8r3ne1zzva573Nc/7mud9zfO+5vn8ms/Hx/vw+TWfD38f4v1Svg/n/VK9D/f9Ur8Pn1/zsY/34fNrPubvQ7xfyvfhvF+q9+G+X+r34X3N/r5mf1+zv6/Z39fs72v29zX7+5r9fc3+vmZ/X3O8rzne1xzva473Ncf7muN9zfG+5nhfc7yvOd7XnO9rzvc15/ua833N+b7mfF9zvq8539ec72vO9zWf9zWf9zWf9zWf9zWf9zWf9zWf9zWf9zWf9zWf9zXX+5rrfc31vua3wfM2eN4Gz9vgeRs8b4PnbfC8DZ63wfM2eN4Gz9vgeRs8b4PnbfC8DZ63wfM2eN4Gz9vgeRs8b4PnbfC8DZ63wfM2eN4Gz9vgeRs8b4PnbfC8DZ63wfM2eN4Gz9vgeRust8F6G6y3wXobrLfBehust8F6G6y3wXobrLfBehust8F6G6y3wXobrLfBehust8F6G6y3wXobrLfBehust8F6G6y3wXobrLfBehust8F6G6y3wXobrLfBehust8F6G6y3wXobrLfBehust8F6G6y3wXobrLfBehust8F6G6y3wXobrLfBehust8F6G6y3wXobrLfBehust8F6G6y3wXobrLfBehust8F6G6y3wXobrLfBehust8F6G6y3wXobrLfBehust8F6G6y3wXobrLfBehust8F6G6y3wXobrLfBehust8F6G6y3wXobrLfBehust8F6G6y3wXobvG+D923wvg3et8H7NnjfBu/b4H0bvG+D923wvg3et8H7NnjfBu/b4H0bvG+D923wvg3et8H7NnjfBu/b4H0bvG+D923wvg3et8H7NnjfBu/b4H0bvG+D923wvg3et8H7NnjfBu/b4H0bvG+D923wvg3et8H7NnjfBu/b4H0bvG+D923wvg3et8H7NnjfBu/b4H0bvG+D923wvg3et8H7NnjfBu/b4H0bvG+D923wvg3et8H7NnjfBu/b4H0bvG+D923wvg3et8H7NnjfBu/b4H0bvG+D923wvg3et8H7NnjfBu/b4H0bvG+D923wvg3et8H7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D+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u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vXP85uE+P71z/ObhPj8Fv5p8Ovxq8enyq80nzuGcwzmHcw7nHM45nHM453DO4ZzDOUdwjuAcwTmCcwTnCM4RnCM4R3CO4BzJOZJzJOdIzpGcIzlHco7kHMk5knMcznE4x+Ech3MczsHOi50XOy92Xuy82Hmx82Lnxc6LnRc7L3Ze7LzYebHzYufFzoudFzsvdl7svNh5sfNi58XOi50XOy92Xuy82Hmx82Lnxc6LnRc7L3Ze7LzYebHzYufFzoudFzsvdl7s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/s/LLzy84vO7/svNl5s/Nm583Om503O2923uy82Xmz82bnzc6bnTc7b3be7LzZebPzZufNzpudNztvdt7svNl5s/Nm583Om503O2923uy82Xmz82bnzc6bnTc7b3be7LzZebPzZufNzpudNztvdt7svNl5s/Nm583Om503O2923uy82Xmz82bnzc6bnTc7b3be7LzZebPzZufNzpudNztvdt7svNl5s/Nm583Om503O2923uy82Xmz82bnzc6bnTc7b3be7LzZebPzZufNzpudNztvdt7svNl5s/Nm583Oh50POx92Pux82Pmw82Hnw86HnQ87H3Y+7HzY+bDzYefDzoedDzsfdj7sfNj5sPNh58POh50POx92Pux82Pmw82Hnw86HnQ87H3Y+7HzY+bDzYefDzoedDzsfdj7sfNj5sPNh58POh50POx92Pux82Pmw82Hnw86HnQ87H3Y+7HzY+bDzYefDzoedDzsfdj7sfNj5sPNh58POh50POx92Pux82Pmw82Hnw86HnQ87H3Y+7HzY+bDzYefDzoedDzsfdj7sfNj5sPNh58POh50POx92Pm/n5+Pt/Hy8nZ+Pt/Pz8XZ+Pt7Oz8fb+fl4Oz8fb+fn4+38fLydn4+38/Pxdn4+3s7Px9v5+Xg7Px9v5+fj7fx8vJ2fj7fz82GcwzmHcw7nHM45nHM453DO4ZzDOYdzjuAcwTmCcwTnCM4RnCM4R3CO4BzBOZJzJOdIzpGcIzlHco7kHMk5knMk5zic43COwzkO5zic43COwzkO5zic43CO4hzFOYpzFOcozlGcozhHcY7iHMU5Lue4nONyjss5Lue4nONyjss5Lue4nKM5R3OO5hzNOZpzNOdoztGcozlHc47hHMM5hnMM5xjOMZxjOMdwjuEc7NzYubFzY+fGzo2dGzs3dm7s3Ni5sXNj58bOjZ0bOzd2buzc2Lmxc2Pnxs6NnRs7N3Zu7NzYubFzY+fGzo2dGzs3dm7s3Ni5sXNj58bOjZ0bOzd2buzc2Lmxc2Pnxs6NnRs7N3Zu7NzYubFzY+fGzo2dGzs3dm7s3Ni5sXNj58bOjZ0bOzd2buzc2Lmxc2Pnxs6NnRs7N3Zu7NzYubFzY+fGzo2dGzs3dm7s3Ni5sXNj58bOjZ0bOzd2buzc2Lmxc2Pnxs6NnRs7N3Zu7NzYubFzY+fGzp2dOzt3du7s3Nm5s3Nn587OnZ07O3d27uzc2bmzc2fnzs6dnTs7d3bu7NzZubNzZ+fOzp2dOzt3du7s3Nm5s3Nn587OnZ07O3d27uzc2bmzc2fnzs6dnTs7d3bu7NzZubNzZ+fOzp2dOzt3du7s3Nm5s3Nn587OnZ07O3d27uzc2bmzc2fnzs6dnTs7d3bu7NzZubNzZ+fOzp2dOzt3du7s3Nm5s3Nn587OnZ07O3d27uzc2bmzc2fnzs6dnTs7d3bu7NzZubNzZ+fOzp2dOzt3du7sPNh5sPNg58HOg50HOw92Huw82Hmw82Dnwc6DnQc7D3Ye7DzYebDzYOfBzoOdBzsPdh7sPNh5sPNg58HOg50HOw92Huw82Hmw82Dnwc6DnQc7D3Ye7DzYebDzYOfBzoOdBzsPdh7sPNh5sPNg58HOg50HOw92Huw82Hmw82Dnwc6DnQc7D3Ye7DzYebDzYOfBzoOdBzsPdh7sPNh5sPNg58HOg50HOw92Huw82Hmw82Dnwc6DnQc7D3Ye7DzYebDzYOfBzoOdBzsPdh7sPNh5sPNg58HOk50nO092nuw82Xmy82Tnyc6TnSc7T3ae7DzZebLzZOfJzpOdJztPdp7sPNl5svNk58nOk50nO092nuw82Xmy82Tnyc6TnSc7T3ae7DzZebLzZOfJzpOdJztPdp7sPNl5svNk58nOk50nO092nuw82Xmy82Tnyc6TnSc7T3ae7DzZebLzZOfJzpOdJztPdp7sPNl5svNk58nOk50nO092nuw82Xmy82Tnyc6TnSc7T3ae7DzZebLzZOfJzpOdJztPdp7sPNl5svNk58nOk50nO092nuz8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87x8MdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMd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4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxX3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pRb3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtR72Dn3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6j3s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84PO8fDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDNR6u8XCNh2s8XOPhGg/XeLjGwzUervFwjYdrPFzj4RoP13i4xsM1Hq7xcI2Hazxc4+EaD9d4uMbDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcPZByDu+8fPk3z/6PoY+gtSH4/+gtLHq7+g9XH4C97kv380/oI3+u8fQ39B6uPRX1D6ePUXtD7qbK6zuc7mOpvrbK6zuc7mOpvrbK6zuc4WOlvobKGzhc4WOlvobKGzhc4WOlvobKmzpc6WOlvqbKmzpc6WOlvqbKmzpc52dLajsx2d7ehsR2c7OtvR2Y7OdnS2o7OVzlY6W+lspbOVzlY6W+lspbOVzlY629XZrs52dbars12d7epsV2e7OtvV2a7O1jpb62yts7XO1jpb62yts7XO1jpb62yjs43ONjrb6Gyjs43ONjrb6Gyjs6klppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiasloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSaglqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45aUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllvxmOG/8/tH18dvbbv3+MfXx6C8ofbz6C1of5/0Fv2HO99HeX/Ab53wfQ39B6uPRX1D6ePUXtD4Of8H3lryPnO032Pk+hv6C1Mejv6D08eovaH3U2Vxnc53NdTbX2Vxnc53NdTbX2Vxnc50tdLbQ2UJnC50tdLbQ2UJnC50tdLbQ2VJnS50tdbbU2VJnS50tdbbU2VJnS53t6GxHZzs629HZjs52dLajsx2d7ehsR2crna10ttLZSmcrna10ttLZSmcrna10tquzXZ3t6mxXZ7s629XZrs52dbars12drXW21tlaZ2udrXW21tlaZ2udrXW21tlGZ1NLrlpy1ZKrlly15KolVy25aslVS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS1otabWk1ZJWS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JJRS0YtGbVk1JKhJfZBS+yDltgHLbEPWmIftMQ+aIl90BL7oCX2QUvsg5bYBy2xD1piH7TEPmiJfdAS+6Al9kFL7IOW2ActsQ/T2Vxnc53NdTbX2Vxnc53NdTbX2Vxnc50tdLbQ2UJnC50tdLbQ2UJnC50tdLbQ2VJnS50tdbbU2VJnS50tdbbU2VJnS53t6GxHZzs629HZjs52dLajsx2d7ehsR2crna10ttLZSmcrna10ttLZSmcrna10tquzXZ3t6mxXZ7s629XZrs52dbars12drXW21tlaZ2udrXW21tlaZ2udrXW21tlGZxudbXS20dlGZxudbXS20dlGZ1NLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLTC0xtcTUElNLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLXC1xtcTVEldLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLQi0JtSTUklBLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLUi1JtSTVklRLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLSm1pNSSUktKLZF7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3s1uVeTezW5V5N7NblXk3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V//NvX77n98/1/p81+den0efvweFz7Y++/oc63Ouz+u9ud6b67253pvrvWe996z3nvXes9571nvPeu9Z7z3rvWe996z31npvrffWem+t99Z6b6331npvrffWem+t99713rvee9d773rvXe+96713vfeu99713rve2+u9vd7b67293tvrvb3e2+u9vd7b67293jvrvbPeO+u9s947672z3jvrvbPeO+u9o/f+Bmf5bOuzr8+xPuf6fNbnWp/v+tzr83qvrffaeq+t99p6r6332nqvrffaeq+t99p6r6/3+nqvr/f6eq+v9/p6r6/3+nqvr/f6em+s98Z6b6z3xnpvrPeuXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr17N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1ahX8aFexYd6FR/qVXyoV/GhXsWHehUf6lV8qFfxoV7Fx8d6r6332nqvrffaeq+t99p6r6332nqvrffaeq+v9/p6r6/3+nqvr/f6eq+v9/p6r6/3+npvrPfGem+s98Z6b6z3xnpvrPfGem+s98Z6b6735npvrvfmem+u9+Z6b6735npvrvfmeu9Z7z3rvWe996z3nvXes9571nvPeu9Z7z3rvbXeW+u9td5b67213lvrvbXeW+u9td5b6713vfeu99713rvee9d773rvXe+96713vfeu9/Z6b6/39npvr/f2em+v9/Z6b6/39npvr/fOeu+s985676z3znrvrPfOeu+s98567+qVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXq1Vm9OqtXZ/XqrF6d1auzenVWr87q1Vm9OqtXZ/XqrF6d1auzenVWr87q1Vm9OqtXZ/XqrF6d1auzenVWr87q1Vm9OqtXZ/XqrF6d1auzenVWr87q1Vm9OqtXZ/XqrF6d1auzenVWr87q1Vm9OqtXZ/XqrF6d1auzenVWr87q1Vm9OqtXZ/XqrF6d1auzenVWr87q1Vm9OqtXZ/XqrF6d1auzenVWr87q1Vm9OqtXZ/XqrF6d1auzenVWr87q1Vm9OqtXZ/XqrF6d1auzenVWr87q1Vm9OqtXZ/XqrF6d1auzenVWr87q1Vm9OqtXZ/XqrF6d1auzenVWr87q1Vm9OqtXZ/XqrF7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e3dWru3p1V6/u6tVdvbqrV3f16q5e3dWru3p1V6/u6tVdvbqrV3f16q5e3dWru3p1V6/u6tVdvbqrV3f16q5e3dWru3p1V6/u6tVdvbqrV3f16q5e3dWru3p1V6+Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL792+f13tWr5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xb83ffHvn75+Hz7779ff7+3pjfP/v6HOtzrs9nfa71+a7PvT5/f2/6b59/69X7bOuzr8+xPuf6fNbnWp/v+tzr83qvr/f6eq+v9/p6r6/3+nqvr/f6eq+v9/p6b6z3xnpvrPfGem+s98Z6b6z3xnpvrPfGem+u9+Z6b6735npvrvfmem+u9+Z6b6735nrvWe89671nvfes95713rPee9Z7z3rvWe8967213lvrvbXeW+u9td5b67213lvrvbXeW+u9d733rvfe9d673nvXe+96713vveu9d733rvf2em+v9/Z6b6/39npvr/f2em+v9/Z6b6/3znrvrPfOeu+s985676z3znrvrPfOeu/ovb/79vfZ1mdfn2N9zvX5rM+1Pt/1udfn9d7Vq1i9itWrWL2K1atYvYrVq1i9itWrWL2K1atYvYrVq1i9itWrWL2K1atYvYrVq1i9itWrWL2K1atYvYrVq1i9itWrWL2K1atYvYrVq1i9itWrWL2K1atYvYrVq1i9itWrWL2K1atYvYrVq1i9itWrWL2K1atYvYrVq1i9itWrWL2K1atYvYrVq1i9itWrWL2K1atYvYrVq1i9itWrWL2K1atYvYrVq1i9itWrWL2K1atYvYrVq1i9itWrWL2K1atYvYrVq1i9itWrWL2K1atYvYrVq1i9itWrWL2K1atYvcrVq1y9ytWrXL3K1atcvcrVq1y9ytWrXL3K1atcvcrVq1y9ytWrXL3K1atcvcrVq1y9ytWrXL3K1atcvcrVq1y9ytWrXL3K1atcvcrVq1y9ytWrXL3K1atcvcrVq1y9ytWrXL3K1atcvcrVq1y9ytWrXL3K1atcvcrVq1y9ytWrXL3K1atcvcrVq1y9ytWrXL3K1atcvcrVq1y9ytWrXL3K1atcvcrVq1y9ytWrXL3K1atcvcrVq1y9ytWrXL3K1atcvcrVq1y9ytWrXL3K1atcvcrVq1y9ytWrXL3K1atcvcrVq1y9ytWrXL3K1atcvcrVq1y9ytWrXL06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq1q9qtWrWr2q1atavarVq1q9qtWrWr2q1atavarVq1q9qtWrWr2q1atavarVq1q9qtWrWr2q1atavarVq1q9qtWrWr2q1atavarVq1q9qtWrWr2q1atavarVq1q9qtWrWr2q1atavarVq1q9qtWrWr2q1atavarVq1q9qtWrWr2q1atavarVq1q9qtWrWr2q1atavarVq1q9qtWrWr2q1atavarVq1q9qtWrWr2q1atavarVq1q9qtWrWr2q1atavarVq1q9qtWrWr2q1atavarVq1q9qtWrWr2q1atavarVq1q9qtWrWr2q1atavarVq1q9qtWrWr2q1au7enVXr+7q1V29uqtXd/Xqrl7d1au7enVXr+7q1V29uqtXd/Xqrl7d1au7enVXr+7q1e++Pc9vn3/v1ednW599fY71Odfnsz7X+nzX516f13tjvTfWe2O9N9Z7Y7031ntjvTfWe2O9N9Z7c70313tzvTfXe3O9N9d7c70313tzvTfXe89671nvPeu9Z733rPee9d6z3nvWe89671nvrfXeWu+t9d5a76313lrvrfXeWu+t9d5a773rvXe996733vXeu95713vveu9d773rvXe9t9d7e72313t7vbfXe3u9t9d7e72313t7vXfWe2e9d9Z7Z7131ntnvXfWe2e9d9Z7R+/93be/z7Y++/oc63Ouz2d9rvX5rs+9Pq/32nqvrffaeq+t99p6r6332nqvrffaeu/qVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9erVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXo16dT7Uq/P/N3UHKbN1yXlG56K2Gxmxd0Ts8FyMkGTZFBSSKEsGYzR3u/7v3srVew8nk6e3WgHn8/WqPl+v6vP1qj5fr+rz9ao+X6/q8/WqPl+v6vOhG3SDbtANukE36AbdoBt0g27STbpJN+km3aSbdJNu0k26h+6he+geuofuoXvoHrqH7qF76V66l+6le+leupfupXvpXrpFt+gW3aJbdItu0S26RbfoNt2m23SbbtNtuk236Tbdpjt0h+7QHbpDd+gO3aE7dIfuo/voPrqP7qP76D66j+6j++gu3aW7dJfu0l26S3fpLl28CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8+nXf/v7YP1792sFO9mFfdrGbPezHpnvpXrqX7qV76V66l+6le+leukW36Bbdolt0i27RLbpFt+g23abbdJtu0226TbfpNt2mO3SH7tAdukN36A7doTt0h+6j++g+uo/uo/voPrqP7qP76C7dpbt0l+7SXbpLd+ku3f12f923/9rBTvZhX3axmz3sx6YbdINu0A26QTfoBt2gG3SDbtJNukk36SbdpJt0k27SxauDVwevDl4dvDp4dfDq4NXBq4NXB68OXh28Onh18Org1cGrg1cHrw5eHbw6eHXw6uDVwauDVwevDl4dvDp4dfDq4NXBq4NXB68OXh28Onh18Org1cGrg1cHrw5eHbw6eHXw6uDVwauDVwevDl4dvDp4dfDq4NXBq4NXB68OXh28Onh18Org1cGrg1cHrw5eHbw6eHXw6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8Gr37u2yv+2H949XsHO9mHfdnFbvawH5tu0S26RbfoFt2iW3SLbtEtuk236Tbdptt0m27TbbpNt+kO3aE7dIfu0B26Q3foDt2h++g+uo/uo/voPrqP7qP76D66S3fpLt2lu3SX7tJdukt3v92f+/bfO9jJPuzLLnazh/3YdINu0A26QTfoBt2gG3SDbtBNukk36SbdpJt0k27STbpJ99A9dA/dQ/fQPXQP3UP30MWrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavNqvV/35etWfr1f9+XrVn69X/fl61Z+vV/35etWfr1f9+XrVnw/doBt0g27QDbpBN+gG3aAbdJNu0k26STfpJt2km3STbtI9dA/dQ/fQPXQP3UP30D10D91L99K9dC/dS/fSvXQv3Uv30i26RbfoFt2iW3SLbtEtukW36Tbdptt0m27TbbpNt+k23aE7dIfu0B26Q3foDt2hO3Qf3Uf30X10H91H99F9dB/dR3fpLt2lu3SX7tJdukt36eJV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXi1c99e90/9o9Xv3awk33Yl13sZg/7sek23abbdJtu0226TbfpNt2mO3SH7tAdukN36A7doTt0h+6j++g+uo/uo/voPrqP7qP76C7dpbt0l+7SXbpLd+ku3f12f+7bf+9gJ/uwL7vYzR72Y9MNukE36AbdoBt0g27QDbpBN+km3aSbdJNu0k26STfpJt1D99A9dA/dQ/fQPXQP3UP30L10L91L99K9dC/dS/fSvXTx6uDVwauDVwevDl4dvDp4dfDq4NXBq4NXB68OXh28Onh18Org1cGrg1cHrw5eHbw6eHXw6uDVwauDVwevDl4dvDp4dfDq4NXBq4NXB68OXh28Onh18Org1cGrg1cHrw5eHbw6eHXw6uDVwauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavF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h+7QHbpDd+gO3aE7dIfu0H10H91H99F9dB/dR/fRfXQf3aW7dJfu0sWrg1cHrw5eHbw6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDVw+vHl49vHp49XPffutnF7vZw37s/e4fr37tYCf7sOkG3aAbdINu0E26STfpJt2km3STbtJNukn30D10D91D99A9dA/dQ/fQPXQv3Uv30r10L91L99K9dC/dS7foFt2iW3SLbtEtukW36Bbdptt0m27TbbpNt+k23abbdIfu0B26Q3foDt2hO3SH7tB9dB/dR/fRfXQf3Uf30X10H92lu3SX7tJdukt36S7dpbvf7s99++8d7GQf9mUXu9nDfmy6eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tV+v9vP1aj9fr/bz9Wo/X6/28/VqP1+v9vP1aj9fr/bz9Wo/H7pBN+gG3aAbdINu0A26QTfoJt2km3STbtJNukk36SbdpHvoHrqH7qF76B66h+6he+geupfupXvpXrqX7qV76V66l+6lW3SLbtEtukW36Bbdolt0i27TbbpNt+k23abbdJtu0226Q3foDt2hO3SH7tAdukN36D66j+6j++g+uo/uo/voPrqP7tJdukt36S7dpbt0l+7SxavAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8Srg1cHrw5eHbw6eHXw6uDVwauDVwevDl4dvDp4dfDq1337+9nFbvawH3u/+8erXzvYyT5sukk36SbdpJt0D91D99A9dA/dQ/fQPXQP3UP30r10L91L99K9dC/dS/fSvXSLbtEtukW36Bbdolt0i27RbbpNt+k23abbdJtu0226TXfoDt2hO3SH7tAdukN36A7dR/fRfXQf3Uf30X10H91H99Fdukt36S7dpbt0l+7SXbr77f66b/+1g53sw77sYjd72I9NN+gG3aAbdPHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41Xg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5e/dy3V/zsYjd72I+93/3zvYlfO9jJPmy6h+6he+geuofupXvpXrqX7qV76V66l+6le+kW3aJbdItu0S26RbfoFt2i23SbbtNtuk236Tbdptt0m+7QHbpDd+gO3aE7dIfu0B26j+6j++g+uo/uo/voPrqP7qO7dJfu0l26S3fpLt2lu3T32/25b/+9g53sw77sYjd72I9NN+gG3aAbdINu0A26QTfoBt2km3STbtLFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8Wrxav9m1f5+fzNq7/uYCf7sC+72M0e9mPTDbpBN+gG3aAbdINu0A26QTfpJt2km3STbtJNukk36SbdQ/fQPXQP3UP30D10D91D99C9dC/dS/fSvXQv3Uv30r10L92iW3SLbtEtukW36Bbdolt0m27TbbpNt+k23abbdJtu0x26Q3foDt2hO3SH7tAdukP30X10H91H99F9dB/dR/fRfXSX7tJdukt36S7dpbt0ly5eBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXh28Onh18Org1cGrg1cHrw5eHbw6eHXw6uDVwauDVwevDl4dvDp4dfDq4NXBq4NXB68OXh28Onh18Org1cGrg1cHrw5eHbw6ePVz3173Zxe72cN+7P3uH69+7WAn+7DpXrqX7qV76V66RbfoFt2iW3SLbtEtukW36Dbdptt0m27TbbpNt+k23aY7dIfu0B26Q3foDt2hO3SH7qP76D66j+6j++g+uo/uo/voLt2lu3SX7tJdukt36S7d/XZ/7tt/72An+7Avu9jNHvZj0w26QTfoBt2gG3SDbtANukE36SbdpJt0k27STbpJN+km3UP30D10D128unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tX+/UqPl+v4vP1Kj5fr+Lz9So+X6/i8/UqPl+v4vP1Kj5fr+LzoRt0g27QDbpBN+gG3aAbdINu0k26STfpJt2km3STbtJNuofuoXvoHrqH7qF76B66h+6he+leupfupXvpXrqX7qV76V66RbfoFt2iW3SLbtEtukW36Dbdptt0m27TbbpNt+k23aY7dIfu0B26Q3foDt2hO3SH7qP76D66j+6j++g+uo/uo/voLt2lu3SX7tJdukt36S5dvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8Srw6eHXw6uDVwauDVwevDl4dvDp4dfDq4NXBq4NXB68OXh28Onh18Org1cGrg1cHrw5eHbw6eHXw6uDVwauDVwevDl4dvDp4dfCK+/bgvj24bw/u24P79uC+PbhvD+7bg/v24L49uG8P7tuD+/bgvj24bw/u24P79uC+PbhvD+7bg/v2+HXfPj+72cN+7P3uH69+7WAn+7Avm27TbbpNt+kO3aE7dIfu0B26Q3foDt2h++g+uo/uo/voPrqP7qP76D66S3fpLt2lu3SX7tJdukt3v91f9+2/drCTfdiXXexmD/ux6QbdoBt0g27QDbpBN+gG3aCbdJNu0k26STfpJt2km3ST7qF76B66h+6he+geuofuoXvoXrqX7qV76V66l+6le+leupdu0S26RbfoFl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6tf9+37s4v9127nz/5rt3/9/rH3u//w6vcOdrIP+7KL3Wy6Q3foPrqP7qP76D66j+6j++g+uo/u0l26S3fpLt2lu3SX7tLdb/fnvv33DnayD/uyi93sYT823aAbdINu0A26QTfoBt2gG3STbtJNukk36SbdpJt0k27SPXQP3UP30D10D91D99A9dA/dS/fSvXQv3Uv30r10L91L99ItukW36Bbdolt0i27RLbpFt+k23abbdJtu0226eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tV+v8vP1Kj9fr/Lz9So/X6/y8/UqP1+v8vP1Kj9fr/Lz9So/H7pBN+gG3aAbdINu0A26QTfoJt2km3STbtJNukk36SbdpHvoHrqH7qF76B66h+6he+geupfupXvpXrqX7qV76V66l+6lW3SLbtEtukW36Bbdolt0i27TbbpNt+k23abbdJtu0226Q3foDt2hO3SH7tAdukN36D66j+6j++g+uo/uo/voPrqP7tJdukt36S7dpbt0l+7SxavAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8Srg1cHrw5eHbw6eHXw6uDVwauDVwevDl4dvDp4dfDq4NXBq4NXB68OXh28Onh18Org1cGrg1cHrw5eHbw6eHXw6uDVwauDVwevDl4dvDp4dfDq4NXBq4NXB68OXh28Onh18Org1cGrg1cHrw5eHbw6eHXw6uDVwauDVwevDl4dvDp4dfDq4NXBq4NXB68OXh28Onh18Org1cGrg1cHrw5eHbw6ePVz3977n//l7/73P/zlT//wj3/+5//1d//1//7/x//xH//yT//+p3/9l1+P//5//u33m3/8y5/+/Oc//c+//7e//Os//fN//4+//PPf//lf/+mPd//53/7z/wE=","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse lib::configs::default::threshold::{\n    L, N, THRESHOLD_SHARE_DECRYPTION_BIT_CT, THRESHOLD_SHARE_DECRYPTION_BIT_D,\n    THRESHOLD_SHARE_DECRYPTION_BIT_E_SM, THRESHOLD_SHARE_DECRYPTION_BIT_R1,\n    THRESHOLD_SHARE_DECRYPTION_BIT_R2, THRESHOLD_SHARE_DECRYPTION_BIT_SK,\n    THRESHOLD_SHARE_DECRYPTION_CONFIGS,\n};\nuse lib::core::threshold::share_decryption::ShareDecryption;\nuse lib::math::polynomial::Polynomial;\n\nfn main(\n    expected_sk_commitment: pub Field,\n    expected_e_sm_commitment: pub Field,\n    ct0: pub [Polynomial<N>; L],\n    ct1: pub [Polynomial<N>; L],\n    sk: [Polynomial<N>; L],\n    e_sm: [Polynomial<N>; L],\n    r1: [Polynomial<(2 * N) - 1>; L],\n    r2: [Polynomial<N - 1>; L],\n    d: [Polynomial<N>; L],\n) {\n    let share_decryption: ShareDecryption<N, L, THRESHOLD_SHARE_DECRYPTION_BIT_CT, THRESHOLD_SHARE_DECRYPTION_BIT_SK, THRESHOLD_SHARE_DECRYPTION_BIT_E_SM, THRESHOLD_SHARE_DECRYPTION_BIT_R1, THRESHOLD_SHARE_DECRYPTION_BIT_R2, THRESHOLD_SHARE_DECRYPTION_BIT_D> = ShareDecryption::new(\n        THRESHOLD_SHARE_DECRYPTION_CONFIGS,\n        expected_sk_commitment,\n        expected_e_sm_commitment,\n        ct0,\n        ct1,\n        sk,\n        e_sm,\n        r1,\n        r2,\n        d,\n    );\n    share_decryption.execute()\n}\n","path":"enclave/circuits/bin/threshold/share_decryption/src/main.nr"},"72":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse crate::math::commitments::{\n    compute_aggregated_shares_commitment, compute_threshold_share_decryption_challenge,\n};\nuse crate::math::helpers::flatten;\nuse crate::math::polynomial::Polynomial;\n\n/// Cryptographic parameters for Threshold decryption share circuit.\npub struct Configs<let L: u32> {\n    /// CRT moduli: [q_0, q_1, ..., q_{L-1}]\n    pub qis: [Field; L],\n    /// Bounds for r1 polynomials (modulus switching quotients) for each CRT basis\n    pub r1_bounds: [Field; L],\n    /// Bounds for r2 polynomials (cyclotomic reduction quotients) for each CRT basis\n    pub r2_bounds: [Field; L],\n}\n\nimpl<let L: u32> Configs<L> {\n    pub fn new(qis: [Field; L], r1_bounds: [Field; L], r2_bounds: [Field; L]) -> Self {\n        Configs { qis, r1_bounds, r2_bounds }\n    }\n}\n\n/// Threshold Share Decryption (Circuit 6).\n///\n/// Verifies:\n/// 1. Commitment to sk matches expected (from DKG decryption circuit)\n/// 2. Commitment to e_sm matches expected (from DKG decryption circuit)\n/// 3. Correct computation: d_i = c_0i + c_1i * s_i + e_i + r_2i * (X^N + 1) + r_1i * q_i\npub struct ShareDecryption<let N: u32, let L: u32, let BIT_CT: u32, let BIT_SK: u32, let BIT_E_SM: u32, let BIT_R1: u32, let BIT_R2: u32, let BIT_D: u32> {\n    /// Circuit parameters including bounds and cryptographic constants\n    configs: Configs<L>,\n\n    /// Expected commitment to aggregated sk shares (from DKG decryption circuit)\n    /// (public witness)\n    expected_sk_commitment: Field,\n\n    /// Expected commitment to aggregated e_sm shares (from DKG decryption circuit)\n    /// (public witness)\n    expected_e_sm_commitment: Field,\n\n    /// Ciphertext components (public witnesses)\n    /// ct0 components for each CRT basis (degree N-1 polynomials with N coefficients)\n    ct0: [Polynomial<N>; L],\n    /// ct1 components for each CRT basis (degree N-1 polynomials with N coefficients)\n    ct1: [Polynomial<N>; L],\n\n    /// Aggregated sum of sk shares (secret witness)\n    sk: [Polynomial<N>; L],\n\n    /// Aggregated sum of e_sm shares (secret witness, direct input)\n    /// e_sm[basis] - sum of e_sm shares for each CRT basis (degree N-1 with N coefficients)\n    e_sm: [Polynomial<N>; L],\n\n    /// Quotient polynomials for lifting to Z (secret witnesses)\n    r1: [Polynomial<2 * N - 1>; L],\n    r2: [Polynomial<N - 1>; L],\n\n    /// Party's computed decryption share\n    /// (public witnesses)\n    d: [Polynomial<N>; L],\n}\n\nimpl<let N: u32, let L: u32, let BIT_CT: u32, let BIT_SK: u32, let BIT_E_SM: u32, let BIT_R1: u32, let BIT_R2: u32, let BIT_D: u32> ShareDecryption<N, L, BIT_CT, BIT_SK, BIT_E_SM, BIT_R1, BIT_R2, BIT_D> {\n    pub fn new(\n        configs: Configs<L>,\n        expected_sk_commitment: Field,\n        expected_e_sm_commitment: Field,\n        ct0: [Polynomial<N>; L],\n        ct1: [Polynomial<N>; L],\n        sk: [Polynomial<N>; L],\n        e_sm: [Polynomial<N>; L],\n        r1: [Polynomial<2 * N - 1>; L],\n        r2: [Polynomial<N - 1>; L],\n        d: [Polynomial<N>; L],\n    ) -> Self {\n        ShareDecryption {\n            configs,\n            expected_sk_commitment,\n            expected_e_sm_commitment,\n            ct0,\n            ct1,\n            sk,\n            e_sm,\n            r1,\n            r2,\n            d,\n        }\n    }\n\n    /// Verifies that aggregated secret shares hash to expected_sk_commitment\n    fn verify_agg_sk_commitment(self) {\n        assert(\n            compute_aggregated_shares_commitment::<N, L, BIT_SK>(self.sk)\n                == self.expected_sk_commitment,\n            \"S commitment mismatch\",\n        );\n    }\n\n    /// Verifies that aggregated noise shares hash to expected_e_sm_commitment\n    fn verify_agg_e_sm_commitment(self) {\n        assert(\n            compute_aggregated_shares_commitment::<N, L, BIT_E_SM>(self.e_sm)\n                == self.expected_e_sm_commitment,\n            \"E commitment mismatch\",\n        );\n    }\n\n    /// Flattens all witness data into a single array for Fiat-Shamir challenge generation.\n    ///\n    /// This function serializes all polynomial coefficients (both public inputs and\n    /// secret witnesses) into a 1D array in a deterministic order. The flattened data\n    /// is used to generate the Fiat-Shamir challenge via the SAFE sponge API.\n    ///\n    /// The order of serialization is:\n    /// 1. Commitment to aggregated secret shares `sk` (expected_sk_commitment)\n    /// 2. Commitment to aggregated noise shares `e_sm` (expected_e_sm_commitment)\n    /// 3. Ciphertext components `c_0` for each CRT basis (serialized coefficients)\n    /// 4. Ciphertext components `c_1` for each CRT basis (serialized coefficients)\n    /// 5. Quotient polynomials `r_1` for each CRT basis (serialized coefficients)\n    /// 6. Quotient polynomials `r_2` for each CRT basis (serialized coefficients)\n    /// 7. Decryption shares `d` for each CRT basis (serialized coefficients)\n    ///\n    /// Note: Aggregated secret shares `sk` and noise shares `e_sm` are represented by their\n    /// commitments rather than serialized coefficients. This saves constraints while\n    /// still binding them to the transcript.\n    ///\n    /// # Returns\n    /// A vector containing commitments and polynomial coefficients in flattened form,\n    /// ready for hashing to generate the Fiat-Shamir challenge.\n    fn payload(self) -> Vec<Field> {\n        let mut inputs = Vec::new();\n\n        // Use commitments instead of full polynomials (saves constraints)\n        inputs.push(self.expected_sk_commitment);\n        inputs.push(self.expected_e_sm_commitment);\n\n        // Flatten ciphertext components (public inputs)\n        inputs = flatten::<_, _, BIT_CT>(inputs, self.ct0);\n        inputs = flatten::<_, _, BIT_CT>(inputs, self.ct1);\n\n        // Flatten quotient polynomials (secret witnesses)\n        inputs = flatten::<_, _, BIT_R1>(inputs, self.r1);\n        inputs = flatten::<_, _, BIT_R2>(inputs, self.r2);\n\n        // Flatten decryption shares (public outputs)\n        inputs = flatten::<_, _, BIT_D>(inputs, self.d);\n\n        inputs\n    }\n\n    /// Main verification function\n    pub fn execute(self) {\n        // Step 1: Verify sk commitment matches expected\n        self.verify_agg_sk_commitment();\n\n        // Step 2: Verify e_sm commitment matches expected\n        self.verify_agg_e_sm_commitment();\n\n        // Step 3: Perform range checks on quotient polynomials\n        // Note: sk and e_sm range checks are handled by commitment verification\n        // (the DKG decryption circuit already performed range checks on these values)\n        self.check_range_bounds();\n\n        // Step 4: Generate Fiat-Shamir challenge from the transcript\n        let gamma = self.generate_challenge();\n\n        // Step 5: Verify decryption share computation for each CRT basis\n        for i in 0..L {\n            self.verify_decryption_share_computation(i, gamma);\n        }\n    }\n\n    /// Performs range checks on quotient polynomial witnesses.\n    ///\n    /// This function constrains quotient polynomials to be within their expected bounds\n    /// as specified in the `configs`. This is critical for security because it prevents\n    /// attacks where malicious provers provide out-of-range values that could break the\n    /// security properties of the Threshold scheme.\n    ///\n    /// Note: Range checks on `sk` and `e_sm` are NOT performed here because:\n    /// - Their commitments are verified against expected values from the DKG circuit\n    /// - The DKG decryption circuit already performed range checks on these values\n    /// - Commitment binding ensures the values match what was previously verified\n    ///\n    /// # Panics\n    /// This function will cause the circuit to fail if any quotient coefficient is\n    /// outside its expected bounds.\n    fn check_range_bounds(self) {\n        // Check quotient polynomials are within bounds\n        for basis_idx in 0..L {\n            // r_1 quotients can be negative (modulus quotients)\n            self.r1[basis_idx].range_check_2bounds::<BIT_R1>(\n                self.configs.r1_bounds[basis_idx],\n                self.configs.r1_bounds[basis_idx],\n            );\n            // r_2 quotients (cyclotomic quotients)\n            self.r2[basis_idx].range_check_2bounds::<BIT_R2>(\n                self.configs.r2_bounds[basis_idx],\n                self.configs.r2_bounds[basis_idx],\n            );\n        }\n    }\n\n    /// Generates Fiat-Shamir challenge value using the SAFE cryptographic sponge.\n    ///\n    /// This function implements the Fiat-Shamir transform for the decryption share circuit:\n    /// 1. Flattens all witness data (commitments for sk/e_sm, ciphertexts c_0/c_1, quotients r_1/r_2, decryption shares d) into a single array\n    /// 2. Absorbs the flattened data into the SAFE sponge\n    /// 3. Squeezes a single challenge value\n    ///\n    /// The challenge is used to evaluate polynomials for the Schwartz-Zippel lemma,\n    /// which allows verification of polynomial equations by checking them at a random\n    /// point rather than checking all coefficients.\n    ///\n    /// # Returns\n    /// A single challenge value `gamma` used as the evaluation point for verifying\n    /// the decryption share computation formula for all CRT bases.\n    fn generate_challenge(self) -> Field {\n        let inputs = self.payload();\n\n        compute_threshold_share_decryption_challenge::<L>(inputs)\n    }\n\n    /// Verifies the lifted decryption share computation formula for a specific CRT basis using the Schwartz-Zippel lemma.\n    ///\n    /// This function verifies that the decryption share for basis `i` satisfies:\n    /// `d_i(gamma) = c_0i(gamma) + c_1i(gamma) * s_i(gamma) + e_i(gamma) + r_2i(gamma) * cyclo(gamma) + r_1i(gamma) * q_i`\n    ///\n    /// Where:\n    /// - `c_0i`, `c_1i` are ciphertext components for basis i\n    /// - `s_i` is the aggregated secret key shares for basis i\n    /// - `e_i` is the aggregated noise shares for basis i\n    /// - `r_1i`, `r_2i` are quotient witnesses for basis i\n    /// - `cyclo(gamma) = gamma^N + 1` is the cyclotomic polynomial evaluated at gamma\n    /// - `q_i` is the CRT modulus for basis i\n    ///\n    /// The Schwartz-Zippel lemma ensures that if this equation holds at a random point\n    /// `gamma`, then the polynomials are identical with high probability.\n    ///\n    /// # Arguments\n    /// * `basis_idx` - The index of the CRT basis to verify (0 <= basis_idx < L)\n    /// * `gamma` - The Fiat-Shamir challenge value used as the evaluation point\n    ///\n    /// # Panics\n    /// The circuit will fail if the decryption share computation formula doesn't hold for the specified basis.\n    fn verify_decryption_share_computation(self, basis_idx: u32, gamma: Field) {\n        // Evaluate ciphertext components at gamma\n        let c_0_at_gamma = self.ct0[basis_idx].eval(gamma);\n        let c_1_at_gamma = self.ct1[basis_idx].eval(gamma);\n\n        // Evaluate aggregated sums at gamma\n        let sk_at_gamma = self.sk[basis_idx].eval(gamma);\n        let e_sm_at_gamma = self.e_sm[basis_idx].eval(gamma);\n\n        // Evaluate quotient polynomials at gamma\n        let r_1_at_gamma = self.r1[basis_idx].eval(gamma);\n        let r_2_at_gamma = self.r2[basis_idx].eval(gamma);\n\n        // Evaluate cyclotomic polynomial X^N + 1 at gamma\n        let cyclo_at_gamma = gamma.pow_32(N as Field) + 1;\n\n        // Compute expected decryption share using the lifted formula:\n        // d_i = c_0i + c_1i * sk_i + e_sm_i + r_2i * (X^N + 1) + r_1i * q_i\n        let expected_decryption_share = c_0_at_gamma\n            + c_1_at_gamma * sk_at_gamma\n            + e_sm_at_gamma\n            + r_2_at_gamma * cyclo_at_gamma\n            + r_1_at_gamma * self.configs.qis[basis_idx];\n\n        // Evaluate the party's claimed decryption share at gamma\n        let computed_decryption_share = self.d[basis_idx].eval(gamma);\n\n        // Enforce equality: computed decryption share must match expected value\n        assert(\n            computed_decryption_share == expected_decryption_share,\n            \"Decryption share computation failed\",\n        );\n    }\n}\n","path":"enclave/circuits/lib/src/core/threshold/share_decryption.nr"},"76":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse crate::math::helpers::{compute_safe, flatten};\nuse crate::math::polynomial::Polynomial;\n\n/// DOMAIN SEPARATORS\n\n// Domain separator - \"PK\"\npub global DS_PK: [u8; 64] = [\n    0x50, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"PK_GENERATION\"\npub global DS_PK_GENERATION: [u8; 64] = [\n    0x50, 0x4b, 0x5f, 0x47, 0x45, 0x4e, 0x45, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"SHARE_COMPUTATION\"\npub global DS_SHARE_COMPUTATION: [u8; 64] = [\n    0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x43, 0x4f, 0x4d, 0x50, 0x55, 0x54, 0x41, 0x54, 0x49, 0x4f,\n    0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"SHARE_ENCRYPTION\"\npub global DS_SHARE_ENCRYPTION: [u8; 64] = [\n    0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x45, 0x4e, 0x43, 0x52, 0x59, 0x50, 0x54, 0x49, 0x4f, 0x4e,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"PK_AGGREGATION\"\npub global DS_PK_AGGREGATION: [u8; 64] = [\n    0x50, 0x4b, 0x5f, 0x41, 0x47, 0x47, 0x52, 0x45, 0x47, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CIPHERTEXT\"\npub global DS_CIPHERTEXT: [u8; 64] = [\n    0x43, 0x49, 0x50, 0x48, 0x45, 0x52, 0x54, 0x45, 0x58, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"AGGREGATED_SHARES\"\npub global DS_AGGREGATED_SHARES: [u8; 64] = [\n    0x41, 0x47, 0x47, 0x52, 0x45, 0x47, 0x41, 0x54, 0x45, 0x44, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45,\n    0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"RECURSIVE_AGGREGATION\"\npub global DS_RECURSIVE_AGGREGATION: [u8; 64] = [\n    0x52, 0x45, 0x43, 0x55, 0x52, 0x53, 0x49, 0x56, 0x45, 0x5f, 0x41, 0x47, 0x47, 0x52, 0x45, 0x47,\n    0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_PK_GENERATION\"\npub global DS_CLG_PK_GENERATION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x50, 0x4b, 0x5f, 0x47, 0x45, 0x4e, 0x45, 0x52, 0x41, 0x54, 0x49, 0x4f,\n    0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_SHARE_ENCRYPTION\"\npub global DS_CLG_SHARE_ENCRYPTION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x45, 0x4e, 0x43, 0x52, 0x59, 0x50,\n    0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_USER_DATA_ENCRYPTION\"\npub global DS_CLG_USER_DATA_ENCRYPTION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x55, 0x53, 0x45, 0x52, 0x5f, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x45, 0x4e,\n    0x43, 0x52, 0x59, 0x50, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_SHARE_DECRYPTION\"\npub global DS_CLG_SHARE_DECRYPTION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x44, 0x45, 0x43, 0x52, 0x59, 0x50,\n    0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n\n// Domain separator - \"USER_DATA_ENCRYPTION_COMMITMENT\"\npub global DS_USER_DATA_ENCRYPTION_COMMITMENT: [u8; 64] = [\n    0x55, 0x53, 0x45, 0x52, 0x5f, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x45, 0x4e, 0x43, 0x52, 0x59, 0x50,\n    0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x43, 0x4f, 0x4d, 0x4d, 0x49, 0x54, 0x4d, 0x45, 0x4e, 0x54, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n\n/// WRAPPERS\n\npub fn compute_commitment(inputs: Vec<Field>, domain_separator: [u8; 64]) -> Field {\n    compute_safe(domain_separator, inputs, [0x80000000 | inputs.len(), 1]).get(0)\n}\n\npub fn compute_single_polynomial_commitment<let N: u32, let BIT: u32>(\n    polynomial: Polynomial<N>,\n    domain_separator: [u8; 64],\n) -> Field {\n    let mut payload = single_polynomial_payload::<N, BIT>(Vec::new(), polynomial);\n    compute_commitment(payload, domain_separator)\n}\n\npub fn compute_multiple_polynomial_commitment<let N: u32, let L: u32, let BIT: u32>(\n    polynomials: [Polynomial<N>; L],\n    domain_separator: [u8; 64],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT>(Vec::new(), polynomials);\n    compute_commitment(payload, domain_separator)\n}\n\npub fn compute_challenge<let L: u32>(inputs: Vec<Field>, domain_separator: [u8; 64]) -> Vec<Field> {\n    compute_safe(domain_separator, inputs, [0x80000000 | inputs.len(), 2 * L])\n}\n\npub fn single_polynomial_payload<let N: u32, let BIT_POLY: u32>(\n    payload: Vec<Field>,\n    input: Polynomial<N>,\n) -> Vec<Field> {\n    flatten::<_, _, BIT_POLY>(payload, [input])\n}\n\npub fn multiple_polynomial_payload<let N: u32, let L: u32, let BIT_POLY: u32>(\n    payload: Vec<Field>,\n    inputs: [Polynomial<N>; L],\n) -> Vec<Field> {\n    flatten::<_, _, BIT_POLY>(payload, inputs)\n}\n\n/// COMMITMENTS\n\npub fn compute_dkg_pk_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);\n    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);\n\n    compute_commitment(payload, DS_PK)\n}\n\npub fn compute_threshold_pk_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);\n    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);\n\n    compute_commitment(payload, DS_PK_GENERATION)\n}\n\npub fn compute_share_computation_sk_commitment<let N: u32, let BIT_SK: u32>(\n    sk: Polynomial<N>,\n) -> Field {\n    let mut payload = single_polynomial_payload::<N, BIT_SK>(Vec::new(), sk);\n    compute_commitment(payload, DS_SHARE_COMPUTATION)\n}\n\npub fn compute_share_computation_e_sm_commitment<let N: u32, let L: u32, let BIT_E_SM: u32>(\n    e_sm: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_E_SM>(Vec::new(), e_sm);\n    compute_commitment(payload, DS_SHARE_COMPUTATION)\n}\n\npub fn compute_share_encryption_commitment_from_message<let N: u32, let BIT_MSG: u32>(\n    message: Polynomial<N>,\n) -> Field {\n    let mut payload = single_polynomial_payload::<N, BIT_MSG>(Vec::new(), message);\n    compute_commitment(payload, DS_SHARE_ENCRYPTION)\n}\n\npub fn compute_share_encryption_commitment_from_shares<let N: u32, let L: u32, let N_PARTIES: u32>(\n    y: [[[Field; N_PARTIES + 1]; L]; N],\n    party_idx: u32,\n    mod_idx: u32,\n) -> Field {\n    let mut payload = Vec::new();\n\n    for coeff_idx in 0..N {\n        payload.push(y[coeff_idx][mod_idx][party_idx + 1]);\n    }\n\n    // Include party_idx and mod_idx in the hash\n    payload.push(party_idx as Field);\n    payload.push(mod_idx as Field);\n\n    compute_commitment(payload, DS_SHARE_ENCRYPTION)\n}\n\npub fn compute_aggregated_shares_commitment<let N: u32, let L: u32, let BIT_MSG: u32>(\n    agg_shares: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_MSG>(Vec::new(), agg_shares);\n    compute_commitment(payload, DS_AGGREGATED_SHARES)\n}\n\npub fn compute_pk_aggregation_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let commit_pk0 = compute_multiple_polynomial_commitment::<N, L, BIT_PK>(pk0, DS_PK_AGGREGATION);\n    let commit_pk1 = compute_multiple_polynomial_commitment::<N, L, BIT_PK>(pk1, DS_PK_AGGREGATION);\n\n    let mut inputs = Vec::new();\n    inputs.push(commit_pk0);\n    inputs.push(commit_pk1);\n\n    compute_commitment(inputs, DS_PK_AGGREGATION)\n}\n\npub fn compute_recursive_aggregation_commitment(payload: Vec<Field>) -> Field {\n    compute_commitment(payload, DS_RECURSIVE_AGGREGATION)\n}\n\npub fn compute_ciphertext_commitment<let N: u32, let L: u32, let BIT_CT: u32>(\n    ct0: [Polynomial<N>; L],\n    ct1: [Polynomial<N>; L],\n) -> Field {\n    let commit_ct0 = compute_multiple_polynomial_commitment::<N, L, BIT_CT>(ct0, DS_CIPHERTEXT);\n    let commit_ct1 = compute_multiple_polynomial_commitment::<N, L, BIT_CT>(ct1, DS_CIPHERTEXT);\n\n    let mut inputs = Vec::new();\n    inputs.push(commit_ct0);\n    inputs.push(commit_ct1);\n\n    compute_commitment(inputs, DS_CIPHERTEXT)\n}\n\n/// COMMITMENTS FOR CHALLENGES\n\npub fn compute_threshold_pk_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {\n    compute_challenge::<L>(payload, DS_CLG_PK_GENERATION)\n}\n\npub fn compute_share_encryption_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {\n    compute_challenge::<L>(payload, DS_CLG_SHARE_ENCRYPTION)\n}\n\npub fn compute_threshold_share_decryption_challenge<let L: u32>(payload: Vec<Field>) -> Field {\n    compute_challenge::<L>(payload, DS_CLG_SHARE_DECRYPTION).get(0)\n}\n\npub fn compute_user_data_encryption_ct0_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {\n    compute_challenge::<L>(payload, DS_CLG_USER_DATA_ENCRYPTION)\n}\n\npub fn compute_user_data_encryption_ct1_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {\n    compute_challenge::<L>(payload, DS_CLG_USER_DATA_ENCRYPTION)\n}\n","path":"enclave/circuits/lib/src/math/commitments.nr"},"77":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\n//! Helper functions for circuit construction and cryptographic operations.\nuse crate::math::polynomial::Polynomial;\nuse crate::math::safe::SafeSponge;\n\n/// Compute hex-aligned packing parameters for a given `BIT`.\n///\n/// # Purpose\n/// Returns `(nibble_bits, group)` for use by pack/flatten so layout stays consistent.\n/// - `nibble_bits`: ceil (`BIT`) to the next multiple of 4 (nibble alignment).\n///   - Examples: `BIT = 7 -> 8`, `BIT = 8 -> 8`, `BIT = 9 -> 12`, `BIT = 10 -> 12`, `BIT = 11 -> 12`,\n///     `BIT=16 -> 16`, `BIT = 17 -> 20`.\n/// - `group`: max number of encoded limbs that fit in one BN254 field element,\n///            when each limb uses an extra 4 bits (see below).\n///\n/// # Rationale\n/// - We align to nibbles so powers of two are hex-friendly and deterministic.\n/// - We reserve one extra nibble (4 bits) per stored value to lift signed\n///   coefficients into the non-negative range (e.g., store `v + 2^nibble_bits`),\n///   which implies a radix of `2^(nibble_bits + 4)`.\n///\n/// # Safety\n/// - Asserts `nibble_bits + 4 <= 254` to avoid mod-p wrap on BN254.\n/// - Ensures at least one limb fits: `group >= 1`.\nfn packing_layout<let BIT: u32>() -> (u32, u32) {\n    // Ceil BIT up to the next multiple of 4 (nibble alignment).\n    let nibble_bits = ((BIT + 3) / 4) * 4;\n\n    // Each stored limb uses an extra nibble because negative coefficients\n    // will be shifted to positive, so radix = 2^(nibble_bits+4).\n    assert(nibble_bits + 4 <= 254);\n\n    // Maximum limbs that fit in one BN254 element without wrap.\n    let group = 254 / (nibble_bits + 4);\n    assert(group >= 1);\n    (nibble_bits, group)\n}\n\n/// Flatten `L` polynomials into a single linear stream of packed `Field` carriers.\n///\n/// ## What this does\n/// - For each CRT limb `j` in `0..L`, it packs the coefficients of `poly[j]`\n///   with `pack::<A, BIT>` and appends all resulting carriers to `inputs`.\n/// - The packing layout (nibble-aligned width and `group` size) is taken from\n///   `packing_layout::<BIT>()` and must match what `pack` uses.\n///\n/// ## Determinism & order\n/// - Preserves a stable order: iterate `j = 0..L`, then for each `j` append\n///   carriers in ascending chunk index `i = 0..num_chunks`.\n/// - This ensures transcripts remain deterministic across runs.\n///\n/// ## Generics\n/// - `A`: polynomial degree (number of coefficients per polynomial).\n/// - `L`: number of CRT bases (polynomials).\n/// - `BIT`: per-coefficient bit bound used by the packing layout (compile-time).\n///\n/// ## Returns\n/// - The same `inputs` vector, extended with all carriers in deterministic order.\npub fn flatten<let A: u32, let L: u32, let BIT: u32>(\n    mut inputs: Vec<Field>,\n    poly: [Polynomial<A>; L],\n) -> Vec<Field> {\n    for j in 0..L {\n        // Pack its A coefficients into `num_chunks` carriers using the same BIT layout.\n        let packed = pack::<A, BIT>(poly[j].coefficients);\n\n        // Append carriers in-order to `inputs` to keep a stable transcript layout.\n        for i in 0..packed.len() {\n            inputs.push(packed.get(i));\n        }\n    }\n\n    // Return the extended input stream.\n    inputs\n}\n\n/// Pack `A` values into a `Vec<Field>` of carriers using the shared hex-aligned layout.\n///\n/// ## What this does\n/// - Computes `(nibble_bits, group)` via `packing_layout::<BIT>()`.\n/// - Encodes each value as a limb `digit = v + 2^nibble_bits` and concatenates\n///   limbs in base `radix = 2^(nibble_bits + 4)` (one extra nibble of headroom).\n/// - Packs up to `group` limbs per carrier (fits within BN254 254-bit capacity).\n/// - Pads the last, partial carrier with `digit = 2^nibble_bits` to keep a stable layout.\n///\n/// ## Determinism & order\n/// - Processes values in increasing index order and emits carriers in chunk order\n///   (`chunk = 0..num_chunks`). Padding is deterministic.\n///\n/// ## Generics\n/// - `A`: number of input values.\n/// - `BIT`: per-value bit bound; rounded up to `nibble_bits` by `packing_layout`.\n///\n/// ## Preconditions / Notes\n/// - Call with the raw coefficients whose magnitudes already satisfy the BIT bound\n///   (as enforced by the upstream range checks); `pack` performs the signed -> unsigned\n///   shift internally via `v + base`.\n/// - `group >= 1` is enforced by `packing_layout::<BIT>()`.\n/// - Padding with `digit = 2^nibble_bits` encodes `zero limb` consistently.\n///\n/// ## Returns\n/// - A `Vec<Field>` where each element is a concatenation of up to `group` limbs,\n///   suitable for hashing or transcript I/O.\npub fn pack<let A: u32, let BIT: u32>(values: [Field; A]) -> Vec<Field> {\n    // Layout parameters: nibble-aligned width and limbs-per-carrier group size.\n    let (nibble_bits, group) = packing_layout::<BIT>();\n\n    let base = 2.pow_32(nibble_bits as Field); // 2^nibble_bits\n    let radix = 2.pow_32((nibble_bits + 4) as Field); // 2^(nibble_bits + 4)\n\n    // Number of chunks to emit: ceil(A / group).\n    let num_chunks = (A + group - 1) / group;\n    let mut out = Vec::new();\n\n    // Process in fixed-size chunks of `group` limbs.\n    for chunk in 0..num_chunks {\n        // How many real values go into this chunk.\n        let remain = A - (chunk * group);\n        let take = if remain < group { remain } else { group };\n\n        // Build field element accumulator (big-endian concatenation in `radix`).\n        let mut acc = 0;\n        for i in 0..take {\n            let v = values[chunk * group + i];\n            acc = acc * radix + (v + base);\n        }\n\n        // Pad remaining limb slots with the canonical zero-limb `digit = base`.\n        for _ in 0..(group - take) {\n            acc = acc * radix + base;\n        }\n\n        out.push(acc);\n    }\n    out\n}\n\n/// Computes a cryptographic hash using the SAFE (Sponge API for Field Elements) protocol.\n///\n/// This is a convenience wrapper around the SAFE sponge API that handles the full\n/// lifecycle: initialization, absorption, squeezing, and finalization. It's designed\n/// for use in Fiat-Shamir challenge generation and commitment schemes within zero-knowledge circuits.\n///\n/// # Arguments\n/// * `domain_separator` - A 64-byte domain separator used to differentiate between\n///                        different protocol instances and prevent cross-protocol attacks.\n/// * `inputs` - Vector of field elements to be absorbed into the sponge.\n/// * `io_pattern` - A 2-element array encoding the I/O pattern:\n///                 - `io_pattern[0]`: Encoded ABSORB operation (MSB=1, lower 31 bits = length)\n///                 - `io_pattern[1]`: Encoded SQUEEZE operation (MSB=0, lower 31 bits = length)\n///\n/// # Returns\n/// A vector of field elements squeezed from the sponge, with length determined by\n/// the SQUEEZE operation in the IO pattern.\npub fn compute_safe(\n    domain_separator: [u8; 64],\n    inputs: Vec<Field>,\n    io_pattern: [u32; 2],\n) -> Vec<Field> {\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(inputs);\n    let digests = sponge.squeeze();\n    sponge.finish();\n\n    digests\n}\n\n#[test]\nfn test_flatten() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([1, 2, 3]); // degree 2\n    let poly2 = Polynomial::new([4, -16, 6]); // degree 2\n    let poly3 = Polynomial::new([-7, 8, 9]); // degree 2\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 4>(inputs, polynomials);\n\n    // Verify the flattened coefficients are in the correct positions\n    // Every value shifted 1 nibble incase of negative integers\n    assert(result.get(0) == 0x11121310101010101010101010101010101010101010101010101010101010);\n    assert(result.get(1) == 0x14001610101010101010101010101010101010101010101010101010101010); // -16 became 00 at  0x 14 00 16,\n    assert(result.get(2) == 0x09181910101010101010101010101010101010101010101010101010101010); // -7 became 09 at 0x 09 18 19(16 - 7 = 9)\n}\n\n#[test]\nfn test_flatten_big() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([\n        1791218451968394,\n        21888242871839275222246405745257275088548364400416034343698198265248580087864,\n        21888242871839275222246405745257275088548364400416034343698200542108324633466,\n        5430119342984413,\n        704811298945172,\n        8901715723925099,\n        21888242871839275222246405745257275088548364400416034343698203098124042812559,\n        21888242871839275222246405745257275088548364400416034343698200215091693880034,\n    ]);\n    let poly2 = Polynomial::new([\n        21888242871839275222246405745257275088548364400416034343698200314078269634250,\n        21888242871839275222246405745257275088548364400416034343698200967285641915872,\n        2909990636858607,\n        7896103832076587,\n        2078397209533893,\n        21888242871839275222246405745257275088548364400416034343698199792421452734531,\n        614400389245817,\n        8290314119277588,\n    ]);\n    let poly3 = Polynomial::new([\n        21888242871839275222246405745257275088548364400416034343698201373175279892906,\n        21888242871839275222246405745257275088548364400416034343698201087241869723721,\n        6768789983786188,\n        635797784303388,\n        7610153424227556,\n        4633893206538324,\n        2016269760615332,\n        21888242871839275222246405745257275088548364400416034343698201007080554428142,\n    ]);\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 54>(inputs, polynomials);\n\n    // Verify the flattened coefficients are in the correct positions\n    // Every value shifted 1 nibble incase of negative integers\n\n    // For the first index of result operation goes like this,\n\n    // First four index of poly1\n    // 1791218451968394,\n    // 21888242871839275222246405745257275088548364400416034343698198265248580087864,\n    // 21888242871839275222246405745257275088548364400416034343698200542108324633466,\n    // 5430119342984413,\n\n    // base + 1791218451968394 = 0x1065d1a8b8b718a\n    // base - 5921327228407753 = 0xeaf69591f3b037 (negative coefficient shifted)\n    // base - 3644467483862151 = 0xf30d604a3a9b79 (negative coefficient shifted)\n    // base + 5430119342984413 = 0x1134aaa2e86ccdd\n    assert(result.get(0) == 0x1065d1a8b8b718a0eaf69591f3b0370f30d604a3a9b791134aaa2e86ccdd);\n    assert(result.get(1) == 0x1028105ab1b789411fa010339db66b0fc220f1326bc8e0f1e3f4cc1e02e1);\n    assert(result.get(2) == 0x0f23dfbe7cd76c90f4901299312ddf10a569efe35acef11c0d76f005412b);\n    assert(result.get(3) == 0x107624a8f605dc50f0638a368960421022ecb3cf36b7911d73ff2c27ec14);\n    assert(result.get(4) == 0x0f6013a24e1b9a90f4fd2c158a08481180c2dba8af4cc10242413515171c);\n    assert(result.get(5) == 0x11b0964eb898ce411076805680b85410729c962da53a40f4b44412d0f6ed);\n}\n\n#[test]\nfn test_flatten_small() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([712345, 104857, 999999, 500001, 123, 654321, 77]);\n    let poly2 = Polynomial::new([1, 524287, 888888, 23456, 34567, 765432, 0]);\n    let poly3 = Polynomial::new([444444, 333333, 222222, 111111, 987654, 246810, 13579]);\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 20>(inputs, polynomials);\n\n    assert(result.get(0) == 0x1ade991199991f423f17a12110007b19fbf110004d100000100000100000);\n    assert(result.get(1) == 0x10000117ffff1d9038105ba01087071badf8100000100000100000100000);\n    assert(result.get(2) == 0x16c81c15161513640e11b2071f120613c41a10350b100000100000100000);\n}\n\n#[test]\nfn test_safe_hashing_with_safe_helper() {\n    // Verifies basic hash functionality with a simple ABSORB(3) + SQUEEZE(1) pattern.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice(&[1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let digests1 = compute_safe(domain_separator, elements, io_pattern);\n\n    assert(digests1.len() == 1);\n    assert(digests1.get(0) != 0);\n\n    // Test determinism\n    let digests2 = compute_safe(domain_separator, elements, io_pattern);\n\n    assert(digests2.len() == 1);\n    assert(digests2.get(0) != 0);\n    assert(digests2.get(0) == digests1.get(0));\n}\n\n#[test]\nfn test_pack() {\n    // Test pack function directly with small values\n    let values = [1, 2, 3, 4];\n    let packed = pack::<4, 4>(values);\n\n    // With BIT=4, nibble_bits=4, group should be floor(254/(4+4)) = 31\n    // So all 4 values should fit in one carrier\n    assert(packed.len() >= 1);\n\n    // Test with negative values\n    let values_neg = [-1, 2, -3, 4];\n    let packed_neg = pack::<4, 4>(values_neg);\n    assert(packed_neg.len() >= 1);\n}\n\n#[test]\nfn test_pack_single_value() {\n    // Test packing a single value\n    let values = [42];\n    let packed = pack::<1, 8>(values);\n    assert(packed.len() == 1);\n    assert(packed.get(0) != 0);\n}\n\n#[test]\nfn test_pack_determinism() {\n    // Test that packing is deterministic\n    let values = [10, 20, 30];\n    let packed1 = pack::<3, 8>(values);\n    let packed2 = pack::<3, 8>(values);\n\n    assert(packed1.len() == packed2.len());\n    for i in 0..packed1.len() {\n        assert(packed1.get(i) == packed2.get(i));\n    }\n}\n","path":"enclave/circuits/lib/src/math/helpers.nr"},"82":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse super::modulo::U128::ModU128;\n\n/// Polynomial structure representing a polynomial of degree N-1.\n///\n/// A polynomial P(X) = a_{N-1} * X^{N-1} + a_{N-2} * X^{N-2} + ... + a_1 * X + a_0\n/// is represented as an array of coefficients where coefficients[0] = a_{N-1} (highest degree)\n/// and coefficients[N-1] = a_0 (constant term).\npub struct Polynomial<let N: u32> {\n    /// Array of polynomial coefficients in descending degree order\n    /// coefficients[0] = coefficient of X^{N-1} (highest degree term)\n    /// coefficients[N-1] = constant term (degree 0)\n    pub coefficients: [Field; N],\n}\n\nimpl<let N: u32> Polynomial<N> {\n    /// Creates a new polynomial from an array of coefficients.\n    ///\n    /// # Arguments\n    /// * `coefficients` - Array of N coefficients in descending degree order\n    ///                    coefficients[0] = coefficient of X^{N-1}\n    ///                    coefficients[N-1] = constant term\n    ///\n    /// # Returns\n    /// A new Polynomial instance with the specified coefficients\n    pub fn new(coefficients: [Field; N]) -> Self {\n        Polynomial { coefficients }\n    }\n\n    /// Adds two polynomials.\n    ///\n    /// # Arguments\n    /// * `other` - The polynomial to add to the current polynomial.\n    ///\n    /// # Returns\n    /// A new polynomial with the coefficients added.\n    pub fn add(self, other: Self) -> Self {\n        let mut result = Self::new([0; N]);\n\n        for i in 0..N {\n            result.coefficients[i] = self.coefficients[i] + other.coefficients[i];\n        }\n\n        result\n    }\n\n    /// Subtracts two polynomials.\n    ///\n    /// # Arguments\n    /// * `other` - The polynomial to subtract from the current polynomial.\n    ///\n    /// # Returns\n    /// A new polynomial with the coefficients subtracted.\n    pub fn sub(self, other: Self) -> Self {\n        let mut result = Self::new([0; N]);\n\n        for i in 0..N {\n            result.coefficients[i] = self.coefficients[i] - other.coefficients[i];\n        }\n\n        result\n    }\n\n    /// Multiplies a polynomial by a scalar.\n    ///\n    /// # Arguments\n    /// * `scalar` - The scalar to multiply the polynomial by.\n    ///\n    /// # Returns\n    /// A new polynomial with the coefficients multiplied by the scalar.\n    pub fn mul_scalar(self, scalar: Field) -> Self {\n        let mut result = Self::new([0; N]);\n\n        for i in 0..N {\n            result.coefficients[i] = self.coefficients[i] * scalar;\n        }\n\n        result\n    }\n\n    /// Evaluates the polynomial at a given point using Horner's method.\n    ///\n    /// Horner's method computes P(x) = a_{N-1} * x^{N-1} + ... + a_1 * x + a_0\n    /// as ((...((a_{N-1} * x + a_{N-2}) * x + a_{N-3}) * x + ...) * x + a_0)\n    /// This approach require n multiplications and n additions to evaluate the polynomial.\n    ///\n    /// # Arguments\n    /// * `x` - The point at which to evaluate the polynomial.\n    ///\n    /// # Returns\n    /// The value of the polynomial at point x: P(x).\n    pub fn eval(self, x: Field) -> Field {\n        let mut result = self.coefficients[0];\n\n        for i in 1..self.coefficients.len() {\n            result = result * x + self.coefficients[i];\n        }\n\n        result\n    }\n\n    /// Evaluates the polynomial at a given point with modular reduction.\n    ///\n    /// This function computes `P(x) mod q` using Horner's method with intermediate\n    /// modular reductions to prevent overflow. The result is guaranteed to be in\n    /// the range `[0, q)`.\n    ///\n    /// The function performs modular reduction after each multiplication and addition\n    /// to ensure the accumulator always remains in the range `[0, q)`, preventing\n    /// any potential overflow issues.\n    ///\n    /// # Arguments\n    /// * `x` - The point at which to evaluate the polynomial\n    /// * `q` - The modular arithmetic context containing the modulus\n    ///\n    /// # Returns\n    /// The value `P(x) mod q` in the range `[0, q)`\n    pub fn eval_mod(self, x: Field, q: ModU128) -> Field {\n        let mut acc = self.coefficients[0];\n        let len = self.coefficients.len();\n\n        for i in 1..len {\n            acc = q.mul_mod(acc, x);\n            acc = q.add(acc, self.coefficients[i]);\n        }\n\n        acc\n    }\n\n    /// Performs range checking on polynomial coefficients using asymmetric bounds.\n    ///\n    /// This function constrains all polynomial coefficients to be in the range [-lower_bound, upper_bound],\n    /// where `lower_bound` is a non-negative magnitude.\n    /// It uses a shifting technique to handle negative numbers efficiently:\n    /// 1. Shifts each coefficient by adding `lower_bound`: c' = c + lower_bound\n    /// 2. Checks that shifted coefficients are in [0, upper_bound + lower_bound] using bit-size assertions\n    /// 3. This ensures original coefficients are in [-lower_bound, upper_bound]\n    ///\n    /// The function uses two bit-size checks per coefficient to ensure the value is within bounds:\n    /// - `shifted_coefficient.assert_max_bit_size::<BIT + 1>()` ensures c' >= 0\n    /// - `(range_size - shifted_coefficient).assert_max_bit_size::<BIT + 1>()` ensures c' <= range_size\n    ///\n    /// # Arguments\n    /// * `upper_bound` - The upper bound for coefficient range checking\n    /// * `lower_bound` - Non-negative magnitude of the negative bound\n    ///                   Coefficients must satisfy: -lower_bound <= c <= upper_bound\n    ///\n    /// # Generic Parameters\n    /// * `BIT` - The bit-length of the total range `upper_bound + lower_bound`\n    ///           (choose `BIT` so `upper_bound + lower_bound < 2^BIT`). Since all checked\n    ///           values lie in `[0, upper_bound + lower_bound]`, they cannot exceed `BIT + 1` bits.\n    ///\n    /// # Panics\n    /// This function will cause the circuit to fail if any coefficient is outside\n    /// the specified bounds.\n    pub fn range_check_2bounds<let BIT: u32>(self, upper_bound: Field, lower_bound: Field) {\n        let range_size = lower_bound + upper_bound;\n\n        for i in 0..self.coefficients.len() {\n            let shifted_coefficient = self.coefficients[i] + lower_bound;\n\n            shifted_coefficient.assert_max_bit_size::<BIT + 1>();\n            (range_size - shifted_coefficient).assert_max_bit_size::<BIT + 1>();\n        }\n    }\n\n    /// Performs range checking on polynomial coefficients for the range [0, upper_bound).\n    ///\n    /// This function constrains all polynomial coefficients to be non-negative and\n    /// strictly less than `upper_bound`. It uses bit-size assertions to verify that\n    /// coefficients are in the valid range.\n    ///\n    /// The function performs two checks per coefficient:\n    /// 1. `coeff.assert_max_bit_size::<BIT>()` ensures `coeff >= 0` and `coeff < 2^BIT`\n    /// 2. `(upper_bound - 1 - coeff).assert_max_bit_size::<BIT>()` ensures `coeff < upper_bound`\n    ///\n    /// # Arguments\n    /// * `upper_bound` - The exclusive upper bound for coefficient range checking.\n    ///                   Coefficients must satisfy: `0 <= c < upper_bound`\n    ///\n    /// # Generic Parameters\n    /// * `BIT` - The bit-length parameter. Must satisfy `upper_bound <= 2^BIT` for\n    ///           the range check to work correctly.\n    ///\n    /// # Panics\n    /// This function will cause the circuit to fail if any coefficient is outside\n    /// the range `[0, upper_bound)`.\n    pub fn range_check_standard<let BIT: u32>(self, upper_bound: Field) {\n        for i in 0..self.coefficients.len() {\n            let coeff = self.coefficients[i];\n            // Check coeff >= 0 and coeff < 2^BIT\n            coeff.assert_max_bit_size::<BIT>();\n            // Check coeff <= upper_bound - 1 (i.e., coeff < upper_bound)\n            (upper_bound - 1 - coeff).assert_max_bit_size::<BIT>();\n        }\n    }\n\n    /// Performs range checking on polynomial coefficients for the range [0, 2^BIT).\n    ///\n    /// This is a specialized range check for coefficients that must be non-negative\n    /// and less than a power of two. It's more efficient than `range_check_standard`\n    /// when the upper bound is exactly `2^BIT` because it only needs a single\n    /// bit-size assertion per coefficient.\n    ///\n    /// The function verifies that each coefficient satisfies:\n    /// - `coeff >= 0` (implicit from bit-size check)\n    /// - `coeff < 2^BIT` (enforced by `assert_max_bit_size::<BIT>()`)\n    ///\n    /// # Generic Parameters\n    /// * `BIT` - The bit-length parameter. Coefficients must satisfy: `0 <= c < 2^BIT`\n    ///\n    /// # Panics\n    /// This function will cause the circuit to fail if any coefficient is outside\n    /// the range `[0, 2^BIT)`.\n    pub fn range_check_power_of_two<let BIT: u32>(self) {\n        for i in 0..self.coefficients.len() {\n            self.coefficients[i].assert_max_bit_size::<BIT>();\n        }\n    }\n}\n\n#[test]\nfn test_polynomial_eval() {\n    let coeffs = [1, 2, 3]; // represents 1x^2 + 2x + 3\n    let poly = Polynomial::new(coeffs);\n\n    let x = 2; // evaluate at x = 2\n    let result = poly.eval(x);\n\n    // (1 * 2^2) + (2 * 2) + 3 = 4 + 4 + 3 = 11\n    assert(result == 11);\n}\n\n#[test]\nfn test_polynomial_eval_zero() {\n    let coeffs = [1, -2, 1]; // x^2 - 2x + 1 = (x-1)^2\n    let poly = Polynomial::new(coeffs);\n\n    let x = 1; // evaluate at x = 1, should be 0\n    let result = poly.eval(x);\n\n    assert(result == 0);\n}\n\n#[test]\nfn test_polynomial_bounds() {\n    let coeffs = [-16, 240, 242];\n    let poly = Polynomial::new(coeffs);\n\n    // Test double bounds check - constrains to [-240, 242]\n    poly.range_check_2bounds::<8>(242, 240);\n}\n\n#[test(should_fail_with = \"assert_max_bit_size\")]\nfn test_polynomial_out_of_bounds_coefficients() {\n    let coeffs = [-100];\n    let poly = Polynomial::new(coeffs);\n\n    // Test double bounds check - constrains to [-98, 99]\n    // Should fail because -100 is out of bounds.\n    poly.range_check_2bounds::<7>(99, 98);\n}\n\n#[test]\nfn test_polynomial_add() {\n    let coeffs1 = [1, 2, 3]; // 1x^2 + 2x + 3\n    let coeffs2 = [4, 5, 6]; // 4x^2 + 5x + 6\n    let poly1 = Polynomial::new(coeffs1);\n    let poly2 = Polynomial::new(coeffs2);\n\n    let result = poly1.add(poly2);\n\n    // Expected: (1+4)x^2 + (2+5)x + (3+6) = 5x^2 + 7x + 9\n    assert(result.coefficients[0] == 5);\n    assert(result.coefficients[1] == 7);\n    assert(result.coefficients[2] == 9);\n}\n\n#[test]\nfn test_polynomial_sub() {\n    let coeffs1 = [5, 7, 9]; // 5x^2 + 7x + 9\n    let coeffs2 = [1, 2, 3]; // 1x^2 + 2x + 3\n    let poly1 = Polynomial::new(coeffs1);\n    let poly2 = Polynomial::new(coeffs2);\n\n    let result = poly1.sub(poly2);\n\n    // Expected: (5-1)x^2 + (7-2)x + (9-3) = 4x^2 + 5x + 6\n    assert(result.coefficients[0] == 4);\n    assert(result.coefficients[1] == 5);\n    assert(result.coefficients[2] == 6);\n}\n\n#[test]\nfn test_polynomial_mul_scalar() {\n    let coeffs = [1, 2, 3]; // 1x^2 + 2x + 3\n    let poly = Polynomial::new(coeffs);\n    let scalar = 5;\n\n    let result = poly.mul_scalar(scalar);\n\n    // Expected: 5x^2 + 10x + 15\n    assert(result.coefficients[0] == 5);\n    assert(result.coefficients[1] == 10);\n    assert(result.coefficients[2] == 15);\n}\n\n#[test]\nfn test_polynomial_mul_scalar_zero() {\n    let coeffs = [1, 2, 3];\n    let poly = Polynomial::new(coeffs);\n    let scalar = 0;\n\n    let result = poly.mul_scalar(scalar);\n\n    // Expected: 0x^2 + 0x + 0 = 0\n    assert(result.coefficients[0] == 0);\n    assert(result.coefficients[1] == 0);\n    assert(result.coefficients[2] == 0);\n}\n\n#[test]\nfn test_eval_mod_simple() {\n    // Test without initial reduction - simple case\n    // p(x) = x + 1 at x=5od 7\n    // Expected: (5 + 1) mod 7 = 6\n    let q = ModU128::new(7);\n\n    let poly1 = Polynomial::new([1, 1]);\n    let result1 = poly1.eval_mod(5, q);\n    assert(result1 == 6);\n\n    // Test: p(x) = 2x + 3 at x=5od 7\n    // Expected: (10 + 3) mod 7 = 13 mod 7 = 6\n    let poly2 = Polynomial::new([2, 3]);\n    let result2 = poly2.eval_mod(5, q);\n    assert(result2 == 6);\n}\n\n#[test]\nfn test_eval_mod_degree_2() {\n    // p(x) = x^2 + 2x + 3 at x=5od 7\n    // Using Horner's method: ((1)*5 + 2)*5 + 3 = (5+2)*5 + 3 = 7*5 + 3 = 35 + 3 = 38\n    // 38 mod 7 = 3 (since 38 = 5*7 + 3)\n    let q = ModU128::new(7);\n\n    let poly = Polynomial::new([1, 2, 3]);\n    let result = poly.eval_mod(5, q);\n    assert(result == 3);\n}\n\n#[test]\nfn test_eval_mod() {\n    // Test 1: Simple polynomial x^2 + 2x + 3 at x=5od 7\n    // Expected: (25 + 10 + 3) mod 7 = 38 mod 7 = 3\n    let q = ModU128::new(7);\n\n    let poly1 = Polynomial::new([1, 2, 3]);\n    let result1 = poly1.eval_mod(5, q);\n    assert(result1 == 3);\n\n    // Test 2: Higher degree polynomialod small prime\n    // p(x) = x^3 + x^2 + x + 1 at x=2od 11\n    // Expected: (8 + 4 + 2 + 1) mod 11 = 15 mod 11 = 4\n    let q = ModU128::new(11);\n\n    let poly2 = Polynomial::new([1, 1, 1, 1]);\n    let result2 = poly2.eval_mod(2, q);\n    assert(result2 == 4);\n\n    // Test 3: Polynomial with larger coefficients\n    // p(x) = 100x^2 + 50x + 25 at x=10od 73\n    // Expected: (10000 + 500 + 25) mod 73 = 10525 mod 73 = 13\n    let q = ModU128::new(73);\n\n    let poly3 = Polynomial::new([100, 50, 25]);\n    let result3 = poly3.eval_mod(10, q);\n    assert(result3 == 13);\n\n    // Test 4: Result should be less than modulus\n    let poly4 = Polynomial::new([5, 3, 7]);\n    let q = ModU128::new(17);\n    let result4 = poly4.eval_mod(4, q);\n    assert(result4 as u128 < q.get_mod_field() as u128);\n\n    // Test 5: Compare with regular eval for small values\n    let poly5 = Polynomial::new([1, 2, 1]);\n    let x = 3;\n    let q = ModU128::new(1000);\n    let result5 = poly5.eval_mod(x, q);\n    let expected5 = poly5.eval(x);\n    assert(result5 == expected5);\n\n    // Test 6: Zero polynomial\n    let poly6 = Polynomial::new([0, 0, 0]);\n    let q = ModU128::new(13);\n    let result6 = poly6.eval_mod(100, q);\n    assert(result6 == 0);\n}\n\n#[test]\nfn test_large_party_ids_scenario() {\n    // Simulating party IDs in range [1, 100]\n    let party_id_1 = 42;\n    let party_id_2 = 73;\n    let m = ModU128::new(288230376151711717); // ~58 bits\n\n    // Operations that would be used in Lagrange coefficients\n    let product = m.mul_mod(party_id_1, party_id_2);\n    let diff = m.sub(party_id_2, party_id_1);\n\n    assert(product == 3066);\n    assert(diff == 31);\n}\n\n#[test]\nfn test_eval_vs_eval_mod() {\n    // Compare eval and eval_mod for small values where no reduction should occur\n    let poly = Polynomial::new([1, 2, 3]);\n    let x = 2;\n    let q = ModU128::new(1000); // Large enough that no reduction happens\n\n    let result_normal = poly.eval(x);\n    let result_mod = poly.eval_mod(x, q);\n\n    // They should be equal: (1)*2 + 2)*2 + 3 = (2+2)*2 + 3 = 4*2 + 3 = 11\n    assert(result_normal == 11);\n    assert(result_mod == 11);\n}\n\n#[test]\nfn test_eval_mod_step_by_step() {\n    // p(x) = x + 1 at x=5od 7\n    // Step by step: acc = 1, then acc = 1*5 + 1 = 6\n    let poly = Polynomial::new([1, 1]);\n\n    // Manually compute\n    let mut acc = 1; // coefficients[0]\n    acc = acc * 5 + 1; // = 6\n    assert(acc == 6);\n\n    // Now with reduce_mod\n    let m = ModU128::new(7);\n    let reduced = m.reduce_mod(acc);\n    assert(reduced == 6);\n\n    // Now test the actual function\n    let result = poly.eval_mod(5, m);\n    assert(result == 6);\n}\n","path":"enclave/circuits/lib/src/math/polynomial.nr"},"83":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse keccak256::keccak256;\nuse poseidon::poseidon2_permutation;\n\n/// SAFE (Sponge API for Field Elements)\n///\n/// This module provides a complete implementation of the SAFE API in Noir as defined in:\n/// \"SAFE (Sponge API for Field Elements) - A Toolbox for ZK Hash Applications\"\n/// see https://hackmd.io/bHgsH6mMStCVibM_wYvb2w#22-Sponge-state for more details.\n///\n/// SAFE provides a unified interface for cryptographic sponge functions that can be\n/// instantiated with various permutations to create hash functions, MACs, authenticated\n/// encryption schemes, and other cryptographic primitives for ZK proof systems.\n///\n/// This implementation follows the SAFE specification exactly, providing:\n/// - Complete API: START, ABSORB, SQUEEZE, FINISH operations.\n/// - Full security: Domain separation, tag computation, IO pattern validation.\n/// - Poseidon2 integration: Field-friendly permutation for ZK systems.\n/// - Specification compliance: All operations follow SAFE spec 2.4 exactly.\n/// - Natural API design: Variable-length inputs, automatic length detection from IO patterns.\n///\n/// # API Design\n///\n/// The API is designed for natural usage while maintaining type safety:\n/// - `absorb(input: [Field])`: Accepts variable-length arrays, no padding required.\n/// - `squeeze()`: Returns a vector with field element(s).\n/// - IO patterns automatically determine operation lengths for validation.\n\n/// Rate parameter for the sponge construction (number of field elements that can be absorbed per permutation call).\nglobal RATE: u32 = 3;\n\n/// Capacity parameter for the sponge construction (security parameter, typically 1-2 field elements).\nglobal CAPACITY: u32 = 1;\n\n/// Total state size (rate + capacity) in field elements.\nglobal STATE_SIZE: u32 = RATE + CAPACITY;\n\n/// IO Pattern encoding constants (from SAFE spec 2.3).\n///\n/// These constants are used for encoding operation types in the 32-bit word format:\n/// - MSB set to 1 for ABSORB operations\n/// - MSB set to 0 for SQUEEZE operations\n\n/// Flag for ABSORB operations (MSB = 1)\nglobal ABSORB_FLAG: u32 = 0x80000000;\n\n/// Flag for SQUEEZE operations (MSB = 0)\nglobal SQUEEZE_FLAG: u32 = 0x00000000;\n\n/// SAFE Sponge State (following spec 2.2)\n///\n/// The sponge state consists of the permutation state, tag, position counters,\n/// and IO pattern tracking as defined in the SAFE specification.\n///\n/// # Generic Parameters\n/// - `L`: The length of the IO pattern array\n///\n/// # Fields\n/// - `state`: Permutation state V in F^n (rate + capacity elements)\n/// - `tag`: Parameter tag T used for instance differentiation\n/// - `absorb_pos`: Current absorb position (<= n-c)\n/// - `squeeze_pos`: Current squeeze position (<= n-c)\n/// - `io_pattern`: Expected IO pattern for validation (encoded 32-bit words)\n/// - `io_count`: Current operation count for pattern tracking\npub struct SafeSponge<let L: u32> {\n    /// Permutation state V in F^n (rate + capacity elements).\n    state: [Field; STATE_SIZE],\n    /// Parameter tag T used for instance differentiation.\n    tag: Field,\n    /// Current absorb position (<= n-c).\n    absorb_pos: u32,\n    /// Current squeeze position (<= n-c).\n    squeeze_pos: u32,\n    /// Expected IO pattern for validation.\n    io_pattern: [u32; L],\n    /// Current operation count for pattern tracking (spec 2.4: io_count).\n    io_count: u32,\n}\n\nimpl<let L: u32> SafeSponge<L> {\n    /// Initializes a new SAFE sponge instance with the given IO pattern and domain separator (following spec 2.4).\n    ///\n    /// # Arguments\n    /// - `io_pattern`: Array of 32-bit encoded operations defining the expected sequence of ABSORB/SQUEEZE calls.\n    ///               Each word has MSB=1 for ABSORB operations, MSB=0 for SQUEEZE operations.\n    /// - `domain_separator`: 64-byte domain separator for cross-protocol security.\n    ///\n    /// # Returns\n    /// A new `SafeSponge` instance with initialized state\n    pub fn start(io_pattern: [u32; L], domain_separator: [u8; 64]) -> SafeSponge<L> {\n        // Compute tag from IO pattern and domain separator (spec 2.3).\n        let tag = compute_tag(io_pattern, domain_separator);\n\n        let mut state = [0; STATE_SIZE];\n        // Initialize capacity with tag (spec 2.4).\n        // Add T to the first 128 bits of the state.\n        state[0] = tag;\n\n        SafeSponge { state, tag, absorb_pos: 0, squeeze_pos: 0, io_pattern, io_count: 0 }\n    }\n\n    /// Absorbs field elements into the sponge state, interleaving permutation calls as needed (following spec 2.4).\n    ///\n    /// The number of elements to absorb is automatically validated against the IO pattern.\n    /// This method accepts variable-length arrays, making it natural to use without padding.\n    ///\n    /// # Arguments\n    /// - `input`: Array of field elements to absorb (variable length, must match IO pattern)\n    pub fn absorb(&mut self, input: Vec<Field>) {\n        let length = input.len() as u32;\n\n        // Validate against IO pattern.\n        assert(self.io_count < L);\n\n        // Parse expected operation from io_pattern (encoded word)\n        let expected_encoded_word = self.io_pattern[self.io_count];\n        let is_expected_absorb = (expected_encoded_word & ABSORB_FLAG) != 0;\n        let expected_length = expected_encoded_word & 0x7FFFFFFF;\n\n        // Validate operation type and length\n        assert(is_expected_absorb, \"Expected ABSORB operation\");\n        assert(expected_length == length, \"Length mismatch\");\n\n        // Process each element naturally (no unnecessary iterations).\n        for i in 0..length {\n            // If absorb_pos == (n-c) then permute and reset (spec 2.4).\n            if self.absorb_pos == RATE {\n                // n-c = RATE.\n                self.state = self.permute();\n                self.absorb_pos = 0;\n            }\n\n            // Add X[i] to state at absorb_pos (spec 2.4).\n            // Note: absorb_pos is the rate position, not capacity position.\n            self.state[self.absorb_pos + CAPACITY] =\n                self.state[self.absorb_pos + CAPACITY] + input.get(i);\n            self.absorb_pos += 1;\n        }\n\n        // Verify that the encoded word matches the expected pattern.\n        let encoded_word = ABSORB_FLAG | length;\n        assert(encoded_word == expected_encoded_word);\n\n        self.io_count += 1;\n\n        // Force permute at start of next SQUEEZE (spec 2.4).\n        self.squeeze_pos = RATE;\n    }\n\n    /// Extracts field elements from the sponge state, interleaving permutation calls as needed (following spec 2.4).\n    ///\n    /// The number of elements to squeeze is automatically determined from the IO pattern.\n    pub fn squeeze(&mut self) -> Vec<Field> {\n        // Validate against IO pattern.\n        assert(self.io_count < L);\n\n        // Parse expected operation from io_pattern (encoded word)\n        let expected_encoded_word = self.io_pattern[self.io_count];\n        let is_expected_squeeze = (expected_encoded_word & ABSORB_FLAG) == 0;\n        let length = expected_encoded_word & 0x7FFFFFFF;\n\n        // Validate operation type\n        assert(is_expected_squeeze, \"Expected SQUEEZE operation\");\n\n        let mut output = Vec::new();\n\n        // SQUEEZE implementation following spec 2.4.\n        // If length==0, loop won't execute (spec 2.4).\n        for _ in 0..length {\n            // If squeeze_pos==(n-c) then permute and reset (spec 2.4).\n            if self.squeeze_pos == RATE {\n                // n-c = RATE.\n                self.state = self.permute();\n                self.squeeze_pos = 0;\n                self.absorb_pos = 0;\n            }\n            // Set Y[i] to state element at squeeze_pos (spec 2.4).\n            output.push(self.state[self.squeeze_pos + CAPACITY]);\n            self.squeeze_pos += 1;\n        }\n\n        // Verify that the encoded word matches the expected pattern.\n        let encoded_word = SQUEEZE_FLAG | length;\n        assert(encoded_word == expected_encoded_word);\n\n        self.io_count += 1;\n        output\n    }\n\n    /// Finalizes the sponge instance, verifying that all expected operations have been performed and clearing the internal state for security (following spec 2.4).\n    ///\n    /// This function is used to ensure that the sponge instance has been used correctly and to prevent information leakage.\n    pub fn finish(&mut self) {\n        // Check that io_count equals the length of the IO pattern expected (spec 2.4).\n        assert(self.io_count == L, \"IO pattern not completed\");\n\n        // Erase the state and its variables (spec 2.4).\n        self.state = [0; STATE_SIZE];\n        self.absorb_pos = 0;\n        self.squeeze_pos = 0;\n        self.io_count = 0;\n    }\n\n    /// Permute the state using Poseidon2 (following spec 2.4).\n    ///\n    /// Applies the Poseidon2 permutation to the current state.\n    /// This is the core cryptographic primitive of the sponge construction.\n    ///\n    /// # Returns\n    /// New state after permutation\n    fn permute(self) -> [Field; STATE_SIZE] {\n        poseidon2_permutation(self.state, STATE_SIZE)\n    }\n}\n\n/// Computes a unique tag for a sponge instance based on its IO pattern and domain separator.\n/// The tag is used to ensure that distinct instances behave like distinct functions.\n///\n/// # Arguments\n/// - `io_pattern`: Array of 32-bit encoded operations defining the sponge's usage pattern.\n///               Each word has MSB=1 for ABSORB operations, MSB=0 for SQUEEZE operations.\n/// - `domain_separator`: 64-byte domain separator for cross-protocol security.\n///\n/// # Returns\n/// A field element representing the 128-bit tag.\npub fn compute_tag<let L: u32>(io_pattern: [u32; L], domain_separator: [u8; 64]) -> Field {\n    // Step 1: Parse and aggregate consecutive operations of the same type\n    let mut encoded_words = [0; L]; // Support up to L operations.\n    let mut word_count = 0;\n    let mut current_absorb_sum = 0;\n    let mut current_squeeze_sum = 0;\n    let mut last_was_absorb = false;\n\n    for i in 0..L {\n        if io_pattern[i] > 0 {\n            // Parse operation type from MSB and length from lower 31 bits\n            let is_absorb = (io_pattern[i] & ABSORB_FLAG) != 0;\n            let length = io_pattern[i] & 0x7FFFFFFF; // Clear MSB to get length\n\n            if is_absorb {\n                if last_was_absorb {\n                    // Aggregate consecutive ABSORB operations\n                    current_absorb_sum += length;\n                } else {\n                    // Start new ABSORB sequence\n                    if current_squeeze_sum > 0 {\n                        // Flush previous SQUEEZE sequence\n                        encoded_words[word_count] = SQUEEZE_FLAG | current_squeeze_sum;\n                        word_count += 1;\n                        current_squeeze_sum = 0;\n                    }\n                    current_absorb_sum = length;\n                }\n                last_was_absorb = true;\n            } else {\n                if !last_was_absorb {\n                    // Aggregate consecutive SQUEEZE operations\n                    current_squeeze_sum += length;\n                } else {\n                    // Start new SQUEEZE sequence\n                    if current_absorb_sum > 0 {\n                        // Flush previous ABSORB sequence\n                        encoded_words[word_count] = ABSORB_FLAG | current_absorb_sum;\n                        word_count += 1;\n                        current_absorb_sum = 0;\n                    }\n                    current_squeeze_sum = length;\n                }\n                last_was_absorb = false;\n            }\n        }\n    }\n\n    // Flush remaining operations\n    if current_absorb_sum > 0 {\n        encoded_words[word_count] = ABSORB_FLAG | current_absorb_sum;\n        word_count += 1;\n    }\n    if current_squeeze_sum > 0 {\n        encoded_words[word_count] = SQUEEZE_FLAG | current_squeeze_sum;\n        word_count += 1;\n    }\n\n    // Step 2: Serialize to byte string and append domain separator (following SAFE spec 2.3).\n    // Buffer is 256 bytes: max 192 bytes for IO pattern (48 words) + 64 bytes for domain separator.\n    // Note: We must use a fixed-size array because Noir's keccak256 requires [u8; N], not Vec<u8>.\n    let max_io_pattern_bytes: u32 = 192; // 256 - 64 (domain separator)\n    let io_pattern_bytes = word_count * 4;\n    assert(\n        io_pattern_bytes <= max_io_pattern_bytes,\n        \"IO pattern too large: max 48 aggregated words supported\",\n    );\n\n    let mut input_bytes = [0u8; 256];\n    let mut byte_count: u32 = 0;\n\n    // Serialize encoded words to bytes (big-endian as per SAFE spec).\n    // Note: Noir requires compile-time loop bounds, so we iterate over L (the array size)\n    // instead of word_count (runtime value). The condition `i < word_count` ensures we only\n    // process valid encoded words. This is safe because word_count <= L always holds\n    // (we can have at most L encoded words from L input operations).\n    for i in 0..L {\n        if i < word_count {\n            let word = encoded_words[i];\n            input_bytes[byte_count] = (word >> 24) as u8;\n            input_bytes[byte_count + 1] = (word >> 16) as u8;\n            input_bytes[byte_count + 2] = (word >> 8) as u8;\n            input_bytes[byte_count + 3] = word as u8;\n            byte_count += 4;\n        }\n    }\n\n    // Append full 64-byte domain separator.\n    for i in 0..64 {\n        input_bytes[byte_count] = domain_separator[i];\n        byte_count += 1;\n    }\n\n    // Step 3: Hash with Keccak-256 and truncate to 128 bits.\n    // Note: The SAFE spec uses SHA3-256, but we use Keccak-256 for Noir compatibility.\n    // Keccak-256 differs from SHA3-256 in padding, but both provide equivalent security.\n    let hash_bytes = keccak256(input_bytes, byte_count);\n\n    // Convert first 128 bits (16 bytes) to field element.\n    let mut tag_value: Field = 0;\n    for i in 0..16 {\n        tag_value = tag_value * 256 + (hash_bytes[i] as Field);\n    }\n\n    tag_value\n}\n\n#[test]\nfn test_safe_hashing() {\n    // Verifies basic hash functionality with a simple ABSORB(3) + SQUEEZE(1) pattern.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice(&[1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(elements);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(elements);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_merkle_node() {\n    // Verifies SAFE can be used for Merkle tree node hashing with pattern ABSORB(1) + ABSORB(1) + SQUEEZE(1).\n    // Tests the ability to absorb multiple inputs before squeezing output.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let left = Vec::from_slice([123]);\n    let right = Vec::from_slice([456]);\n\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(left);\n    sponge.absorb(right);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(left);\n    sponge2.absorb(right);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_commitment_scheme() {\n    // Verifies SAFE can be used for commitment schemes with pattern ABSORB(3) + SQUEEZE(1).\n    // Tests the ability to create deterministic commitments from multiple field elements.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let values = Vec::from_slice([10, 20, 30]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(values);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(values);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_domain_separation() {\n    // Verifies that different domain separators produce different outputs for the same input.\n    // This is crucial for cross-protocol security and preventing collisions between different applications.\n    let elements = Vec::from_slice([1, 2, 3]);\n    let domain1 = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let domain2 = [\n        0x41, 0x42, 0x43, 0x45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n\n    let mut sponge1 = SafeSponge::start(io_pattern, domain1);\n    sponge1.absorb(elements);\n    let output1 = sponge1.squeeze();\n    sponge1.finish();\n\n    let mut sponge2 = SafeSponge::start(io_pattern, domain2);\n    sponge2.absorb(elements);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output1.len() == 1);\n    assert(output2.len() == 1);\n    assert(output1.get(0) != output2.get(0)); // Different domain separators should produce different outputs\n}\n\n#[test]\nfn test_multiple_squeeze() {\n    // Verifies that multiple field elements can be squeezed in a single operation.\n    // Tests pattern ABSORB(3) + SQUEEZE(2) to ensure proper state management.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice([1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(2)\n    let io_pattern = [0x80000003, 0x00000002];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(elements);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 2);\n    assert(output.get(0) != 0);\n    assert(output.get(1) != 0);\n    assert(output.get(0) != output.get(1)); // Different squeeze outputs should be different\n}\n\n#[test]\nfn test_zero_length_operations() {\n    // Verifies that zero-length ABSORB and SQUEEZE operations are handled correctly.\n    // Tests pattern ABSORB(0) + SQUEEZE(1) to ensure proper state transitions.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Pattern: ABSORB(0), SQUEEZE(1)\n    let io_pattern = [0x80000000, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(Vec::new());\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n}\n\n#[test]\nfn test_tag_computation() {\n    // Verifies the tag computation algorithm using the example from the SAFE specification.\n    // Pattern: ABSORB(3), ABSORB(3), SQUEEZE(3)\n    // Should aggregate to: ABSORB(6), SQUEEZE(3)\n    // Encoded as: [0x80000006, 0x00000003]\n    // Tests determinism and pattern differentiation.\n\n    let io_pattern = [0x80000003, 0x80000003, 0x00000003];\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test determinism\n    let tag2 = compute_tag(io_pattern, domain_separator);\n    assert(tag == tag2);\n\n    // Test that different patterns produce different tags\n    let io_pattern2 = [0x80000003, 0x00000003]; // ABSORB(3), SQUEEZE(3) - different pattern\n    let tag3 = compute_tag(io_pattern2, domain_separator);\n    assert(tag != tag3);\n}\n\n#[test]\nfn test_tag_computation_debug() {\n    println(\"=== SAFE Tag Computation Debug Test ===\");\n\n    // Test your specific pattern [2, 2, 2] (ABSORB(2), SQUEEZE(2), ABSORB(2))\n    let io_pattern = [0x80000002, 0x00000002, 0x80000002];\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    println(f\"Testing pattern: {io_pattern}\");\n    println(\n        f\"Expected to aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(2)\",\n    );\n    println(\n        f\"Expected encoded words: [0x80000002, 0x00000002, 0x80000002]\",\n    );\n    println(\"\");\n\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    println(f\"=== Expected Rust Output ===\");\n    println(\"Pattern [2, 2, 2] (ABSORB(2), SQUEEZE(2), ABSORB(2))\");\n    println(\"Domain separator: 0x41424344...\");\n    println(\"Tag: 0xce3bb9ee4b2d41c42e9cdda38afe8b6a\");\n    println(\"\");\n\n    println(f\"=== Noir Output ===\");\n    println(f\"Tag: {tag}\");\n    println(\"\");\n\n    println(\"Compare the tag values above with Rust script!\");\n}\n\n#[test]\nfn test_consecutive_absorb_aggregation() {\n    // Test that consecutive ABSORB operations are properly aggregated\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1) should aggregate to ABSORB(2), SQUEEZE(1)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), ABSORB(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001];\n\n    // This should aggregate to: ABSORB(2), SQUEEZE(1) = [0x80000002, 0x00000001]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag ABSORB(2), SQUEEZE(1)\n    let aggregated_pattern = [0x80000002, 0x00000001];\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(tag == aggregated_tag, \"Consecutive ABSORB operations should aggregate to the same tag\");\n\n    // Test that a different pattern produces a different tag\n    let different_pattern = [0x80000001, 0x00000001, 0x80000001]; // ABSORB(1), SQUEEZE(1), ABSORB(1)\n    let different_tag = compute_tag(different_pattern, domain_separator);\n\n    // This should be different because it doesn't have consecutive ABSORB operations\n    assert(tag != different_tag, \"Different patterns should produce different tags\");\n\n    println(\"=== Consecutive ABSORB Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x80000001, 0x00000001] (ABSORB(1), ABSORB(1), SQUEEZE(1))\",\n    );\n    println(\n        f\"Aggregated pattern: [0x80000002, 0x00000001] (ABSORB(2), SQUEEZE(1))\",\n    );\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Different pattern tag: {different_tag}\");\n}\n\n#[test]\nfn test_consecutive_squeeze_aggregation() {\n    // Test that consecutive SQUEEZE operations are properly aggregated\n    // Pattern: ABSORB(1), SQUEEZE(1), SQUEEZE(1) should aggregate to ABSORB(1), SQUEEZE(2)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), SQUEEZE(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x00000001, 0x00000001];\n\n    // This should aggregate to: ABSORB(1), SQUEEZE(2) = [0x80000001, 0x00000002]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag ABSORB(1), SQUEEZE(2)\n    let aggregated_pattern = [0x80000001, 0x00000002];\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(\n        tag == aggregated_tag,\n        \"Consecutive SQUEEZE operations should aggregate to the same tag\",\n    );\n\n    // Test that a different pattern produces a different tag\n    let different_pattern = [0x80000001, 0x00000001, 0x80000001]; // ABSORB(1), SQUEEZE(1), ABSORB(1)\n    let different_tag = compute_tag(different_pattern, domain_separator);\n\n    // This should be different because it doesn't have consecutive SQUEEZE operations\n    assert(tag != different_tag, \"Different patterns should produce different tags\");\n\n    println(\"=== Consecutive SQUEEZE Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x00000001, 0x00000001] (ABSORB(1), SQUEEZE(1), SQUEEZE(1))\",\n    );\n    println(\n        f\"Aggregated pattern: [0x80000001, 0x00000002] (ABSORB(1), SQUEEZE(2))\",\n    );\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Different pattern tag: {different_tag}\");\n}\n\n#[test]\nfn test_mixed_consecutive_aggregation() {\n    // Test that both consecutive ABSORB and SQUEEZE operations are properly aggregated\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1)\n    // Should aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(1)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001, 0x00000001, 0x80000001];\n\n    // This should aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(1) = [0x80000002, 0x00000002, 0x80000001]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag\n    let aggregated_pattern = [0x80000002, 0x00000002, 0x80000001]; // ABSORB(2), SQUEEZE(2), ABSORB(1)\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(tag == aggregated_tag, \"Mixed consecutive operations should aggregate to the same tag\");\n\n    println(\"=== Mixed Consecutive Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x80000001, 0x00000001, 0x00000001, 0x80000001]\",\n    );\n    println(\n        f\"  (ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1))\",\n    );\n    println(f\"Aggregated pattern: [0x80000002, 0x00000002, 0x80000001]\");\n    println(f\"  (ABSORB(2), SQUEEZE(2), ABSORB(1))\");\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n}\n\n#[test]\nfn test_large_io_pattern() {\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Create pattern with 48 alternating ABSORB(1) and SQUEEZE(1) operations\n    // This is the maximum supported (48 words * 4 bytes = 192 bytes, leaving 64 for domain separator)\n    let mut io_pattern = [0u32; 48];\n    for i in 0..48 {\n        if i % 2 == 0 {\n            io_pattern[i] = ABSORB_FLAG | 1; // ABSORB(1)\n        } else {\n            io_pattern[i] = SQUEEZE_FLAG | 1; // SQUEEZE(1)\n        }\n    }\n\n    let tag = compute_tag(io_pattern, domain_separator);\n    assert(tag != 0);\n}\n\n#[test]\nfn test_domain_separator_not_truncated() {\n    // This test verifies that the domain separator is always included in the tag computation,\n    // even for large IO patterns. If the domain separator were truncated, different domain\n    // separators would produce the same tag for large patterns.\n\n    let domain_separator_a = [\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41,\n    ]; // All 'A's\n\n    let domain_separator_b = [\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42,\n    ]; // All 'B's\n\n    // Create pattern with 48 alternating operations (max supported: 192 bytes of IO pattern)\n    let mut io_pattern = [0u32; 48];\n    for i in 0..48 {\n        if i % 2 == 0 {\n            io_pattern[i] = ABSORB_FLAG | 1;\n        } else {\n            io_pattern[i] = SQUEEZE_FLAG | 1;\n        }\n    }\n\n    let tag_a = compute_tag(io_pattern, domain_separator_a);\n    let tag_b = compute_tag(io_pattern, domain_separator_b);\n\n    // Tags MUST be different because domain separators are different.\n    // If they were the same, it would mean the domain separator was truncated/ignored.\n    assert(tag_a != tag_b, \"Domain separator must affect tag even for large IO patterns\");\n}\n","path":"enclave/circuits/lib/src/math/safe.nr"}},"expression_width":{"Bounded":{"width":4}}}