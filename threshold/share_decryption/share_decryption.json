{"noir_version":"1.0.0-beta.15+83245db91dcf63420ef4bcbbd85b98f397fee663","hash":"5855950985937366278","abi":{"parameters":[{"name":"expected_sk_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"expected_e_sm_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"ct0","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":512,"type":{"kind":"field"}}}]}},"visibility":"public"},{"name":"ct1","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":512,"type":{"kind":"field"}}}]}},"visibility":"public"},{"name":"sk","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":512,"type":{"kind":"field"}}}]}},"visibility":"private"},{"name":"e_sm","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":512,"type":{"kind":"field"}}}]}},"visibility":"private"},{"name":"r1","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":1023,"type":{"kind":"field"}}}]}},"visibility":"private"},{"name":"r2","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":511,"type":{"kind":"field"}}}]}},"visibility":"private"},{"name":"d","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"lib::math::polynomial::Polynomial","fields":[{"name":"coefficients","type":{"kind":"array","length":512,"type":{"kind":"field"}}}]}},"visibility":"private"}],"return_type":null,"error_types":{"790736725912586495":{"error_kind":"string","string":"Decryption share computation failed"},"7023503018538476324":{"error_kind":"string","string":"S commitment mismatch"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"13823868475309396004":{"error_kind":"string","string":"E commitment mismatch"}}},"bytecode":"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","debug_symbols":"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D/U+3PdL/T7M5y/92OAfH+zzl35s8I8P8X4p34fzfqneh/t+qd+H+fylHxv844N9/tKPDf7x4X3N/b7mfl9zv6+539fc72vu9zXP+5rnfc3zvuZ5X/O8r3ne1zzva573Nc/7mufzaz4fH+/D59d8Pvx9iPdL+T6c90v1Ptz3S/0+fH7Nxz7eh8+v+Zi/D/F+Kd+H836p3of7fqnfh/c1+/ua/X3N/r5mf1+zv6/Z39fs72v29zX7+5r9fc3xvuZ4X3O8rzne1xzva473Ncf7muN9zfG+5nhfc76vOd/XnO9rzvc15/ua833N+b7mfF9zvq8539d83td83td83td83td83td83td83td83td83td83tdc72uu9zXX+5rfBs/b4HkbPG+D523wvA2et8HzNnjeBs/b4HkbPG+D523wvA2et8HzNnjeBs/b4HkbPG+D523wvA2et8HzNnjeBs/b4HkbPG+D523wvA2et8HzNnjeBs/b4HkbPG+D522w3gbrbbDeButtsN4G622w3gbrbbDeButtsN4G622w3gbrbbDeButtsN4G622w3gbrbbDeButtsN4G622w3gbrbbDeButtsN4G622w3gbrbbDeButtsN4G622w3gbrbbDeButtsN4G622w3gbrbbDeButtsN4G622w3gbrbbDeButtsN4G622w3gbrbbDeButtsN4G622w3gbrbbDeButtsN4G622w3gbrbbDeButtsN4G622w3gbrbbDeButtsN4G622w3gbrbbDeButtsN4G622w3gbrbbDeButtsN4G622w3gbrbbDeButtsN4G622w3gbrbbDeButt8L4N3rfB+zZ43wbv2+B9G7xvg/dt8L4N3rfB+zZ43wbv2+B9G7xvg/dt8L4N3rfB+zZ43wbv2+B9G7xvg/dt8L4N3rfB+zZ43wbv2+B9G7xvg/dt8L4N3rfB+zZ43wbv2+B9G7xvg/dt8L4N3rfB+zZ43wbv2+B9G7xvg/dt8L4N3rfB+zZ43wbv2+B9G7xvg/dt8L4N3rfB+zZ43wbv2+B9G7xvg/dt8L4N3rfB+zZ43wbv2+B9G7xvg/dt8L4N3rfB+zZ43wbv2+B9G7xvg/dt8L4N3rfB+zZ43wbv2+B9G7xvg/dt8L4N3rfB+zZ43wbv2+B9G7xvg/dt8L4N3rfB+zZ43wb7bbDfBvtt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D+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcD+d4OMfDOR7O8XCOh3M8nOPhHA/neDjHwzkezvFwjodzPJzj4RwP53g4x8M5Hs7xcI6Hczyc4+EcDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u8HCBhws8XODhAg8XeLjAwwUeLvBwgYcLPFzg4QIPF3i4wMMFHi7wcIGHCzxc4OECDxd4uMDDBR4u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ebLzZOfJzpOdJztPdp7sPNl5svNk58nOk50nO092nuw82Xmy82Tnyc6TnSc7T3ae7DzZebLzZOfJzpOdJztPdp7sPNl5svNk58nOk50nO092nuw82Xmy82Tnyc6TnSc7T3ae7DzZebLzZOfJzpOdJztPdp7s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84POz/s/LDzw84PO8fDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx083MHDHTzcwcMdPNzBwx08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wsMVHq7wcIWHKzxc4eEKD1d4uMLDFR6u8HCFhys8XOHhCg9XeLjCwxUervBwhYcrPFzh4QoPV3i4wsMVHq7wcIWHKzxc4eEKD1d4uOK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1OK+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pV7uS73cl3q5L/VyX+rlvtTLfamX+1Iv96Ve7ku93Jd6uS/1cl/q5b7Uy32pl/tSL/elXu5LvdyXerkv9XJf6uW+1Mt9qZf7Ui/3pd7Dzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sPPDzg87P+z8sHM83MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzcxcNdPNzFw1083MXDXTzc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wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzzc4OEGDzd4uMHDDR5u8HCDhxs83ODhBg83eLjBww0ebvBwg4cbPNzg4QYPN3i4wcMNHm7wcIOHGzycfQDifnz8PMmPj66Pob8h9fHobyh9vPobWh+Hv+FN/sdH4294o//xMfQ3pD4e/Q2lj1d/Q+ujzuY6m+tsrrO5zuY6m+tsrrO5zuY6m+tsobOFzhY6W+hsobOFzhY6W+hsobOFzpY6W+psqbOlzpY6W+psqbOlzpY6W+psR2c7OtvR2Y7OdnS2o7Mdne3obEdnOzpb6Wyls5XOVjpb6Wyls5XOVjpb6Wyls12d7epsV2e7OtvV2a7OdnW2q7Ndne3qbK2ztc7WOlvrbK2ztc7WOlvrbK2ztc42OtvobKOzjc42OtvobKOzjc42OptaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlphaYmqJqSWmlpha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrha4mqJqyWulrhaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRaEmpJqCWhloRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRakmpJqiWplqRactSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSakmpJaWWlFpSasnvhvPGHx9dH397260/PqY+Hv0NpY9Xf0Pr47y/4XfM+T7a+xt+55zvY+hvSH08+htKH6/+htbH4W/40ZL3kbP9Djvfx9DfkPp49DeUPl79Da2POpvrbK6zuc7mOpvrbK6zuc7mOpvrbK6zhc4WOlvobKGzhc4WOlvobKGzhc4WOlvqbKmzpc6WOlvqbKmzpc6WOlvqbKmzHZ3t6GxHZzs629HZjs52dLajsx2d7ehspbOVzlY6W+lspbOVzlY6W+lspbOVznZ1tquzXZ3t6mxXZ7s629XZrs52dbars7XO1jpb62yts7XO1jpb62yts7XO1jrb6GxqyVVLrlpy1ZKrlly15KolVy25akmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSakmrJa2WtFrSasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoyasmoJaOWjFoytMQ+aIl90BL7oCX2QUvsg5bYBy2xD1piH7TEPmiJfdAS+6Al9kFL7IOW2ActsQ9aYh+0xD5oiX3QEvugJfZhOpvrbK6zuc7mOpvrbK6zuc7mOpvrbK6zhc4WOlvobKGzhc4WOlvobKGzhc4WOlvqbKmzpc6WOlvqbKmzpc6WOlvqbKmzHZ3t6GxHZzs629HZjs52dLajsx2d7ehspbOVzlY6W+lspbOVzlY6W+lspbOVznZ1tquzXZ3t6mxXZ7s629XZrs52dbars7XO1jpb62yts7XO1jpb62yts7XO1jrb6Gyjs43ONjrb6Gyjs43ONjrb6GxqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaklppaYWmJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqiaslrpa4WuJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSagloZaEWhJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqSaolqZakWpJqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlhy15KglRy05aslRS45actSSo5YcteSoJUctOWrJUUuOWnLUkqOWHLXkqCVHLTlqyVFLjlpy1JKjlpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSWllpRaUmpJqSVyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvJvdqcq8m92pyryb3anKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq8u9+pyry736nKvLvfqcq+/fdTZ1BK5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVeXe3W5V5d7dblXl3t1uVf/3b3+9pc/Ptf6fNfnXp9Hn38Ehc+2Pvv6HOtzrs/rvbnem+u9ud6b671nvfes95713rPee9Z7z3rvWe89671nvfes99Z6b6331npvrffWem+t99Z6b6331npvrffe9d673nvXe+96713vveu9d733rvfe9d673tvrvb3e2+u9vd7b67293tvrvb3e2+u9vd47672z3jvrvbPeO+u9s947672z3jvrvaP3/g5n+Wzrs6/PsT7n+nzW51qf7/rc6/N6r6332nqvrffaeq+t99p6r6332nqvrffaeq+v9/p6r6/3+nqvr/f6eq+v9/p6r6/3+npvrPfGem+s98Z6b6z3rl716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9e9epVr1716lWvXvXqVa9ezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWsXs3q1axezerVrF7N6tWoV/GhXsWHehUf6lV8qFfxoV7Fh3oVH+pVfKhX8aFexcfHeq+t99p6r6332nqvrffaeq+t99p6r6332nqvr/f6eq+v9/p6r6/3+nqvr/f6eq+v9/p6b6z3xnpvrPfGem+s98Z6b6z3xnpvrPfGem+u9+Z6b6735npvrvfmem+u9+Z6b6735nrvWe89671nvfes95713rPee9Z7z3rvWe8967213lvrvbXeW+u9td5b67213lvrvbXeW+u9d733rvfe9d673nvXe+96713vveu9d733rvf2em+v9/Z6b6/39npvr/f2em+v9/Z6b6/3znrvrPfOeu+s985676z3znrvrPfOeu/qla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWtXtnqla1e2eqVrV7Z6pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+eqVr1756pWvXvnqla9e+epVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVaxexepVrF7F6lWsXsXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6lWuXuXqVa5e5epVrl7l6tVZvTqrV2f16qxendWrs3p1Vq/O6tVZvTqrV2f16qxendWrs3p1Vq/O6tVZvTqrV2f16qxendWrs3p1Vq/O6tVZvTqrV2f16qxendWrs3p1Vq/O6tVZvTqrV2f16qxendWrs3p1Vq/O6tVZvTqrV2f16qxendWrs3p1Vq/O6tVZvTqrV2f16qxendWrs3p1Vq/O6tVZvTqrV2f16qxendWrs3p1Vq/O6tVZvTqrV2f16qxendWrs3p1Vq/O6tVZvTqrV2f16qxendWrs3p1Vq/O6tVZvTqrV2f16qxendWrs3p1Vq/O6tVZvTqrV2f16qxendWrs3p1Vq/O6tVZvTqrV2f16qxe1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXtXqVa1e1epVrV7V6lWtXt3Vq7t6dVev7urVXb26q1d39equXt3Vq7t6dVev7urVXb26q1d39equXt3Vq7t6dVev7urVXb26q1d39equXt3Vq7t6dVev7urVXb26q1d39equXt3Vq7t6dVevlm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm+P5dtj+fZYvj2Wb4/l22P59li+PZZvj+XbY/n2WL49lm/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+PZdvz+Xbc/n2XL49l2/P5dtz+fZcvj2Xb8/l23P59ly+/bfP672rV8u35/LtuXx7Lt+ey7fn8u25fHsu357Lt+fy7bl8ey7fnsu35/LtuXx7Lt+ey7fn8u25fHsu357Lt+fy7bl8ey7fnsu35/LtuXx7Lt+ey7fn8u25fHsu357Lt+fy7bl8ey7fnsu35/LtuXx7Lt+ey7fn8u25fHsu357Lt+fy7bl8ey7fnsu35/LtuXx7Lt+ey7fn8u25fHsu357Lt+fy7bl8ey7fnsu35/LtuXx7Lt+ey7fn8u25fHsu357Lt+cfvj3yj8/D5z98+/v8473Rf3z29TnW51yfz/pc6/Ndn3t9/vHetN8//96r99nWZ1+fY33O9fmsz7U+3/W51+f1Xl/v9fVeX+/19V5f7/X1Xl/v9fVeX+/19d5Y74313ljvjfXeWO+N9d5Y74313ljvjfXeXO/N9d5c78313lzvzfXeXO/N9d5c78313rPee9Z7z3rvWe89671nvfes95713rPee9Z7a7231ntrvbfWe2u9t9Z7a7231ntrvbfWe+96713vveu9d733rvfe9d673nvXe+96713v7fXeXu/t9d5e7+313l7v7fXeXu/t9d5e75313lnvnfXeWe+d9d5Z75313lnvnfXe0Xv/8O3vs63Pvj7H+pzr81mfa32+63Ovz+u9q1exehWrV7F6FatXsXoVq1exehWrV7F6FatXsXoVq1exehWrV7F6FatXsXoVq1exehWrV7F6FatXsXoVq1exehWrV7F6FatXsXoVq1exehWrV7F6FatXsXoVq1exehWrV7F6FatXsXoVq1exehWrV7F6FatXsXoVq1exehWrV7F6FatXsXoVq1exehWrV7F6FatXsXoVq1exehWrV7F6FatXsXoVq1exehWrV7F6FatXsXoVq1exehWrV7F6FatXsXoVq1exehWrV7F6FatXsXoVq1exehWrV7F6FatXsXqVq1e5epWrV7l6latXuXqVq1e5epWrV7l6latXuXqVq1e5epWrV7l6latXuXqVq1e5epWrV7l6latXuXqVq1e5epWrV7l6latXuXqVq1e5epWrV7l6latXuXqVq1e5epWrV7l6latXuXqVq1e5epWrV7l6latXuXqVq1e5epWrV7l6latXuXqVq1e5epWrV7l6latXuXqVq1e5epWrV7l6latXuXqVq1e5epWrV7l6latXuXqVq1e5epWrV7l6latXuXqVq1e5epWrV7l6latXuXqVq1e5epWrV7l6latXuXqVq1e5epWrV7l6latXuXqVq1e5epWrV7l6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1dn9eqsXp3Vq7N6dVavzurVWb06q1e1elWrV7V6VatXtXpVq1e1elWrV7V6VatXtXpVq1e1elWrV7V6VatXtXpVq1e1elWrV7V6VatXtXpVq1e1elWrV7V6VatXtXpVq1e1elWrV7V6VatXtXpVq1e1elWrV7V6VatXtXpVq1e1elWrV7V6VatXtXpVq1e1elWrV7V6VatXtXpVq1e1elWrV7V6VatXtXpVq1e1elWrV7V6VatXtXpVq1e1elWrV7V6VatXtXpVq1e1elWrV7V6VatXtXpVq1e1elWrV7V6VatXtXpVq1e1elWrV7V6VatXtXpVq1e1elWrV7V6VatXtXpVq1e1elWrV7V6VatXd/Xqrl7d1au7enVXr+7q1V29uqtXd/Xqrl7d1au7enVXr+7q1V29uqtXd/Xqrl7d1as/fHv+/t8U/vDt77Otz74+x/qc6/NZn2t9vutzr8/rvbHeG+u9sd4b672x3hvrvbHeG+u9sd4b67253pvrvbnem+u9ud6b67253pvrvbnem+u9Z733rPee9d6z3nvWe89671nvPeu9Z733rPfWem+t99Z6b6331npvrffWem+t99Z6b6333vXeu95713vveu9d773rvXe996733vXeu97b67293tvrvb3e2+u9vd7b67293tvrvb3eO+u9s947672z3jvrvbPeO+u9s947672j9/7h299nW599fY71Odfnsz7X+nzX516f13ttvdfWe22919Z7bb3X1nttvdfWe229d/WqV6969apXr3r1qlevevWqV6969apXr3r1qlevevWqV6969apXr3r1qlevevWqV6969apXr3r1qlevevWqV6969apXr3r1qlevevWqV6969apXr3r1qlevevWqV6969apXr3r1qlevevWqV6969apXr3r1qlevevWqV6969apXr3r1qlevevWqV6969apXr3r1qlevevWqV6969apXr3r1qlevevWqV6969apXr3r1qlevevWqV6969apXr3r1qlevevWqV6969WpWr2b1alavZvVqVq9m9WpWr2b1alavZvVqVq9m9WpWr2b1alavZvVqVq9m9WpWr2b1alavZvVqVq9m9WpWr2b1alavZvVqVq9m9WpWr2b1alavZvVqVq9m9WpWr2b1alavZvVqVq9m9WpWr2b1alavZvVqVq9m9WpWr2b1alavZvVqVq9m9WpWr2b1alavZvVqVq9m9WpWr2b1alavZvVqVq9m9WpWr2b1alavZvVqVq9m9WpWr2b1alavZvVqVq9m9WpWr2b1alavZvVqVq9m9WpWr2b1alavZvVqVq9m9WpWr2b1alavZvVqVq9m9WpWr2b1alavRr06H+rV+VCvzod6dT7Uq/OhXp0P9ep8qFfnQ736/5q6l5XZuuQ8o/eithsZMeMwp+/FCEmWTUEhibJkMEb3btf/7V05eu9iZfL0Ritg9efrVX8+dINu0A26QTfoBt2gG3SDbtBNukk36SbdpJt0k27STbpJ99A9dA/dQ/fQPXQP3UP30D10i27RLbpFt+gW3aJbdItu0W26TbfpNt2m23SbbtNtuk136A7doTt0h+7QHbpDd+gO3aW7dJfu0l26S3fpLt2lu3Qv3Uv30r10L91L99K9dC/dS/fRfXQf3Uf30X10H91H99HFq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8Cr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Gq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18erh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1fv69V+vl7t5+vVfr5e7efr1X6+Xu3n69V+vl7t5+vVfr5e7edDN+gG3aAbdINu0A26QTfoBt2km3STbtJNukk36SbdpJt0D91D99A9dA/dQ/fQPXQP3UO36Bbdolt0i27RLbpFt+gW3abbdJtu0226TbfpNt2m23SH7tAdukN36A7doTt0h+7QXbpLd+ku3aW7dJfu0l26S/fSvXQv3Uv30r10L91L99K9dB/dR/fRfXQf3Uf30X10H128CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvOK+fblvX+7bl/v25b59uW9f7tuX+/blvn25b1/u25f79uW+fblvX+7bl/v25b59uW9f7tuX+/blvn1/3bfPzw52sg+72M0e9rIv+333pXvpXrqX7qV76V66l+6le+k+uo/uo/voPrqP7qP76D6679v9dd/+awc72Ydd7GYPe9mXTTfoBt2gG3SDbtANukE36AbdpJt0k27STbpJN+km3aSbdA/dQ/fQPXQP3UP30D10D91Dt+gW3aJbdItu0S26RbfoFt2m23SbbtNtuk236Tbdptt0h+7QHbpDd+gO3aE7dIfu0MWrg1cHrw5eHbw6eHXw6uDVwauDVwevDl4dvDp4dfDq4NXBq4NXB68OXh28Onh18Org1cGrg1cHrw5eHbw6eFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41Xg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV49eu+/f6xf7z6tf/anfjZyf5rd37++4dXv3ezh73sy37f/YdXv3ewk0330X10H91H99F93+7PffvvHexkH3axmz3sZV823aAbdINu0A26QTfoBt2gG3STbtJNukk36SbdpJt0k27SPXQP3UP30D10D91D99A9dA/dolt0i27RLbpFt+gW3aJbdJtu0226TbfpNt2m23SbbtMdukN36A7doTt0h+7QHbpDd+ku3aW7dJfu0l26S3fpLt1L99K9dPHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHV+/r1f18vbqfr1f38/Xqfr5e3c/Xq/v5enU/X6/u5+vV/Xy9up8P3aAbdINu0A26QTfoBt2gG3STbtJNukk36SbdpJt0k27SPXQP3UP30D10D91D99A9dA/dolt0i27RLbpFt+gW3aJbdJtu0226TbfpNt2m23SbbtMdukN36A7doTt0h+7QHbpDd+ku3aW7dJfu0l26S3fpLt1L99K9dC/dS/fSvXQv3Uv30n10H91H99F9dB/dR/fRfXTxKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvEq8SrxKvHq57597s/+a7fiZzd72Mu+7Pe3/XPf/nsHO9mHXexmD3vZl0036AbdoBt0g27QDbpBN+gG3aSbdJNu0k26STfpJt2km3QP3UP30D10D91D99A9dA/dQ7foFt2iW3SLbtEtukW36Bbdptt0m27TbbpNt+k23abbdIfu0B26Q3foDt2hO3SH7tBdukt36S7dpbt0l+7SXbpL99K9dC/dS/fSvXQv3Uv30r10H91H99F9dPHq4NXBq4NXB68OXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeFV4VXhVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV41XjVeNV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXg1eDV4NXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eLV4tXi1eXby6eHXx6uLVz3171c9u9rCXfdnvu3+8+rWDnezDpht0g27QDbpBN+km3aSbdJNu0k26STfpJt1D99A9dA/dQ/fQPXQP3UP30C26RbfoFt2iW3SLbtEtukW36Tbdptt0m27TbbpNt+k23aE7dIfu0B26Q3foDt2hO3SX7tJdukt36S7dpbt0l+7SvXQv3Uv30r10L91L99K9dC/dR/fRfXQf3Uf30X10H91H9327P/ftv3ewk33YxW72sJd92XTx6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Op9vXqfr1fv8/Xqfb5evc/Xq/f5evU+X6/e5+vV+3y9ep+vV+/zoRt0g27QDbpBN+gG3aAbdINu0k26STfpJt2km3STbtJNuofuoXvoHrqH7qF76B66h+6hW3SLbtEtukW36Bbdolt0i27TbbpNt+k23abbdJtu0226Q3foDt2hO3SH7tAdukN36C7dpbt0l+7SXbpLd+ku3aV76V66l+6le+leupfupXvpXrqP7qP76D66j+6j++g+uo8uXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeBV4FXgVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4lXiVeJV4dvDp4dfDq4NXBq4NXB68OXh28Onh18Org1cGrg1e/7tv3Zzd72Mu+7PfdP1792sFO9mHTTbpJN+km3aR76B66h+6he+geuofuoXvoHrpFt+gW3aJbdItu0S26RbfoNt2m23SbbtNtuk236Tbdpjt0h+7QHbpDd+gO3aE7dIfu0l26S3fpLt2lu3SX7tJdupfupXvpXrqX7qV76V66l+6l++g+uo/uo/voPrqP7qP76L5v99d9+68d7GQfdrGbPexlXzbdoBt0g27QxavCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8KrwqvCq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arxqvGq8arwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavBq8GrwavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavF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Fq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavFq8WrxavLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4tXFq4tXF68uXl28unh18eri1cWri1cXry5eXby6eHXx6uLVxauLVxevLl5dvLp4dfHq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dXD68eXj28enj18Orh1cOrh1cPrx5ePbx6ePXw6uHVw6uHVw+vHl49vHp49fDq4dXDq4dX7+tVfL5exefrVXy+XsXn61V8vl7F5+tVfL5exefrVXy+XsXnQzfoBt2gG3SDbtANukE36AbdpJt0k27STbpJN+km3aSbdA/dQ/fQPXQP3UP30D10D91Dt+gW3aJbdItu0S26RbfoFt2m23SbbtNtuk236Tbdptt0h+7QHbpDd+gO3aE7dIfu0F26S3fpLt2lu3SX7tJdukv30r10L91L99K9dC/dS/fSvXQf3Uf30X10H91H99F9dB9dvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8CrwKvAq8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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse lib::configs::default::threshold::{\n    L, N, THRESHOLD_SHARE_DECRYPTION_BIT_CT, THRESHOLD_SHARE_DECRYPTION_BIT_D,\n    THRESHOLD_SHARE_DECRYPTION_BIT_E_SM, THRESHOLD_SHARE_DECRYPTION_BIT_R1,\n    THRESHOLD_SHARE_DECRYPTION_BIT_R2, THRESHOLD_SHARE_DECRYPTION_BIT_SK,\n    THRESHOLD_SHARE_DECRYPTION_CONFIGS,\n};\nuse lib::core::threshold::share_decryption::ShareDecryption;\nuse lib::math::polynomial::Polynomial;\n\nfn main(\n    expected_sk_commitment: pub Field,\n    expected_e_sm_commitment: pub Field,\n    ct0: pub [Polynomial<N>; L],\n    ct1: pub [Polynomial<N>; L],\n    sk: [Polynomial<N>; L],\n    e_sm: [Polynomial<N>; L],\n    r1: [Polynomial<(2 * N) - 1>; L],\n    r2: [Polynomial<N - 1>; L],\n    d: [Polynomial<N>; L],\n) {\n    let share_decryption: ShareDecryption<N, L, THRESHOLD_SHARE_DECRYPTION_BIT_CT, THRESHOLD_SHARE_DECRYPTION_BIT_SK, THRESHOLD_SHARE_DECRYPTION_BIT_E_SM, THRESHOLD_SHARE_DECRYPTION_BIT_R1, THRESHOLD_SHARE_DECRYPTION_BIT_R2, THRESHOLD_SHARE_DECRYPTION_BIT_D> = ShareDecryption::new(\n        THRESHOLD_SHARE_DECRYPTION_CONFIGS,\n        expected_sk_commitment,\n        expected_e_sm_commitment,\n        ct0,\n        ct1,\n        sk,\n        e_sm,\n        r1,\n        r2,\n        d,\n    );\n    share_decryption.execute()\n}\n","path":"enclave/circuits/bin/threshold/share_decryption/src/main.nr"},"71":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse crate::math::commitments::{\n    compute_aggregated_shares_commitment, compute_threshold_share_decryption_challenge,\n};\nuse crate::math::helpers::flatten;\nuse crate::math::polynomial::Polynomial;\n\n/// Cryptographic parameters for Threshold decryption share circuit.\npub struct Configs<let L: u32> {\n    /// CRT moduli: [q_0, q_1, ..., q_{L-1}]\n    pub qis: [Field; L],\n    /// Bounds for r1 polynomials (modulus switching quotients) for each CRT basis\n    pub r1_bounds: [Field; L],\n    /// Bounds for r2 polynomials (cyclotomic reduction quotients) for each CRT basis\n    pub r2_bounds: [Field; L],\n}\n\nimpl<let L: u32> Configs<L> {\n    pub fn new(qis: [Field; L], r1_bounds: [Field; L], r2_bounds: [Field; L]) -> Self {\n        Configs { qis, r1_bounds, r2_bounds }\n    }\n}\n\n/// Threshold Share Decryption (Circuit 6).\n///\n/// Verifies:\n/// 1. Commitment to sk matches expected (from DKG decryption circuit)\n/// 2. Commitment to e_sm matches expected (from DKG decryption circuit)\n/// 3. Correct computation: d_i = c_0i + c_1i * s_i + e_i + r_2i * (X^N + 1) + r_1i * q_i\npub struct ShareDecryption<let N: u32, let L: u32, let BIT_CT: u32, let BIT_SK: u32, let BIT_E_SM: u32, let BIT_R1: u32, let BIT_R2: u32, let BIT_D: u32> {\n    /// Circuit parameters including bounds and cryptographic constants\n    configs: Configs<L>,\n\n    /// Expected commitment to aggregated sk shares (from DKG decryption circuit)\n    /// (public witness)\n    expected_sk_commitment: Field,\n\n    /// Expected commitment to aggregated e_sm shares (from DKG decryption circuit)\n    /// (public witness)\n    expected_e_sm_commitment: Field,\n\n    /// Ciphertext components (public witnesses)\n    /// ct0 components for each CRT basis (degree N-1 polynomials with N coefficients)\n    ct0: [Polynomial<N>; L],\n    /// ct1 components for each CRT basis (degree N-1 polynomials with N coefficients)\n    ct1: [Polynomial<N>; L],\n\n    /// Aggregated sum of sk shares (secret witness)\n    sk: [Polynomial<N>; L],\n\n    /// Aggregated sum of e_sm shares (secret witness, direct input)\n    /// e_sm[basis] - sum of e_sm shares for each CRT basis (degree N-1 with N coefficients)\n    e_sm: [Polynomial<N>; L],\n\n    /// Quotient polynomials for lifting to Z (secret witnesses)\n    r1: [Polynomial<2 * N - 1>; L],\n    r2: [Polynomial<N - 1>; L],\n\n    /// Party's computed decryption share\n    /// (public witnesses)\n    d: [Polynomial<N>; L],\n}\n\nimpl<let N: u32, let L: u32, let BIT_CT: u32, let BIT_SK: u32, let BIT_E_SM: u32, let BIT_R1: u32, let BIT_R2: u32, let BIT_D: u32> ShareDecryption<N, L, BIT_CT, BIT_SK, BIT_E_SM, BIT_R1, BIT_R2, BIT_D> {\n    pub fn new(\n        configs: Configs<L>,\n        expected_sk_commitment: Field,\n        expected_e_sm_commitment: Field,\n        ct0: [Polynomial<N>; L],\n        ct1: [Polynomial<N>; L],\n        sk: [Polynomial<N>; L],\n        e_sm: [Polynomial<N>; L],\n        r1: [Polynomial<2 * N - 1>; L],\n        r2: [Polynomial<N - 1>; L],\n        d: [Polynomial<N>; L],\n    ) -> Self {\n        ShareDecryption {\n            configs,\n            expected_sk_commitment,\n            expected_e_sm_commitment,\n            ct0,\n            ct1,\n            sk,\n            e_sm,\n            r1,\n            r2,\n            d,\n        }\n    }\n\n    /// Verifies that aggregated secret shares hash to expected_sk_commitment\n    fn verify_agg_sk_commitment(self) {\n        assert(\n            compute_aggregated_shares_commitment::<N, L, BIT_SK>(self.sk)\n                == self.expected_sk_commitment,\n            \"S commitment mismatch\",\n        );\n    }\n\n    /// Verifies that aggregated noise shares hash to expected_e_sm_commitment\n    fn verify_agg_e_sm_commitment(self) {\n        assert(\n            compute_aggregated_shares_commitment::<N, L, BIT_E_SM>(self.e_sm)\n                == self.expected_e_sm_commitment,\n            \"E commitment mismatch\",\n        );\n    }\n\n    /// Flattens all witness data into a single array for Fiat-Shamir challenge generation.\n    ///\n    /// This function serializes all polynomial coefficients (both public inputs and\n    /// secret witnesses) into a 1D array in a deterministic order. The flattened data\n    /// is used to generate the Fiat-Shamir challenge via the SAFE sponge API.\n    ///\n    /// The order of serialization is:\n    /// 1. Commitment to aggregated secret shares `sk` (expected_sk_commitment)\n    /// 2. Commitment to aggregated noise shares `e_sm` (expected_e_sm_commitment)\n    /// 3. Ciphertext components `c_0` for each CRT basis (serialized coefficients)\n    /// 4. Ciphertext components `c_1` for each CRT basis (serialized coefficients)\n    /// 5. Quotient polynomials `r_1` for each CRT basis (serialized coefficients)\n    /// 6. Quotient polynomials `r_2` for each CRT basis (serialized coefficients)\n    /// 7. Decryption shares `d` for each CRT basis (serialized coefficients)\n    ///\n    /// Note: Aggregated secret shares `sk` and noise shares `e_sm` are represented by their\n    /// commitments rather than serialized coefficients. This saves constraints while\n    /// still binding them to the transcript.\n    ///\n    /// # Returns\n    /// A vector containing commitments and polynomial coefficients in flattened form,\n    /// ready for hashing to generate the Fiat-Shamir challenge.\n    fn payload(self) -> Vec<Field> {\n        let mut inputs = Vec::new();\n\n        // Use commitments instead of full polynomials (saves constraints)\n        inputs.push(self.expected_sk_commitment);\n        inputs.push(self.expected_e_sm_commitment);\n\n        // Flatten ciphertext components (public inputs)\n        inputs = flatten::<_, _, BIT_CT>(inputs, self.ct0);\n        inputs = flatten::<_, _, BIT_CT>(inputs, self.ct1);\n\n        // Flatten quotient polynomials (secret witnesses)\n        inputs = flatten::<_, _, BIT_R1>(inputs, self.r1);\n        inputs = flatten::<_, _, BIT_R2>(inputs, self.r2);\n\n        // Flatten decryption shares (public outputs)\n        inputs = flatten::<_, _, BIT_D>(inputs, self.d);\n\n        inputs\n    }\n\n    /// Main verification function\n    pub fn execute(self) {\n        // Step 1: Verify sk commitment matches expected\n        self.verify_agg_sk_commitment();\n\n        // Step 2: Verify e_sm commitment matches expected\n        self.verify_agg_e_sm_commitment();\n\n        // Step 3: Perform range checks on quotient polynomials\n        // Note: sk and e_sm range checks are handled by commitment verification\n        // (the DKG decryption circuit already performed range checks on these values)\n        self.check_range_bounds();\n\n        // Step 4: Generate Fiat-Shamir challenge from the transcript\n        let gamma = self.generate_challenge();\n\n        // Step 5: Verify decryption share computation for each CRT basis\n        for i in 0..L {\n            self.verify_decryption_share_computation(i, gamma);\n        }\n    }\n\n    /// Performs range checks on quotient polynomial witnesses.\n    ///\n    /// This function constrains quotient polynomials to be within their expected bounds\n    /// as specified in the `configs`. This is critical for security because it prevents\n    /// attacks where malicious provers provide out-of-range values that could break the\n    /// security properties of the Threshold scheme.\n    ///\n    /// Note: Range checks on `sk` and `e_sm` are NOT performed here because:\n    /// - Their commitments are verified against expected values from the DKG circuit\n    /// - The DKG decryption circuit already performed range checks on these values\n    /// - Commitment binding ensures the values match what was previously verified\n    ///\n    /// # Panics\n    /// This function will cause the circuit to fail if any quotient coefficient is\n    /// outside its expected bounds.\n    fn check_range_bounds(self) {\n        // Check quotient polynomials are within bounds\n        for basis_idx in 0..L {\n            // r_1 quotients can be negative (modulus quotients)\n            self.r1[basis_idx].range_check_2bounds::<BIT_R1>(\n                self.configs.r1_bounds[basis_idx],\n                self.configs.r1_bounds[basis_idx],\n            );\n            // r_2 quotients (cyclotomic quotients)\n            self.r2[basis_idx].range_check_2bounds::<BIT_R2>(\n                self.configs.r2_bounds[basis_idx],\n                self.configs.r2_bounds[basis_idx],\n            );\n        }\n    }\n\n    /// Generates Fiat-Shamir challenge value using the SAFE cryptographic sponge.\n    ///\n    /// This function implements the Fiat-Shamir transform for the decryption share circuit:\n    /// 1. Flattens all witness data (commitments for sk/e_sm, ciphertexts c_0/c_1, quotients r_1/r_2, decryption shares d) into a single array\n    /// 2. Absorbs the flattened data into the SAFE sponge\n    /// 3. Squeezes a single challenge value\n    ///\n    /// The challenge is used to evaluate polynomials for the Schwartz-Zippel lemma,\n    /// which allows verification of polynomial equations by checking them at a random\n    /// point rather than checking all coefficients.\n    ///\n    /// # Returns\n    /// A single challenge value `gamma` used as the evaluation point for verifying\n    /// the decryption share computation formula for all CRT bases.\n    fn generate_challenge(self) -> Field {\n        let inputs = self.payload();\n\n        compute_threshold_share_decryption_challenge::<L>(inputs)\n    }\n\n    /// Verifies the lifted decryption share computation formula for a specific CRT basis using the Schwartz-Zippel lemma.\n    ///\n    /// This function verifies that the decryption share for basis `i` satisfies:\n    /// `d_i(gamma) = c_0i(gamma) + c_1i(gamma) * s_i(gamma) + e_i(gamma) + r_2i(gamma) * cyclo(gamma) + r_1i(gamma) * q_i`\n    ///\n    /// Where:\n    /// - `c_0i`, `c_1i` are ciphertext components for basis i\n    /// - `s_i` is the aggregated secret key shares for basis i\n    /// - `e_i` is the aggregated noise shares for basis i\n    /// - `r_1i`, `r_2i` are quotient witnesses for basis i\n    /// - `cyclo(gamma) = gamma^N + 1` is the cyclotomic polynomial evaluated at gamma\n    /// - `q_i` is the CRT modulus for basis i\n    ///\n    /// The Schwartz-Zippel lemma ensures that if this equation holds at a random point\n    /// `gamma`, then the polynomials are identical with high probability.\n    ///\n    /// # Arguments\n    /// * `basis_idx` - The index of the CRT basis to verify (0 <= basis_idx < L)\n    /// * `gamma` - The Fiat-Shamir challenge value used as the evaluation point\n    ///\n    /// # Panics\n    /// The circuit will fail if the decryption share computation formula doesn't hold for the specified basis.\n    fn verify_decryption_share_computation(self, basis_idx: u32, gamma: Field) {\n        // Evaluate ciphertext components at gamma\n        let c_0_at_gamma = self.ct0[basis_idx].eval(gamma);\n        let c_1_at_gamma = self.ct1[basis_idx].eval(gamma);\n\n        // Evaluate aggregated sums at gamma\n        let sk_at_gamma = self.sk[basis_idx].eval(gamma);\n        let e_sm_at_gamma = self.e_sm[basis_idx].eval(gamma);\n\n        // Evaluate quotient polynomials at gamma\n        let r_1_at_gamma = self.r1[basis_idx].eval(gamma);\n        let r_2_at_gamma = self.r2[basis_idx].eval(gamma);\n\n        // Evaluate cyclotomic polynomial X^N + 1 at gamma\n        let cyclo_at_gamma = gamma.pow_32(N as Field) + 1;\n\n        // Compute expected decryption share using the lifted formula:\n        // d_i = c_0i + c_1i * sk_i + e_sm_i + r_2i * (X^N + 1) + r_1i * q_i\n        let expected_decryption_share = c_0_at_gamma\n            + c_1_at_gamma * sk_at_gamma\n            + e_sm_at_gamma\n            + r_2_at_gamma * cyclo_at_gamma\n            + r_1_at_gamma * self.configs.qis[basis_idx];\n\n        // Evaluate the party's claimed decryption share at gamma\n        let computed_decryption_share = self.d[basis_idx].eval(gamma);\n\n        // Enforce equality: computed decryption share must match expected value\n        assert(\n            computed_decryption_share == expected_decryption_share,\n            \"Decryption share computation failed\",\n        );\n    }\n}\n","path":"enclave/circuits/lib/src/core/threshold/share_decryption.nr"},"74":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse crate::math::helpers::{compute_safe, flatten};\nuse crate::math::polynomial::Polynomial;\n\n/// DOMAIN SEPARATORS\n\n// Domain separator - \"PK\"\npub global DS_PK: [u8; 64] = [\n    0x50, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"PK_GENERATION\"\npub global DS_PK_GENERATION: [u8; 64] = [\n    0x50, 0x4b, 0x5f, 0x47, 0x45, 0x4e, 0x45, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"SHARE_COMPUTATION\"\npub global DS_SHARE_COMPUTATION: [u8; 64] = [\n    0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x43, 0x4f, 0x4d, 0x50, 0x55, 0x54, 0x41, 0x54, 0x49, 0x4f,\n    0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"SHARE_ENCRYPTION\"\npub global DS_SHARE_ENCRYPTION: [u8; 64] = [\n    0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x45, 0x4e, 0x43, 0x52, 0x59, 0x50, 0x54, 0x49, 0x4f, 0x4e,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"PK_AGGREGATION\"\npub global DS_PK_AGGREGATION: [u8; 64] = [\n    0x50, 0x4b, 0x5f, 0x41, 0x47, 0x47, 0x52, 0x45, 0x47, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CIPHERTEXT\"\npub global DS_CIPHERTEXT: [u8; 64] = [\n    0x43, 0x49, 0x50, 0x48, 0x45, 0x52, 0x54, 0x45, 0x58, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"AGGREGATED_SHARES\"\npub global DS_AGGREGATED_SHARES: [u8; 64] = [\n    0x41, 0x47, 0x47, 0x52, 0x45, 0x47, 0x41, 0x54, 0x45, 0x44, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45,\n    0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"RECURSIVE_AGGREGATION\"\npub global DS_RECURSIVE_AGGREGATION: [u8; 64] = [\n    0x52, 0x45, 0x43, 0x55, 0x52, 0x53, 0x49, 0x56, 0x45, 0x5f, 0x41, 0x47, 0x47, 0x52, 0x45, 0x47,\n    0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_PK_GENERATION\"\npub global DS_CLG_PK_GENERATION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x50, 0x4b, 0x5f, 0x47, 0x45, 0x4e, 0x45, 0x52, 0x41, 0x54, 0x49, 0x4f,\n    0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_SHARE_ENCRYPTION\"\npub global DS_CLG_SHARE_ENCRYPTION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x45, 0x4e, 0x43, 0x52, 0x59, 0x50,\n    0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_USER_DATA_ENCRYPTION\"\npub global DS_CLG_USER_DATA_ENCRYPTION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x55, 0x53, 0x45, 0x52, 0x5f, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x45, 0x4e,\n    0x43, 0x52, 0x59, 0x50, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n// Domain separator - \"CLG_SHARE_DECRYPTION\"\npub global DS_CLG_SHARE_DECRYPTION: [u8; 64] = [\n    0x43, 0x4c, 0x47, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x44, 0x45, 0x43, 0x52, 0x59, 0x50,\n    0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n];\n\n/// WRAPPERS\n\npub fn compute_commitments(\n    payload: Vec<Field>,\n    domain_separator: [u8; 64],\n    io_pattern: [u32; 2],\n) -> Vec<Field> {\n    compute_safe(domain_separator, payload, io_pattern)\n}\n\npub fn single_polynomial_payload<let N: u32, let BIT_POLY: u32>(\n    payload: Vec<Field>,\n    input: Polynomial<N>,\n) -> Vec<Field> {\n    flatten::<_, _, BIT_POLY>(payload, [input])\n}\n\npub fn multiple_polynomial_payload<let N: u32, let L: u32, let BIT_POLY: u32>(\n    payload: Vec<Field>,\n    inputs: [Polynomial<N>; L],\n) -> Vec<Field> {\n    flatten::<_, _, BIT_POLY>(payload, inputs)\n}\n\n/// COMMITMENTS\n\npub fn compute_dkg_pk_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);\n    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);\n\n    compute_commitments(payload, DS_PK, [0x80000000 | payload.len(), 1]).get(0)\n}\n\npub fn compute_threshold_pk_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);\n    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);\n\n    compute_commitments(payload, DS_PK_GENERATION, [0x80000000 | payload.len(), 1]).get(0)\n}\n\npub fn compute_share_computation_sk_commitment<let N: u32, let BIT_SK: u32>(\n    sk: Polynomial<N>,\n) -> Field {\n    let mut payload = single_polynomial_payload::<N, BIT_SK>(Vec::new(), sk);\n    compute_commitments(\n        payload,\n        DS_SHARE_COMPUTATION,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_share_computation_e_sm_commitment<let N: u32, let L: u32, let BIT_E_SM: u32>(\n    e_sm: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_E_SM>(Vec::new(), e_sm);\n    compute_commitments(\n        payload,\n        DS_SHARE_COMPUTATION,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_share_encryption_commitment_from_message<let N: u32, let BIT_MSG: u32>(\n    message: Polynomial<N>,\n) -> Field {\n    let mut payload = single_polynomial_payload::<N, BIT_MSG>(Vec::new(), message);\n    compute_commitments(\n        payload,\n        DS_SHARE_ENCRYPTION,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_share_encryption_commitment_from_shares<let N: u32, let L: u32, let N_PARTIES: u32>(\n    y: [[[Field; N_PARTIES + 1]; L]; N],\n    party_idx: u32,\n    mod_idx: u32,\n) -> Field {\n    let mut payload = Vec::new();\n\n    for coeff_idx in 0..N {\n        payload.push(y[coeff_idx][mod_idx][party_idx + 1]);\n    }\n\n    // Include party_idx and mod_idx in the hash\n    payload.push(party_idx as Field);\n    payload.push(mod_idx as Field);\n\n    compute_commitments(\n        payload,\n        DS_SHARE_ENCRYPTION,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_aggregated_shares_commitment<let N: u32, let L: u32, let BIT_MSG: u32>(\n    agg_shares: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_MSG>(Vec::new(), agg_shares);\n    compute_commitments(\n        payload,\n        DS_AGGREGATED_SHARES,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_pk_aggregation_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0: [Polynomial<N>; L],\n    pk1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);\n    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);\n\n    compute_commitments(payload, DS_PK_AGGREGATION, [0x80000000 | payload.len(), 1]).get(0)\n}\n\npub fn compute_recursive_aggregation_commitment(payload: Vec<Field>) -> Field {\n    compute_safe(\n        DS_RECURSIVE_AGGREGATION,\n        payload,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n\npub fn compute_ciphertext_commitment<let N: u32, let L: u32, let BIT_CT: u32>(\n    ct0: [Polynomial<N>; L],\n    ct1: [Polynomial<N>; L],\n) -> Field {\n    let mut payload = multiple_polynomial_payload::<N, L, BIT_CT>(Vec::new(), ct0);\n    payload = multiple_polynomial_payload::<N, L, BIT_CT>(payload, ct1);\n\n    compute_commitments(payload, DS_CIPHERTEXT, [0x80000000 | payload.len(), 1]).get(0)\n}\n\n/// COMMITMENTS FOR CHALLENGES\n\npub fn compute_threshold_pk_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {\n    compute_commitments(\n        payload,\n        DS_CLG_PK_GENERATION,\n        [0x80000000 | payload.len(), 2 * L],\n    )\n}\n\npub fn compute_share_encryption_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {\n    compute_commitments(\n        payload,\n        DS_CLG_SHARE_ENCRYPTION,\n        [0x80000000 | payload.len(), 2 * L],\n    )\n}\n\npub fn compute_user_data_encryption_challenge_commitment<let N: u32, let L: u32, let BIT_PK: u32>(\n    pk0is: [Polynomial<N>; L],\n    pk1is: [Polynomial<N>; L],\n    gammas_payload: Vec<Field>,\n    pk_commitment: Field,\n) -> Vec<Field> {\n    assert(compute_pk_aggregation_commitment::<N, L, BIT_PK>(pk0is, pk1is) == pk_commitment);\n\n    compute_commitments(\n        gammas_payload,\n        DS_CLG_USER_DATA_ENCRYPTION,\n        [0x80000000 | gammas_payload.len(), 2 * L],\n    )\n}\n\npub fn compute_threshold_share_decryption_challenge<let L: u32>(payload: Vec<Field>) -> Field {\n    compute_commitments(\n        payload,\n        DS_CLG_SHARE_DECRYPTION,\n        [0x80000000 | payload.len(), 1],\n    )\n        .get(0)\n}\n","path":"enclave/circuits/lib/src/math/commitments.nr"},"75":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\n//! Helper functions for circuit construction and cryptographic operations.\nuse crate::math::polynomial::Polynomial;\nuse crate::math::safe::SafeSponge;\n\n/// Compute hex-aligned packing parameters for a given `BIT`.\n///\n/// # Purpose\n/// Returns `(nibble_bits, group)` for use by pack/flatten so layout stays consistent.\n/// - `nibble_bits`: ceil (`BIT`) to the next multiple of 4 (nibble alignment).\n///   - Examples: `BIT = 7 -> 8`, `BIT = 8 -> 8`, `BIT = 9 -> 12`, `BIT = 10 -> 12`, `BIT = 11 -> 12`,\n///     `BIT=16 -> 16`, `BIT = 17 -> 20`.\n/// - `group`: max number of encoded limbs that fit in one BN254 field element,\n///            when each limb uses an extra 4 bits (see below).\n///\n/// # Rationale\n/// - We align to nibbles so powers of two are hex-friendly and deterministic.\n/// - We reserve one extra nibble (4 bits) per stored value to lift signed\n///   coefficients into the non-negative range (e.g., store `v + 2^nibble_bits`),\n///   which implies a radix of `2^(nibble_bits + 4)`.\n///\n/// # Safety\n/// - Asserts `nibble_bits + 4 <= 254` to avoid mod-p wrap on BN254.\n/// - Ensures at least one limb fits: `group >= 1`.\nfn packing_layout<let BIT: u32>() -> (u32, u32) {\n    // Ceil BIT up to the next multiple of 4 (nibble alignment).\n    let nibble_bits = ((BIT + 3) / 4) * 4;\n\n    // Each stored limb uses an extra nibble because negative coefficients\n    // will be shifted to positive, so radix = 2^(nibble_bits+4).\n    assert(nibble_bits + 4 <= 254);\n\n    // Maximum limbs that fit in one BN254 element without wrap.\n    let group = 254 / (nibble_bits + 4);\n    assert(group >= 1);\n    (nibble_bits, group)\n}\n\n/// Flatten `L` polynomials into a single linear stream of packed `Field` carriers.\n///\n/// ## What this does\n/// - For each CRT limb `j` in `0..L`, it packs the coefficients of `poly[j]`\n///   with `pack::<A, BIT>` and appends all resulting carriers to `inputs`.\n/// - The packing layout (nibble-aligned width and `group` size) is taken from\n///   `packing_layout::<BIT>()` and must match what `pack` uses.\n///\n/// ## Determinism & order\n/// - Preserves a stable order: iterate `j = 0..L`, then for each `j` append\n///   carriers in ascending chunk index `i = 0..num_chunks`.\n/// - This ensures transcripts remain deterministic across runs.\n///\n/// ## Generics\n/// - `A`: polynomial degree (number of coefficients per polynomial).\n/// - `L`: number of CRT bases (polynomials).\n/// - `BIT`: per-coefficient bit bound used by the packing layout (compile-time).\n///\n/// ## Returns\n/// - The same `inputs` vector, extended with all carriers in deterministic order.\npub fn flatten<let A: u32, let L: u32, let BIT: u32>(\n    mut inputs: Vec<Field>,\n    poly: [Polynomial<A>; L],\n) -> Vec<Field> {\n    for j in 0..L {\n        // Pack its A coefficients into `num_chunks` carriers using the same BIT layout.\n        let packed = pack::<A, BIT>(poly[j].coefficients);\n\n        // Append carriers in-order to `inputs` to keep a stable transcript layout.\n        for i in 0..packed.len() {\n            inputs.push(packed.get(i));\n        }\n    }\n\n    // Return the extended input stream.\n    inputs\n}\n\n/// Pack `A` values into a `Vec<Field>` of carriers using the shared hex-aligned layout.\n///\n/// ## What this does\n/// - Computes `(nibble_bits, group)` via `packing_layout::<BIT>()`.\n/// - Encodes each value as a limb `digit = v + 2^nibble_bits` and concatenates\n///   limbs in base `radix = 2^(nibble_bits + 4)` (one extra nibble of headroom).\n/// - Packs up to `group` limbs per carrier (fits within BN254 254-bit capacity).\n/// - Pads the last, partial carrier with `digit = 2^nibble_bits` to keep a stable layout.\n///\n/// ## Determinism & order\n/// - Processes values in increasing index order and emits carriers in chunk order\n///   (`chunk = 0..num_chunks`). Padding is deterministic.\n///\n/// ## Generics\n/// - `A`: number of input values.\n/// - `BIT`: per-value bit bound; rounded up to `nibble_bits` by `packing_layout`.\n///\n/// ## Preconditions / Notes\n/// - Call with the raw coefficients whose magnitudes already satisfy the BIT bound\n///   (as enforced by the upstream range checks); `pack` performs the signed -> unsigned\n///   shift internally via `v + base`.\n/// - `group >= 1` is enforced by `packing_layout::<BIT>()`.\n/// - Padding with `digit = 2^nibble_bits` encodes `zero limb` consistently.\n///\n/// ## Returns\n/// - A `Vec<Field>` where each element is a concatenation of up to `group` limbs,\n///   suitable for hashing or transcript I/O.\npub fn pack<let A: u32, let BIT: u32>(values: [Field; A]) -> Vec<Field> {\n    // Layout parameters: nibble-aligned width and limbs-per-carrier group size.\n    let (nibble_bits, group) = packing_layout::<BIT>();\n\n    let base = 2.pow_32(nibble_bits as Field); // 2^nibble_bits\n    let radix = 2.pow_32((nibble_bits + 4) as Field); // 2^(nibble_bits + 4)\n\n    // Number of chunks to emit: ceil(A / group).\n    let num_chunks = (A + group - 1) / group;\n    let mut out = Vec::new();\n\n    // Process in fixed-size chunks of `group` limbs.\n    for chunk in 0..num_chunks {\n        // How many real values go into this chunk.\n        let remain = A - (chunk * group);\n        let take = if remain < group { remain } else { group };\n\n        // Build field element accumulator (big-endian concatenation in `radix`).\n        let mut acc = 0;\n        for i in 0..take {\n            let v = values[chunk * group + i];\n            acc = acc * radix + (v + base);\n        }\n\n        // Pad remaining limb slots with the canonical zero-limb `digit = base`.\n        for _ in 0..(group - take) {\n            acc = acc * radix + base;\n        }\n\n        out.push(acc);\n    }\n    out\n}\n\n/// Computes a cryptographic hash using the SAFE (Sponge API for Field Elements) protocol.\n///\n/// This is a convenience wrapper around the SAFE sponge API that handles the full\n/// lifecycle: initialization, absorption, squeezing, and finalization. It's designed\n/// for use in Fiat-Shamir challenge generation and commitment schemes within zero-knowledge circuits.\n///\n/// # Arguments\n/// * `domain_separator` - A 64-byte domain separator used to differentiate between\n///                        different protocol instances and prevent cross-protocol attacks.\n/// * `inputs` - Vector of field elements to be absorbed into the sponge.\n/// * `io_pattern` - A 2-element array encoding the I/O pattern:\n///                 - `io_pattern[0]`: Encoded ABSORB operation (MSB=1, lower 31 bits = length)\n///                 - `io_pattern[1]`: Encoded SQUEEZE operation (MSB=0, lower 31 bits = length)\n///\n/// # Returns\n/// A vector of field elements squeezed from the sponge, with length determined by\n/// the SQUEEZE operation in the IO pattern.\npub fn compute_safe(\n    domain_separator: [u8; 64],\n    inputs: Vec<Field>,\n    io_pattern: [u32; 2],\n) -> Vec<Field> {\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(inputs);\n    let digests = sponge.squeeze();\n    sponge.finish();\n\n    digests\n}\n\n#[test]\nfn test_flatten() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([1, 2, 3]); // degree 2\n    let poly2 = Polynomial::new([4, -16, 6]); // degree 2\n    let poly3 = Polynomial::new([-7, 8, 9]); // degree 2\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 4>(inputs, polynomials);\n\n    // Verify the flattened coefficients are in the correct positions\n    // Every value shifted 1 nibble incase of negative integers\n    assert(result.get(0) == 0x11121310101010101010101010101010101010101010101010101010101010);\n    assert(result.get(1) == 0x14001610101010101010101010101010101010101010101010101010101010); // -16 became 00 at  0x 14 00 16,\n    assert(result.get(2) == 0x09181910101010101010101010101010101010101010101010101010101010); // -7 became 09 at 0x 09 18 19(16 - 7 = 9)\n}\n\n#[test]\nfn test_flatten_big() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([\n        1791218451968394,\n        21888242871839275222246405745257275088548364400416034343698198265248580087864,\n        21888242871839275222246405745257275088548364400416034343698200542108324633466,\n        5430119342984413,\n        704811298945172,\n        8901715723925099,\n        21888242871839275222246405745257275088548364400416034343698203098124042812559,\n        21888242871839275222246405745257275088548364400416034343698200215091693880034,\n    ]);\n    let poly2 = Polynomial::new([\n        21888242871839275222246405745257275088548364400416034343698200314078269634250,\n        21888242871839275222246405745257275088548364400416034343698200967285641915872,\n        2909990636858607,\n        7896103832076587,\n        2078397209533893,\n        21888242871839275222246405745257275088548364400416034343698199792421452734531,\n        614400389245817,\n        8290314119277588,\n    ]);\n    let poly3 = Polynomial::new([\n        21888242871839275222246405745257275088548364400416034343698201373175279892906,\n        21888242871839275222246405745257275088548364400416034343698201087241869723721,\n        6768789983786188,\n        635797784303388,\n        7610153424227556,\n        4633893206538324,\n        2016269760615332,\n        21888242871839275222246405745257275088548364400416034343698201007080554428142,\n    ]);\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 54>(inputs, polynomials);\n\n    // Verify the flattened coefficients are in the correct positions\n    // Every value shifted 1 nibble incase of negative integers\n\n    // For the first index of result operation goes like this,\n\n    // First four index of poly1\n    // 1791218451968394,\n    // 21888242871839275222246405745257275088548364400416034343698198265248580087864,\n    // 21888242871839275222246405745257275088548364400416034343698200542108324633466,\n    // 5430119342984413,\n\n    // base + 1791218451968394 = 0x1065d1a8b8b718a\n    // base - 5921327228407753 = 0xeaf69591f3b037 (negative coefficient shifted)\n    // base - 3644467483862151 = 0xf30d604a3a9b79 (negative coefficient shifted)\n    // base + 5430119342984413 = 0x1134aaa2e86ccdd\n    assert(result.get(0) == 0x1065d1a8b8b718a0eaf69591f3b0370f30d604a3a9b791134aaa2e86ccdd);\n    assert(result.get(1) == 0x1028105ab1b789411fa010339db66b0fc220f1326bc8e0f1e3f4cc1e02e1);\n    assert(result.get(2) == 0x0f23dfbe7cd76c90f4901299312ddf10a569efe35acef11c0d76f005412b);\n    assert(result.get(3) == 0x107624a8f605dc50f0638a368960421022ecb3cf36b7911d73ff2c27ec14);\n    assert(result.get(4) == 0x0f6013a24e1b9a90f4fd2c158a08481180c2dba8af4cc10242413515171c);\n    assert(result.get(5) == 0x11b0964eb898ce411076805680b85410729c962da53a40f4b44412d0f6ed);\n}\n\n#[test]\nfn test_flatten_small() {\n    // Create test polynomials\n    let poly1 = Polynomial::new([712345, 104857, 999999, 500001, 123, 654321, 77]);\n    let poly2 = Polynomial::new([1, 524287, 888888, 23456, 34567, 765432, 0]);\n    let poly3 = Polynomial::new([444444, 333333, 222222, 111111, 987654, 246810, 13579]);\n\n    let polynomials = [poly1, poly2, poly3];\n\n    // Initialize target array with zeros\n    let mut inputs = Vec::new();\n\n    // Flatten the polynomials\n    let result = flatten::<_, _, 20>(inputs, polynomials);\n\n    assert(result.get(0) == 0x1ade991199991f423f17a12110007b19fbf110004d100000100000100000);\n    assert(result.get(1) == 0x10000117ffff1d9038105ba01087071badf8100000100000100000100000);\n    assert(result.get(2) == 0x16c81c15161513640e11b2071f120613c41a10350b100000100000100000);\n}\n\n#[test]\nfn test_safe_hashing_with_safe_helper() {\n    // Verifies basic hash functionality with a simple ABSORB(3) + SQUEEZE(1) pattern.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice(&[1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let digests1 = compute_safe(domain_separator, elements, io_pattern);\n\n    assert(digests1.len() == 1);\n    assert(digests1.get(0) != 0);\n\n    // Test determinism\n    let digests2 = compute_safe(domain_separator, elements, io_pattern);\n\n    assert(digests2.len() == 1);\n    assert(digests2.get(0) != 0);\n    assert(digests2.get(0) == digests1.get(0));\n}\n\n#[test]\nfn test_pack() {\n    // Test pack function directly with small values\n    let values = [1, 2, 3, 4];\n    let packed = pack::<4, 4>(values);\n\n    // With BIT=4, nibble_bits=4, group should be floor(254/(4+4)) = 31\n    // So all 4 values should fit in one carrier\n    assert(packed.len() >= 1);\n\n    // Test with negative values\n    let values_neg = [-1, 2, -3, 4];\n    let packed_neg = pack::<4, 4>(values_neg);\n    assert(packed_neg.len() >= 1);\n}\n\n#[test]\nfn test_pack_single_value() {\n    // Test packing a single value\n    let values = [42];\n    let packed = pack::<1, 8>(values);\n    assert(packed.len() == 1);\n    assert(packed.get(0) != 0);\n}\n\n#[test]\nfn test_pack_determinism() {\n    // Test that packing is deterministic\n    let values = [10, 20, 30];\n    let packed1 = pack::<3, 8>(values);\n    let packed2 = pack::<3, 8>(values);\n\n    assert(packed1.len() == packed2.len());\n    for i in 0..packed1.len() {\n        assert(packed1.get(i) == packed2.get(i));\n    }\n}\n","path":"enclave/circuits/lib/src/math/helpers.nr"},"80":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse super::modulo::U128::ModU128;\n\n/// Polynomial structure representing a polynomial of degree N-1.\n///\n/// A polynomial P(X) = a_{N-1} * X^{N-1} + a_{N-2} * X^{N-2} + ... + a_1 * X + a_0\n/// is represented as an array of coefficients where coefficients[0] = a_{N-1} (highest degree)\n/// and coefficients[N-1] = a_0 (constant term).\npub struct Polynomial<let N: u32> {\n    /// Array of polynomial coefficients in descending degree order\n    /// coefficients[0] = coefficient of X^{N-1} (highest degree term)\n    /// coefficients[N-1] = constant term (degree 0)\n    pub coefficients: [Field; N],\n}\n\nimpl<let N: u32> Polynomial<N> {\n    /// Creates a new polynomial from an array of coefficients.\n    ///\n    /// # Arguments\n    /// * `coefficients` - Array of N coefficients in descending degree order\n    ///                    coefficients[0] = coefficient of X^{N-1}\n    ///                    coefficients[N-1] = constant term\n    ///\n    /// # Returns\n    /// A new Polynomial instance with the specified coefficients\n    pub fn new(coefficients: [Field; N]) -> Self {\n        Polynomial { coefficients }\n    }\n\n    /// Adds two polynomials.\n    ///\n    /// # Arguments\n    /// * `other` - The polynomial to add to the current polynomial.\n    ///\n    /// # Returns\n    /// A new polynomial with the coefficients added.\n    pub fn add(self, other: Self) -> Self {\n        let mut result = Self::new([0; N]);\n\n        for i in 0..N {\n            result.coefficients[i] = self.coefficients[i] + other.coefficients[i];\n        }\n\n        result\n    }\n\n    /// Subtracts two polynomials.\n    ///\n    /// # Arguments\n    /// * `other` - The polynomial to subtract from the current polynomial.\n    ///\n    /// # Returns\n    /// A new polynomial with the coefficients subtracted.\n    pub fn sub(self, other: Self) -> Self {\n        let mut result = Self::new([0; N]);\n\n        for i in 0..N {\n            result.coefficients[i] = self.coefficients[i] - other.coefficients[i];\n        }\n\n        result\n    }\n\n    /// Multiplies a polynomial by a scalar.\n    ///\n    /// # Arguments\n    /// * `scalar` - The scalar to multiply the polynomial by.\n    ///\n    /// # Returns\n    /// A new polynomial with the coefficients multiplied by the scalar.\n    pub fn mul_scalar(self, scalar: Field) -> Self {\n        let mut result = Self::new([0; N]);\n\n        for i in 0..N {\n            result.coefficients[i] = self.coefficients[i] * scalar;\n        }\n\n        result\n    }\n\n    /// Evaluates the polynomial at a given point using Horner's method.\n    ///\n    /// Horner's method computes P(x) = a_{N-1} * x^{N-1} + ... + a_1 * x + a_0\n    /// as ((...((a_{N-1} * x + a_{N-2}) * x + a_{N-3}) * x + ...) * x + a_0)\n    /// This approach require n multiplications and n additions to evaluate the polynomial.\n    ///\n    /// # Arguments\n    /// * `x` - The point at which to evaluate the polynomial.\n    ///\n    /// # Returns\n    /// The value of the polynomial at point x: P(x).\n    pub fn eval(self, x: Field) -> Field {\n        let mut result = self.coefficients[0];\n\n        for i in 1..self.coefficients.len() {\n            result = result * x + self.coefficients[i];\n        }\n\n        result\n    }\n\n    /// Evaluates the polynomial at a given point with modular reduction.\n    ///\n    /// This function computes `P(x) mod q` using Horner's method with intermediate\n    /// modular reductions to prevent overflow. The result is guaranteed to be in\n    /// the range `[0, q)`.\n    ///\n    /// The function performs modular reduction after each multiplication and addition\n    /// to ensure the accumulator always remains in the range `[0, q)`, preventing\n    /// any potential overflow issues.\n    ///\n    /// # Arguments\n    /// * `x` - The point at which to evaluate the polynomial\n    /// * `q` - The modular arithmetic context containing the modulus\n    ///\n    /// # Returns\n    /// The value `P(x) mod q` in the range `[0, q)`\n    pub fn eval_mod(self, x: Field, q: ModU128) -> Field {\n        let mut acc = self.coefficients[0];\n        let len = self.coefficients.len();\n\n        for i in 1..len {\n            acc = q.mul_mod(acc, x);\n            acc = q.add(acc, self.coefficients[i]);\n        }\n\n        acc\n    }\n\n    /// Performs range checking on polynomial coefficients using asymmetric bounds.\n    ///\n    /// This function constrains all polynomial coefficients to be in the range [-lower_bound, upper_bound],\n    /// where `lower_bound` is a non-negative magnitude.\n    /// It uses a shifting technique to handle negative numbers efficiently:\n    /// 1. Shifts each coefficient by adding `lower_bound`: c' = c + lower_bound\n    /// 2. Checks that shifted coefficients are in [0, upper_bound + lower_bound] using bit-size assertions\n    /// 3. This ensures original coefficients are in [-lower_bound, upper_bound]\n    ///\n    /// The function uses two bit-size checks per coefficient to ensure the value is within bounds:\n    /// - `shifted_coefficient.assert_max_bit_size::<BIT + 1>()` ensures c' >= 0\n    /// - `(range_size - shifted_coefficient).assert_max_bit_size::<BIT + 1>()` ensures c' <= range_size\n    ///\n    /// # Arguments\n    /// * `upper_bound` - The upper bound for coefficient range checking\n    /// * `lower_bound` - Non-negative magnitude of the negative bound\n    ///                   Coefficients must satisfy: -lower_bound <= c <= upper_bound\n    ///\n    /// # Generic Parameters\n    /// * `BIT` - The bit-length of the total range `upper_bound + lower_bound`\n    ///           (choose `BIT` so `upper_bound + lower_bound < 2^BIT`). Since all checked\n    ///           values lie in `[0, upper_bound + lower_bound]`, they cannot exceed `BIT + 1` bits.\n    ///\n    /// # Panics\n    /// This function will cause the circuit to fail if any coefficient is outside\n    /// the specified bounds.\n    pub fn range_check_2bounds<let BIT: u32>(self, upper_bound: Field, lower_bound: Field) {\n        let range_size = lower_bound + upper_bound;\n\n        for i in 0..self.coefficients.len() {\n            let shifted_coefficient = self.coefficients[i] + lower_bound;\n\n            shifted_coefficient.assert_max_bit_size::<BIT + 1>();\n            (range_size - shifted_coefficient).assert_max_bit_size::<BIT + 1>();\n        }\n    }\n\n    /// Performs range checking on polynomial coefficients for the range [0, upper_bound).\n    ///\n    /// This function constrains all polynomial coefficients to be non-negative and\n    /// strictly less than `upper_bound`. It uses bit-size assertions to verify that\n    /// coefficients are in the valid range.\n    ///\n    /// The function performs two checks per coefficient:\n    /// 1. `coeff.assert_max_bit_size::<BIT>()` ensures `coeff >= 0` and `coeff < 2^BIT`\n    /// 2. `(upper_bound - 1 - coeff).assert_max_bit_size::<BIT>()` ensures `coeff < upper_bound`\n    ///\n    /// # Arguments\n    /// * `upper_bound` - The exclusive upper bound for coefficient range checking.\n    ///                   Coefficients must satisfy: `0 <= c < upper_bound`\n    ///\n    /// # Generic Parameters\n    /// * `BIT` - The bit-length parameter. Must satisfy `upper_bound <= 2^BIT` for\n    ///           the range check to work correctly.\n    ///\n    /// # Panics\n    /// This function will cause the circuit to fail if any coefficient is outside\n    /// the range `[0, upper_bound)`.\n    pub fn range_check_standard<let BIT: u32>(self, upper_bound: Field) {\n        for i in 0..self.coefficients.len() {\n            let coeff = self.coefficients[i];\n            // Check coeff >= 0 and coeff < 2^BIT\n            coeff.assert_max_bit_size::<BIT>();\n            // Check coeff <= upper_bound - 1 (i.e., coeff < upper_bound)\n            (upper_bound - 1 - coeff).assert_max_bit_size::<BIT>();\n        }\n    }\n\n    /// Performs range checking on polynomial coefficients for the range [0, 2^BIT).\n    ///\n    /// This is a specialized range check for coefficients that must be non-negative\n    /// and less than a power of two. It's more efficient than `range_check_standard`\n    /// when the upper bound is exactly `2^BIT` because it only needs a single\n    /// bit-size assertion per coefficient.\n    ///\n    /// The function verifies that each coefficient satisfies:\n    /// - `coeff >= 0` (implicit from bit-size check)\n    /// - `coeff < 2^BIT` (enforced by `assert_max_bit_size::<BIT>()`)\n    ///\n    /// # Generic Parameters\n    /// * `BIT` - The bit-length parameter. Coefficients must satisfy: `0 <= c < 2^BIT`\n    ///\n    /// # Panics\n    /// This function will cause the circuit to fail if any coefficient is outside\n    /// the range `[0, 2^BIT)`.\n    pub fn range_check_power_of_two<let BIT: u32>(self) {\n        for i in 0..self.coefficients.len() {\n            self.coefficients[i].assert_max_bit_size::<BIT>();\n        }\n    }\n}\n\n#[test]\nfn test_polynomial_eval() {\n    let coeffs = [1, 2, 3]; // represents 1x^2 + 2x + 3\n    let poly = Polynomial::new(coeffs);\n\n    let x = 2; // evaluate at x = 2\n    let result = poly.eval(x);\n\n    // (1 * 2^2) + (2 * 2) + 3 = 4 + 4 + 3 = 11\n    assert(result == 11);\n}\n\n#[test]\nfn test_polynomial_eval_zero() {\n    let coeffs = [1, -2, 1]; // x^2 - 2x + 1 = (x-1)^2\n    let poly = Polynomial::new(coeffs);\n\n    let x = 1; // evaluate at x = 1, should be 0\n    let result = poly.eval(x);\n\n    assert(result == 0);\n}\n\n#[test]\nfn test_polynomial_bounds() {\n    let coeffs = [-16, 240, 242];\n    let poly = Polynomial::new(coeffs);\n\n    // Test double bounds check - constrains to [-240, 242]\n    poly.range_check_2bounds::<8>(242, 240);\n}\n\n#[test(should_fail_with = \"assert_max_bit_size\")]\nfn test_polynomial_out_of_bounds_coefficients() {\n    let coeffs = [-100];\n    let poly = Polynomial::new(coeffs);\n\n    // Test double bounds check - constrains to [-98, 99]\n    // Should fail because -100 is out of bounds.\n    poly.range_check_2bounds::<7>(99, 98);\n}\n\n#[test]\nfn test_polynomial_add() {\n    let coeffs1 = [1, 2, 3]; // 1x^2 + 2x + 3\n    let coeffs2 = [4, 5, 6]; // 4x^2 + 5x + 6\n    let poly1 = Polynomial::new(coeffs1);\n    let poly2 = Polynomial::new(coeffs2);\n\n    let result = poly1.add(poly2);\n\n    // Expected: (1+4)x^2 + (2+5)x + (3+6) = 5x^2 + 7x + 9\n    assert(result.coefficients[0] == 5);\n    assert(result.coefficients[1] == 7);\n    assert(result.coefficients[2] == 9);\n}\n\n#[test]\nfn test_polynomial_sub() {\n    let coeffs1 = [5, 7, 9]; // 5x^2 + 7x + 9\n    let coeffs2 = [1, 2, 3]; // 1x^2 + 2x + 3\n    let poly1 = Polynomial::new(coeffs1);\n    let poly2 = Polynomial::new(coeffs2);\n\n    let result = poly1.sub(poly2);\n\n    // Expected: (5-1)x^2 + (7-2)x + (9-3) = 4x^2 + 5x + 6\n    assert(result.coefficients[0] == 4);\n    assert(result.coefficients[1] == 5);\n    assert(result.coefficients[2] == 6);\n}\n\n#[test]\nfn test_polynomial_mul_scalar() {\n    let coeffs = [1, 2, 3]; // 1x^2 + 2x + 3\n    let poly = Polynomial::new(coeffs);\n    let scalar = 5;\n\n    let result = poly.mul_scalar(scalar);\n\n    // Expected: 5x^2 + 10x + 15\n    assert(result.coefficients[0] == 5);\n    assert(result.coefficients[1] == 10);\n    assert(result.coefficients[2] == 15);\n}\n\n#[test]\nfn test_polynomial_mul_scalar_zero() {\n    let coeffs = [1, 2, 3];\n    let poly = Polynomial::new(coeffs);\n    let scalar = 0;\n\n    let result = poly.mul_scalar(scalar);\n\n    // Expected: 0x^2 + 0x + 0 = 0\n    assert(result.coefficients[0] == 0);\n    assert(result.coefficients[1] == 0);\n    assert(result.coefficients[2] == 0);\n}\n\n#[test]\nfn test_eval_mod_simple() {\n    // Test without initial reduction - simple case\n    // p(x) = x + 1 at x=5od 7\n    // Expected: (5 + 1) mod 7 = 6\n    let q = ModU128::new(7);\n\n    let poly1 = Polynomial::new([1, 1]);\n    let result1 = poly1.eval_mod(5, q);\n    assert(result1 == 6);\n\n    // Test: p(x) = 2x + 3 at x=5od 7\n    // Expected: (10 + 3) mod 7 = 13 mod 7 = 6\n    let poly2 = Polynomial::new([2, 3]);\n    let result2 = poly2.eval_mod(5, q);\n    assert(result2 == 6);\n}\n\n#[test]\nfn test_eval_mod_degree_2() {\n    // p(x) = x^2 + 2x + 3 at x=5od 7\n    // Using Horner's method: ((1)*5 + 2)*5 + 3 = (5+2)*5 + 3 = 7*5 + 3 = 35 + 3 = 38\n    // 38 mod 7 = 3 (since 38 = 5*7 + 3)\n    let q = ModU128::new(7);\n\n    let poly = Polynomial::new([1, 2, 3]);\n    let result = poly.eval_mod(5, q);\n    assert(result == 3);\n}\n\n#[test]\nfn test_eval_mod() {\n    // Test 1: Simple polynomial x^2 + 2x + 3 at x=5od 7\n    // Expected: (25 + 10 + 3) mod 7 = 38 mod 7 = 3\n    let q = ModU128::new(7);\n\n    let poly1 = Polynomial::new([1, 2, 3]);\n    let result1 = poly1.eval_mod(5, q);\n    assert(result1 == 3);\n\n    // Test 2: Higher degree polynomialod small prime\n    // p(x) = x^3 + x^2 + x + 1 at x=2od 11\n    // Expected: (8 + 4 + 2 + 1) mod 11 = 15 mod 11 = 4\n    let q = ModU128::new(11);\n\n    let poly2 = Polynomial::new([1, 1, 1, 1]);\n    let result2 = poly2.eval_mod(2, q);\n    assert(result2 == 4);\n\n    // Test 3: Polynomial with larger coefficients\n    // p(x) = 100x^2 + 50x + 25 at x=10od 73\n    // Expected: (10000 + 500 + 25) mod 73 = 10525 mod 73 = 13\n    let q = ModU128::new(73);\n\n    let poly3 = Polynomial::new([100, 50, 25]);\n    let result3 = poly3.eval_mod(10, q);\n    assert(result3 == 13);\n\n    // Test 4: Result should be less than modulus\n    let poly4 = Polynomial::new([5, 3, 7]);\n    let q = ModU128::new(17);\n    let result4 = poly4.eval_mod(4, q);\n    assert(result4 as u128 < q.get_mod_field() as u128);\n\n    // Test 5: Compare with regular eval for small values\n    let poly5 = Polynomial::new([1, 2, 1]);\n    let x = 3;\n    let q = ModU128::new(1000);\n    let result5 = poly5.eval_mod(x, q);\n    let expected5 = poly5.eval(x);\n    assert(result5 == expected5);\n\n    // Test 6: Zero polynomial\n    let poly6 = Polynomial::new([0, 0, 0]);\n    let q = ModU128::new(13);\n    let result6 = poly6.eval_mod(100, q);\n    assert(result6 == 0);\n}\n\n#[test]\nfn test_large_party_ids_scenario() {\n    // Simulating party IDs in range [1, 100]\n    let party_id_1 = 42;\n    let party_id_2 = 73;\n    let m = ModU128::new(288230376151711717); // ~58 bits\n\n    // Operations that would be used in Lagrange coefficients\n    let product = m.mul_mod(party_id_1, party_id_2);\n    let diff = m.sub(party_id_2, party_id_1);\n\n    assert(product == 3066);\n    assert(diff == 31);\n}\n\n#[test]\nfn test_eval_vs_eval_mod() {\n    // Compare eval and eval_mod for small values where no reduction should occur\n    let poly = Polynomial::new([1, 2, 3]);\n    let x = 2;\n    let q = ModU128::new(1000); // Large enough that no reduction happens\n\n    let result_normal = poly.eval(x);\n    let result_mod = poly.eval_mod(x, q);\n\n    // They should be equal: (1)*2 + 2)*2 + 3 = (2+2)*2 + 3 = 4*2 + 3 = 11\n    assert(result_normal == 11);\n    assert(result_mod == 11);\n}\n\n#[test]\nfn test_eval_mod_step_by_step() {\n    // p(x) = x + 1 at x=5od 7\n    // Step by step: acc = 1, then acc = 1*5 + 1 = 6\n    let poly = Polynomial::new([1, 1]);\n\n    // Manually compute\n    let mut acc = 1; // coefficients[0]\n    acc = acc * 5 + 1; // = 6\n    assert(acc == 6);\n\n    // Now with reduce_mod\n    let m = ModU128::new(7);\n    let reduced = m.reduce_mod(acc);\n    assert(reduced == 6);\n\n    // Now test the actual function\n    let result = poly.eval_mod(5, m);\n    assert(result == 6);\n}\n","path":"enclave/circuits/lib/src/math/polynomial.nr"},"81":{"source":"// SPDX-License-Identifier: LGPL-3.0-only\n//\n// This file is provided WITHOUT ANY WARRANTY;\n// without even the implied warranty of MERCHANTABILITY\n// or FITNESS FOR A PARTICULAR PURPOSE.\n\nuse keccak256::keccak256;\nuse poseidon::poseidon2_permutation;\n\n/// SAFE (Sponge API for Field Elements)\n///\n/// This module provides a complete implementation of the SAFE API in Noir as defined in:\n/// \"SAFE (Sponge API for Field Elements) - A Toolbox for ZK Hash Applications\"\n/// see https://hackmd.io/bHgsH6mMStCVibM_wYvb2w#22-Sponge-state for more details.\n///\n/// SAFE provides a unified interface for cryptographic sponge functions that can be\n/// instantiated with various permutations to create hash functions, MACs, authenticated\n/// encryption schemes, and other cryptographic primitives for ZK proof systems.\n///\n/// This implementation follows the SAFE specification exactly, providing:\n/// - Complete API: START, ABSORB, SQUEEZE, FINISH operations.\n/// - Full security: Domain separation, tag computation, IO pattern validation.\n/// - Poseidon2 integration: Field-friendly permutation for ZK systems.\n/// - Specification compliance: All operations follow SAFE spec 2.4 exactly.\n/// - Natural API design: Variable-length inputs, automatic length detection from IO patterns.\n///\n/// # API Design\n///\n/// The API is designed for natural usage while maintaining type safety:\n/// - `absorb(input: [Field])`: Accepts variable-length arrays, no padding required.\n/// - `squeeze()`: Returns a vector with field element(s).\n/// - IO patterns automatically determine operation lengths for validation.\n\n/// Rate parameter for the sponge construction (number of field elements that can be absorbed per permutation call).\nglobal RATE: u32 = 3;\n\n/// Capacity parameter for the sponge construction (security parameter, typically 1-2 field elements).\nglobal CAPACITY: u32 = 1;\n\n/// Total state size (rate + capacity) in field elements.\nglobal STATE_SIZE: u32 = RATE + CAPACITY;\n\n/// IO Pattern encoding constants (from SAFE spec 2.3).\n///\n/// These constants are used for encoding operation types in the 32-bit word format:\n/// - MSB set to 1 for ABSORB operations\n/// - MSB set to 0 for SQUEEZE operations\n\n/// Flag for ABSORB operations (MSB = 1)\nglobal ABSORB_FLAG: u32 = 0x80000000;\n\n/// Flag for SQUEEZE operations (MSB = 0)\nglobal SQUEEZE_FLAG: u32 = 0x00000000;\n\n/// SAFE Sponge State (following spec 2.2)\n///\n/// The sponge state consists of the permutation state, tag, position counters,\n/// and IO pattern tracking as defined in the SAFE specification.\n///\n/// # Generic Parameters\n/// - `L`: The length of the IO pattern array\n///\n/// # Fields\n/// - `state`: Permutation state V in F^n (rate + capacity elements)\n/// - `tag`: Parameter tag T used for instance differentiation\n/// - `absorb_pos`: Current absorb position (<= n-c)\n/// - `squeeze_pos`: Current squeeze position (<= n-c)\n/// - `io_pattern`: Expected IO pattern for validation (encoded 32-bit words)\n/// - `io_count`: Current operation count for pattern tracking\npub struct SafeSponge<let L: u32> {\n    /// Permutation state V in F^n (rate + capacity elements).\n    state: [Field; STATE_SIZE],\n    /// Parameter tag T used for instance differentiation.\n    tag: Field,\n    /// Current absorb position (<= n-c).\n    absorb_pos: u32,\n    /// Current squeeze position (<= n-c).\n    squeeze_pos: u32,\n    /// Expected IO pattern for validation.\n    io_pattern: [u32; L],\n    /// Current operation count for pattern tracking (spec 2.4: io_count).\n    io_count: u32,\n}\n\nimpl<let L: u32> SafeSponge<L> {\n    /// Initializes a new SAFE sponge instance with the given IO pattern and domain separator (following spec 2.4).\n    ///\n    /// # Arguments\n    /// - `io_pattern`: Array of 32-bit encoded operations defining the expected sequence of ABSORB/SQUEEZE calls.\n    ///               Each word has MSB=1 for ABSORB operations, MSB=0 for SQUEEZE operations.\n    /// - `domain_separator`: 64-byte domain separator for cross-protocol security.\n    ///\n    /// # Returns\n    /// A new `SafeSponge` instance with initialized state\n    pub fn start(io_pattern: [u32; L], domain_separator: [u8; 64]) -> SafeSponge<L> {\n        // Compute tag from IO pattern and domain separator (spec 2.3).\n        let tag = compute_tag(io_pattern, domain_separator);\n\n        let mut state = [0; STATE_SIZE];\n        // Initialize capacity with tag (spec 2.4).\n        // Add T to the first 128 bits of the state.\n        state[0] = tag;\n\n        SafeSponge { state, tag, absorb_pos: 0, squeeze_pos: 0, io_pattern, io_count: 0 }\n    }\n\n    /// Absorbs field elements into the sponge state, interleaving permutation calls as needed (following spec 2.4).\n    ///\n    /// The number of elements to absorb is automatically validated against the IO pattern.\n    /// This method accepts variable-length arrays, making it natural to use without padding.\n    ///\n    /// # Arguments\n    /// - `input`: Array of field elements to absorb (variable length, must match IO pattern)\n    pub fn absorb(&mut self, input: Vec<Field>) {\n        let length = input.len() as u32;\n\n        // Validate against IO pattern.\n        assert(self.io_count < L);\n\n        // Parse expected operation from io_pattern (encoded word)\n        let expected_encoded_word = self.io_pattern[self.io_count];\n        let is_expected_absorb = (expected_encoded_word & ABSORB_FLAG) != 0;\n        let expected_length = expected_encoded_word & 0x7FFFFFFF;\n\n        // Validate operation type and length\n        assert(is_expected_absorb, \"Expected ABSORB operation\");\n        assert(expected_length == length, \"Length mismatch\");\n\n        // Process each element naturally (no unnecessary iterations).\n        for i in 0..length {\n            // If absorb_pos == (n-c) then permute and reset (spec 2.4).\n            if self.absorb_pos == RATE {\n                // n-c = RATE.\n                self.state = self.permute();\n                self.absorb_pos = 0;\n            }\n\n            // Add X[i] to state at absorb_pos (spec 2.4).\n            // Note: absorb_pos is the rate position, not capacity position.\n            self.state[self.absorb_pos + CAPACITY] =\n                self.state[self.absorb_pos + CAPACITY] + input.get(i);\n            self.absorb_pos += 1;\n        }\n\n        // Verify that the encoded word matches the expected pattern.\n        let encoded_word = ABSORB_FLAG | length;\n        assert(encoded_word == expected_encoded_word);\n\n        self.io_count += 1;\n\n        // Force permute at start of next SQUEEZE (spec 2.4).\n        self.squeeze_pos = RATE;\n    }\n\n    /// Extracts field elements from the sponge state, interleaving permutation calls as needed (following spec 2.4).\n    ///\n    /// The number of elements to squeeze is automatically determined from the IO pattern.\n    pub fn squeeze(&mut self) -> Vec<Field> {\n        // Validate against IO pattern.\n        assert(self.io_count < L);\n\n        // Parse expected operation from io_pattern (encoded word)\n        let expected_encoded_word = self.io_pattern[self.io_count];\n        let is_expected_squeeze = (expected_encoded_word & ABSORB_FLAG) == 0;\n        let length = expected_encoded_word & 0x7FFFFFFF;\n\n        // Validate operation type\n        assert(is_expected_squeeze, \"Expected SQUEEZE operation\");\n\n        let mut output = Vec::new();\n\n        // SQUEEZE implementation following spec 2.4.\n        // If length==0, loop won't execute (spec 2.4).\n        for _ in 0..length {\n            // If squeeze_pos==(n-c) then permute and reset (spec 2.4).\n            if self.squeeze_pos == RATE {\n                // n-c = RATE.\n                self.state = self.permute();\n                self.squeeze_pos = 0;\n                self.absorb_pos = 0;\n            }\n            // Set Y[i] to state element at squeeze_pos (spec 2.4).\n            output.push(self.state[self.squeeze_pos + CAPACITY]);\n            self.squeeze_pos += 1;\n        }\n\n        // Verify that the encoded word matches the expected pattern.\n        let encoded_word = SQUEEZE_FLAG | length;\n        assert(encoded_word == expected_encoded_word);\n\n        self.io_count += 1;\n        output\n    }\n\n    /// Finalizes the sponge instance, verifying that all expected operations have been performed and clearing the internal state for security (following spec 2.4).\n    ///\n    /// This function is used to ensure that the sponge instance has been used correctly and to prevent information leakage.\n    pub fn finish(&mut self) {\n        // Check that io_count equals the length of the IO pattern expected (spec 2.4).\n        assert(self.io_count == L, \"IO pattern not completed\");\n\n        // Erase the state and its variables (spec 2.4).\n        self.state = [0; STATE_SIZE];\n        self.absorb_pos = 0;\n        self.squeeze_pos = 0;\n        self.io_count = 0;\n    }\n\n    /// Permute the state using Poseidon2 (following spec 2.4).\n    ///\n    /// Applies the Poseidon2 permutation to the current state.\n    /// This is the core cryptographic primitive of the sponge construction.\n    ///\n    /// # Returns\n    /// New state after permutation\n    fn permute(self) -> [Field; STATE_SIZE] {\n        poseidon2_permutation(self.state, STATE_SIZE)\n    }\n}\n\n/// Computes a unique tag for a sponge instance based on its IO pattern and domain separator.\n/// The tag is used to ensure that distinct instances behave like distinct functions.\n///\n/// # Arguments\n/// - `io_pattern`: Array of 32-bit encoded operations defining the sponge's usage pattern.\n///               Each word has MSB=1 for ABSORB operations, MSB=0 for SQUEEZE operations.\n/// - `domain_separator`: 64-byte domain separator for cross-protocol security.\n///\n/// # Returns\n/// A field element representing the 128-bit tag.\npub fn compute_tag<let L: u32>(io_pattern: [u32; L], domain_separator: [u8; 64]) -> Field {\n    // Step 1: Parse and aggregate consecutive operations of the same type\n    let mut encoded_words = [0; L]; // Support up to L operations.\n    let mut word_count = 0;\n    let mut current_absorb_sum = 0;\n    let mut current_squeeze_sum = 0;\n    let mut last_was_absorb = false;\n\n    for i in 0..L {\n        if io_pattern[i] > 0 {\n            // Parse operation type from MSB and length from lower 31 bits\n            let is_absorb = (io_pattern[i] & ABSORB_FLAG) != 0;\n            let length = io_pattern[i] & 0x7FFFFFFF; // Clear MSB to get length\n\n            if is_absorb {\n                if last_was_absorb {\n                    // Aggregate consecutive ABSORB operations\n                    current_absorb_sum += length;\n                } else {\n                    // Start new ABSORB sequence\n                    if current_squeeze_sum > 0 {\n                        // Flush previous SQUEEZE sequence\n                        encoded_words[word_count] = SQUEEZE_FLAG | current_squeeze_sum;\n                        word_count += 1;\n                        current_squeeze_sum = 0;\n                    }\n                    current_absorb_sum = length;\n                }\n                last_was_absorb = true;\n            } else {\n                if !last_was_absorb {\n                    // Aggregate consecutive SQUEEZE operations\n                    current_squeeze_sum += length;\n                } else {\n                    // Start new SQUEEZE sequence\n                    if current_absorb_sum > 0 {\n                        // Flush previous ABSORB sequence\n                        encoded_words[word_count] = ABSORB_FLAG | current_absorb_sum;\n                        word_count += 1;\n                        current_absorb_sum = 0;\n                    }\n                    current_squeeze_sum = length;\n                }\n                last_was_absorb = false;\n            }\n        }\n    }\n\n    // Flush remaining operations\n    if current_absorb_sum > 0 {\n        encoded_words[word_count] = ABSORB_FLAG | current_absorb_sum;\n        word_count += 1;\n    }\n    if current_squeeze_sum > 0 {\n        encoded_words[word_count] = SQUEEZE_FLAG | current_squeeze_sum;\n        word_count += 1;\n    }\n\n    // Step 2: Serialize to byte string and append domain separator (following SAFE spec 2.3).\n    // Buffer is 256 bytes: max 192 bytes for IO pattern (48 words) + 64 bytes for domain separator.\n    // Note: We must use a fixed-size array because Noir's keccak256 requires [u8; N], not Vec<u8>.\n    let max_io_pattern_bytes: u32 = 192; // 256 - 64 (domain separator)\n    let io_pattern_bytes = word_count * 4;\n    assert(\n        io_pattern_bytes <= max_io_pattern_bytes,\n        \"IO pattern too large: max 48 aggregated words supported\",\n    );\n\n    let mut input_bytes = [0u8; 256];\n    let mut byte_count: u32 = 0;\n\n    // Serialize encoded words to bytes (big-endian as per SAFE spec).\n    // Note: Noir requires compile-time loop bounds, so we iterate over L (the array size)\n    // instead of word_count (runtime value). The condition `i < word_count` ensures we only\n    // process valid encoded words. This is safe because word_count <= L always holds\n    // (we can have at most L encoded words from L input operations).\n    for i in 0..L {\n        if i < word_count {\n            let word = encoded_words[i];\n            input_bytes[byte_count] = (word >> 24) as u8;\n            input_bytes[byte_count + 1] = (word >> 16) as u8;\n            input_bytes[byte_count + 2] = (word >> 8) as u8;\n            input_bytes[byte_count + 3] = word as u8;\n            byte_count += 4;\n        }\n    }\n\n    // Append full 64-byte domain separator.\n    for i in 0..64 {\n        input_bytes[byte_count] = domain_separator[i];\n        byte_count += 1;\n    }\n\n    // Step 3: Hash with Keccak-256 and truncate to 128 bits.\n    // Note: The SAFE spec uses SHA3-256, but we use Keccak-256 for Noir compatibility.\n    // Keccak-256 differs from SHA3-256 in padding, but both provide equivalent security.\n    let hash_bytes = keccak256(input_bytes, byte_count);\n\n    // Convert first 128 bits (16 bytes) to field element.\n    let mut tag_value: Field = 0;\n    for i in 0..16 {\n        tag_value = tag_value * 256 + (hash_bytes[i] as Field);\n    }\n\n    tag_value\n}\n\n#[test]\nfn test_safe_hashing() {\n    // Verifies basic hash functionality with a simple ABSORB(3) + SQUEEZE(1) pattern.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice(&[1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(elements);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(elements);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_merkle_node() {\n    // Verifies SAFE can be used for Merkle tree node hashing with pattern ABSORB(1) + ABSORB(1) + SQUEEZE(1).\n    // Tests the ability to absorb multiple inputs before squeezing output.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let left = Vec::from_slice([123]);\n    let right = Vec::from_slice([456]);\n\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(left);\n    sponge.absorb(right);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(left);\n    sponge2.absorb(right);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_commitment_scheme() {\n    // Verifies SAFE can be used for commitment schemes with pattern ABSORB(3) + SQUEEZE(1).\n    // Tests the ability to create deterministic commitments from multiple field elements.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let values = Vec::from_slice([10, 20, 30]);\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(values);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n\n    // Test determinism\n    let mut sponge2 = SafeSponge::start(io_pattern, domain_separator);\n    sponge2.absorb(values);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output2.len() == 1);\n    assert(output2.get(0) != 0);\n}\n\n#[test]\nfn test_domain_separation() {\n    // Verifies that different domain separators produce different outputs for the same input.\n    // This is crucial for cross-protocol security and preventing collisions between different applications.\n    let elements = Vec::from_slice([1, 2, 3]);\n    let domain1 = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let domain2 = [\n        0x41, 0x42, 0x43, 0x45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Pattern: ABSORB(3), SQUEEZE(1)\n    let io_pattern = [0x80000003, 0x00000001];\n\n    let mut sponge1 = SafeSponge::start(io_pattern, domain1);\n    sponge1.absorb(elements);\n    let output1 = sponge1.squeeze();\n    sponge1.finish();\n\n    let mut sponge2 = SafeSponge::start(io_pattern, domain2);\n    sponge2.absorb(elements);\n    let output2 = sponge2.squeeze();\n    sponge2.finish();\n\n    assert(output1.len() == 1);\n    assert(output2.len() == 1);\n    assert(output1.get(0) != output2.get(0)); // Different domain separators should produce different outputs\n}\n\n#[test]\nfn test_multiple_squeeze() {\n    // Verifies that multiple field elements can be squeezed in a single operation.\n    // Tests pattern ABSORB(3) + SQUEEZE(2) to ensure proper state management.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n    let elements = Vec::from_slice([1, 2, 3]);\n\n    // Pattern: ABSORB(3), SQUEEZE(2)\n    let io_pattern = [0x80000003, 0x00000002];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(elements);\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 2);\n    assert(output.get(0) != 0);\n    assert(output.get(1) != 0);\n    assert(output.get(0) != output.get(1)); // Different squeeze outputs should be different\n}\n\n#[test]\nfn test_zero_length_operations() {\n    // Verifies that zero-length ABSORB and SQUEEZE operations are handled correctly.\n    // Tests pattern ABSORB(0) + SQUEEZE(1) to ensure proper state transitions.\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Pattern: ABSORB(0), SQUEEZE(1)\n    let io_pattern = [0x80000000, 0x00000001];\n    let mut sponge = SafeSponge::start(io_pattern, domain_separator);\n    sponge.absorb(Vec::new());\n    let output = sponge.squeeze();\n    sponge.finish();\n\n    assert(output.len() == 1);\n    assert(output.get(0) != 0);\n}\n\n#[test]\nfn test_tag_computation() {\n    // Verifies the tag computation algorithm using the example from the SAFE specification.\n    // Pattern: ABSORB(3), ABSORB(3), SQUEEZE(3)\n    // Should aggregate to: ABSORB(6), SQUEEZE(3)\n    // Encoded as: [0x80000006, 0x00000003]\n    // Tests determinism and pattern differentiation.\n\n    let io_pattern = [0x80000003, 0x80000003, 0x00000003];\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test determinism\n    let tag2 = compute_tag(io_pattern, domain_separator);\n    assert(tag == tag2);\n\n    // Test that different patterns produce different tags\n    let io_pattern2 = [0x80000003, 0x00000003]; // ABSORB(3), SQUEEZE(3) - different pattern\n    let tag3 = compute_tag(io_pattern2, domain_separator);\n    assert(tag != tag3);\n}\n\n#[test]\nfn test_tag_computation_debug() {\n    println(\"=== SAFE Tag Computation Debug Test ===\");\n\n    // Test your specific pattern [2, 2, 2] (ABSORB(2), SQUEEZE(2), ABSORB(2))\n    let io_pattern = [0x80000002, 0x00000002, 0x80000002];\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    println(f\"Testing pattern: {io_pattern}\");\n    println(\n        f\"Expected to aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(2)\",\n    );\n    println(\n        f\"Expected encoded words: [0x80000002, 0x00000002, 0x80000002]\",\n    );\n    println(\"\");\n\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    println(f\"=== Expected Rust Output ===\");\n    println(\"Pattern [2, 2, 2] (ABSORB(2), SQUEEZE(2), ABSORB(2))\");\n    println(\"Domain separator: 0x41424344...\");\n    println(\"Tag: 0xce3bb9ee4b2d41c42e9cdda38afe8b6a\");\n    println(\"\");\n\n    println(f\"=== Noir Output ===\");\n    println(f\"Tag: {tag}\");\n    println(\"\");\n\n    println(\"Compare the tag values above with Rust script!\");\n}\n\n#[test]\nfn test_consecutive_absorb_aggregation() {\n    // Test that consecutive ABSORB operations are properly aggregated\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1) should aggregate to ABSORB(2), SQUEEZE(1)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), ABSORB(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001];\n\n    // This should aggregate to: ABSORB(2), SQUEEZE(1) = [0x80000002, 0x00000001]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag ABSORB(2), SQUEEZE(1)\n    let aggregated_pattern = [0x80000002, 0x00000001];\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(tag == aggregated_tag, \"Consecutive ABSORB operations should aggregate to the same tag\");\n\n    // Test that a different pattern produces a different tag\n    let different_pattern = [0x80000001, 0x00000001, 0x80000001]; // ABSORB(1), SQUEEZE(1), ABSORB(1)\n    let different_tag = compute_tag(different_pattern, domain_separator);\n\n    // This should be different because it doesn't have consecutive ABSORB operations\n    assert(tag != different_tag, \"Different patterns should produce different tags\");\n\n    println(\"=== Consecutive ABSORB Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x80000001, 0x00000001] (ABSORB(1), ABSORB(1), SQUEEZE(1))\",\n    );\n    println(\n        f\"Aggregated pattern: [0x80000002, 0x00000001] (ABSORB(2), SQUEEZE(1))\",\n    );\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Different pattern tag: {different_tag}\");\n}\n\n#[test]\nfn test_consecutive_squeeze_aggregation() {\n    // Test that consecutive SQUEEZE operations are properly aggregated\n    // Pattern: ABSORB(1), SQUEEZE(1), SQUEEZE(1) should aggregate to ABSORB(1), SQUEEZE(2)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), SQUEEZE(1), SQUEEZE(1)\n    let io_pattern = [0x80000001, 0x00000001, 0x00000001];\n\n    // This should aggregate to: ABSORB(1), SQUEEZE(2) = [0x80000001, 0x00000002]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag ABSORB(1), SQUEEZE(2)\n    let aggregated_pattern = [0x80000001, 0x00000002];\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(\n        tag == aggregated_tag,\n        \"Consecutive SQUEEZE operations should aggregate to the same tag\",\n    );\n\n    // Test that a different pattern produces a different tag\n    let different_pattern = [0x80000001, 0x00000001, 0x80000001]; // ABSORB(1), SQUEEZE(1), ABSORB(1)\n    let different_tag = compute_tag(different_pattern, domain_separator);\n\n    // This should be different because it doesn't have consecutive SQUEEZE operations\n    assert(tag != different_tag, \"Different patterns should produce different tags\");\n\n    println(\"=== Consecutive SQUEEZE Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x00000001, 0x00000001] (ABSORB(1), SQUEEZE(1), SQUEEZE(1))\",\n    );\n    println(\n        f\"Aggregated pattern: [0x80000001, 0x00000002] (ABSORB(1), SQUEEZE(2))\",\n    );\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n    println(f\"Different pattern tag: {different_tag}\");\n}\n\n#[test]\nfn test_mixed_consecutive_aggregation() {\n    // Test that both consecutive ABSORB and SQUEEZE operations are properly aggregated\n    // Pattern: ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1)\n    // Should aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(1)\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Test pattern: ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1)\n    let io_pattern = [0x80000001, 0x80000001, 0x00000001, 0x00000001, 0x80000001];\n\n    // This should aggregate to: ABSORB(2), SQUEEZE(2), ABSORB(1) = [0x80000002, 0x00000002, 0x80000001]\n    let tag = compute_tag(io_pattern, domain_separator);\n\n    // Test that the aggregated pattern produces the same tag\n    let aggregated_pattern = [0x80000002, 0x00000002, 0x80000001]; // ABSORB(2), SQUEEZE(2), ABSORB(1)\n    let aggregated_tag = compute_tag(aggregated_pattern, domain_separator);\n\n    // The tags should be identical because the patterns are equivalent after aggregation\n    assert(tag == aggregated_tag, \"Mixed consecutive operations should aggregate to the same tag\");\n\n    println(\"=== Mixed Consecutive Aggregation Test ===\");\n    println(\n        f\"Original pattern: [0x80000001, 0x80000001, 0x00000001, 0x00000001, 0x80000001]\",\n    );\n    println(\n        f\"  (ABSORB(1), ABSORB(1), SQUEEZE(1), SQUEEZE(1), ABSORB(1))\",\n    );\n    println(f\"Aggregated pattern: [0x80000002, 0x00000002, 0x80000001]\");\n    println(f\"  (ABSORB(2), SQUEEZE(2), ABSORB(1))\");\n    println(f\"Original tag: {tag}\");\n    println(f\"Aggregated tag: {aggregated_tag}\");\n}\n\n#[test]\nfn test_large_io_pattern() {\n    let domain_separator = [\n        0x41, 0x42, 0x43, 0x44, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0,\n    ];\n\n    // Create pattern with 48 alternating ABSORB(1) and SQUEEZE(1) operations\n    // This is the maximum supported (48 words * 4 bytes = 192 bytes, leaving 64 for domain separator)\n    let mut io_pattern = [0u32; 48];\n    for i in 0..48 {\n        if i % 2 == 0 {\n            io_pattern[i] = ABSORB_FLAG | 1; // ABSORB(1)\n        } else {\n            io_pattern[i] = SQUEEZE_FLAG | 1; // SQUEEZE(1)\n        }\n    }\n\n    let tag = compute_tag(io_pattern, domain_separator);\n    assert(tag != 0);\n}\n\n#[test]\nfn test_domain_separator_not_truncated() {\n    // This test verifies that the domain separator is always included in the tag computation,\n    // even for large IO patterns. If the domain separator were truncated, different domain\n    // separators would produce the same tag for large patterns.\n\n    let domain_separator_a = [\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,\n        0x41, 0x41, 0x41, 0x41,\n    ]; // All 'A's\n\n    let domain_separator_b = [\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,\n        0x42, 0x42, 0x42, 0x42,\n    ]; // All 'B's\n\n    // Create pattern with 48 alternating operations (max supported: 192 bytes of IO pattern)\n    let mut io_pattern = [0u32; 48];\n    for i in 0..48 {\n        if i % 2 == 0 {\n            io_pattern[i] = ABSORB_FLAG | 1;\n        } else {\n            io_pattern[i] = SQUEEZE_FLAG | 1;\n        }\n    }\n\n    let tag_a = compute_tag(io_pattern, domain_separator_a);\n    let tag_b = compute_tag(io_pattern, domain_separator_b);\n\n    // Tags MUST be different because domain separators are different.\n    // If they were the same, it would mean the domain separator was truncated/ignored.\n    assert(tag_a != tag_b, \"Domain separator must affect tag even for large IO patterns\");\n}\n","path":"enclave/circuits/lib/src/math/safe.nr"}},"expression_width":{"Bounded":{"width":4}}}