// SPDX-License-Identifier: LGPL-3.0-only
//
// This file is provided WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.

use crate::math::helpers::{compute_safe, flatten};
use crate::math::polynomial::Polynomial;

/// DOMAIN SEPARATORS

// Domain separator - "PK"
pub global DS_PK: [u8; 64] = [
    0x50, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "PK_GENERATION"
pub global DS_PK_GENERATION: [u8; 64] = [
    0x50, 0x4b, 0x5f, 0x47, 0x45, 0x4e, 0x45, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "SHARE_COMPUTATION"
pub global DS_SHARE_COMPUTATION: [u8; 64] = [
    0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x43, 0x4f, 0x4d, 0x50, 0x55, 0x54, 0x41, 0x54, 0x49, 0x4f,
    0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "SHARE_ENCRYPTION"
pub global DS_SHARE_ENCRYPTION: [u8; 64] = [
    0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x45, 0x4e, 0x43, 0x52, 0x59, 0x50, 0x54, 0x49, 0x4f, 0x4e,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "PK_AGGREGATION"
pub global DS_PK_AGGREGATION: [u8; 64] = [
    0x50, 0x4b, 0x5f, 0x41, 0x47, 0x47, 0x52, 0x45, 0x47, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "CIPHERTEXT"
pub global DS_CIPHERTEXT: [u8; 64] = [
    0x43, 0x49, 0x50, 0x48, 0x45, 0x52, 0x54, 0x45, 0x58, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "AGGREGATED_SHARES"
pub global DS_AGGREGATED_SHARES: [u8; 64] = [
    0x41, 0x47, 0x47, 0x52, 0x45, 0x47, 0x41, 0x54, 0x45, 0x44, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45,
    0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "AGGREGATION"
pub global DS_AGGREGATION: [u8; 64] = [
    0x41, 0x47, 0x47, 0x52, 0x45, 0x47, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "CLG_PK_GENERATION"
pub global DS_CLG_PK_GENERATION: [u8; 64] = [
    0x43, 0x4c, 0x47, 0x50, 0x4b, 0x5f, 0x47, 0x45, 0x4e, 0x45, 0x52, 0x41, 0x54, 0x49, 0x4f, 0x4e,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "CLG_SHARE_ENCRYPTION"
pub global DS_CLG_SHARE_ENCRYPTION: [u8; 64] = [
    0x43, 0x4c, 0x47, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x45, 0x4e, 0x43, 0x52, 0x59, 0x50,
    0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "CLG_USER_DATA_ENCRYPTION"
pub global DS_CLG_USER_DATA_ENCRYPTION: [u8; 64] = [
    0x43, 0x4c, 0x47, 0x5f, 0x55, 0x53, 0x45, 0x52, 0x5f, 0x44, 0x41, 0x54, 0x41, 0x5f, 0x45, 0x4e,
    0x43, 0x52, 0x59, 0x50, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "CLG_SHARE_DECRYPTION"
pub global DS_CLG_SHARE_DECRYPTION: [u8; 64] = [
    0x43, 0x4c, 0x47, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45, 0x5f, 0x44, 0x45, 0x43, 0x52, 0x59, 0x50,
    0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

/// WRAPPERS

pub fn compute_commitments(
    payload: Vec<Field>,
    domain_separator: [u8; 64],
    io_pattern: [u32; 2],
) -> Vec<Field> {
    compute_safe(domain_separator, payload, io_pattern)
}

pub fn single_polynomial_payload<let N: u32, let BIT_POLY: u32>(
    payload: Vec<Field>,
    input: Polynomial<N>,
) -> Vec<Field> {
    flatten::<_, _, BIT_POLY>(payload, [input])
}

pub fn multiple_polynomial_payload<let N: u32, let L: u32, let BIT_POLY: u32>(
    payload: Vec<Field>,
    inputs: [Polynomial<N>; L],
) -> Vec<Field> {
    flatten::<_, _, BIT_POLY>(payload, inputs)
}

/// COMMITMENTS

pub fn compute_dkg_pk_commitment<let N: u32, let L: u32, let BIT_PK: u32>(
    pk0: [Polynomial<N>; L],
    pk1: [Polynomial<N>; L],
) -> Field {
    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);
    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);

    compute_commitments(payload, DS_PK, [0x80000000 | payload.len(), 1]).get(0)
}

pub fn compute_threshold_pk_commitment<let N: u32, let L: u32, let BIT_PK: u32>(
    pk0: [Polynomial<N>; L],
    pk1: [Polynomial<N>; L],
) -> Field {
    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);
    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);

    compute_commitments(payload, DS_PK_GENERATION, [0x80000000 | payload.len(), 1]).get(0)
}

pub fn compute_share_computation_sk_commitment<let N: u32, let BIT_SK: u32>(
    sk: Polynomial<N>,
) -> Field {
    let mut payload = single_polynomial_payload::<N, BIT_SK>(Vec::new(), sk);
    compute_commitments(
        payload,
        DS_SHARE_COMPUTATION,
        [0x80000000 | payload.len(), 1],
    )
        .get(0)
}

pub fn compute_share_computation_e_sm_commitment<let N: u32, let L: u32, let BIT_E_SM: u32>(
    e_sm: [Polynomial<N>; L],
) -> Field {
    let mut payload = multiple_polynomial_payload::<N, L, BIT_E_SM>(Vec::new(), e_sm);
    compute_commitments(
        payload,
        DS_SHARE_COMPUTATION,
        [0x80000000 | payload.len(), 1],
    )
        .get(0)
}

pub fn compute_share_encryption_commitment_from_message<let N: u32, let BIT_MSG: u32>(
    message: Polynomial<N>,
) -> Field {
    let mut payload = single_polynomial_payload::<N, BIT_MSG>(Vec::new(), message);
    compute_commitments(
        payload,
        DS_SHARE_ENCRYPTION,
        [0x80000000 | payload.len(), 1],
    )
        .get(0)
}

pub fn compute_share_encryption_commitment_from_shares<let N: u32, let L: u32, let N_PARTIES: u32>(
    y: [[[Field; N_PARTIES + 1]; L]; N],
    party_idx: u32,
    mod_idx: u32,
) -> Field {
    let mut payload = Vec::new();

    for coeff_idx in 0..N {
        payload.push(y[coeff_idx][mod_idx][party_idx + 1]);
    }

    // Include party_idx and mod_idx in the hash
    payload.push(party_idx as Field);
    payload.push(mod_idx as Field);

    compute_commitments(
        payload,
        DS_SHARE_ENCRYPTION,
        [0x80000000 | payload.len(), 1],
    )
        .get(0)
}

pub fn compute_aggregated_shares_commitment<let N: u32, let L: u32, let BIT_MSG: u32>(
    agg_shares: [Polynomial<N>; L],
) -> Field {
    let mut payload = multiple_polynomial_payload::<N, L, BIT_MSG>(Vec::new(), agg_shares);
    compute_commitments(
        payload,
        DS_AGGREGATED_SHARES,
        [0x80000000 | payload.len(), 1],
    )
        .get(0)
}

pub fn compute_threshold_pk_aggregation_commitment<let N: u32, let L: u32, let BIT_PK: u32>(
    pk0: [Polynomial<N>; L],
    pk1: [Polynomial<N>; L],
) -> Field {
    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);
    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);

    compute_commitments(payload, DS_PK_AGGREGATION, [0x80000000 | payload.len(), 1]).get(0)
}

pub fn compute_aggregation_commitment(payload: Vec<Field>) -> Field {
    compute_safe(DS_AGGREGATION, payload, [0x80000000 | payload.len(), 1]).get(0)
}

pub fn compute_ciphertext_commitment<let N: u32, let L: u32, let BIT_CT: u32>(
    ct0: [Polynomial<N>; L],
    ct1: [Polynomial<N>; L],
) -> Field {
    let mut payload = multiple_polynomial_payload::<N, L, BIT_CT>(Vec::new(), ct0);
    payload = multiple_polynomial_payload::<N, L, BIT_CT>(payload, ct1);

    compute_commitments(payload, DS_CIPHERTEXT, [0x80000000 | payload.len(), 1]).get(0)
}

/// COMMITMENTS FOR CHALLENGES

pub fn compute_threshold_pk_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {
    compute_commitments(
        payload,
        DS_CLG_PK_GENERATION,
        [0x80000000 | payload.len(), 2 * L],
    )
}

pub fn compute_share_encryption_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {
    compute_commitments(
        payload,
        DS_CLG_SHARE_ENCRYPTION,
        [0x80000000 | payload.len(), 2 * L],
    )
}

pub fn compute_user_data_encryption_challenge_commitment<let N: u32, let L: u32, let BIT_PK: u32>(
    pk0is: [Polynomial<N>; L],
    pk1is: [Polynomial<N>; L],
    gammas_payload: Vec<Field>,
    pk_commitment: Field,
) -> Vec<Field> {
    assert(
        compute_threshold_pk_aggregation_commitment::<N, L, BIT_PK>(pk0is, pk1is) == pk_commitment,
    );

    compute_commitments(
        gammas_payload,
        DS_CLG_USER_DATA_ENCRYPTION,
        [0x80000000 | gammas_payload.len(), 2 * L],
    )
}

pub fn compute_threshold_share_decryption_challenge<let L: u32>(payload: Vec<Field>) -> Field {
    compute_commitments(
        payload,
        DS_CLG_SHARE_DECRYPTION,
        [0x80000000 | payload.len(), 1],
    )
        .get(0)
}
