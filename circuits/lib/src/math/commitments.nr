// SPDX-License-Identifier: LGPL-3.0-only
//
// This file is provided WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.

use crate::math::helpers::{compute_safe, flatten};
use crate::math::polynomial::Polynomial;

/// DOMAIN SEPARATORS

// Domain separator - "PK_BFV"
pub global DS_PK_BFV: [u8; 64] = [
    0x50, 0x4b, 0x5f, 0x42, 0x46, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "PK_TRBFV"
pub global DS_PK_TRBFV: [u8; 64] = [
    0x50, 0x4b, 0x5f, 0x54, 0x52, 0x42, 0x46, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "SECRET"
pub global DS_SECRET: [u8; 64] = [
    0x53, 0x45, 0x43, 0x52, 0x45, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "SPM"
pub global DS_SPM: [u8; 64] = [
    0x53, 0x50, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "AGG_SHARES"
pub global DS_AGG_SHARES: [u8; 64] = [
    0x41, 0x47, 0x47, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45, 0x53, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "PK_AGG"
pub global DS_PK_AGG: [u8; 64] = [
    0x50, 0x4b, 0x5f, 0x41, 0x47, 0x47, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "AGGREGATION"
pub global DS_AGGREGATION: [u8; 64] = [
    0x41, 0x47, 0x47, 0x52, 0x45, 0x47, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "CIPHERTEXT"
pub global DS_CIPHERTEXT: [u8; 64] = [
    0x43, 0x49, 0x50, 0x48, 0x45, 0x52, 0x54, 0x45, 0x58, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "CLG_PK_TRBFV"
pub global DS_CLG_PK_TRBFV: [u8; 64] = [
    0x43, 0x4c, 0x47, 0x5f, 0x50, 0x4b, 0x5f, 0x54, 0x52, 0x42, 0x46, 0x56, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "CLG_ENC_BFV"
pub global DS_CLG_ENC_BFV: [u8; 64] = [
    0x43, 0x4c, 0x47, 0x5f, 0x45, 0x4e, 0x43, 0x5f, 0x42, 0x46, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "CLG_GRECO"
pub global DS_CLG_GRECO: [u8; 64] = [
    0x43, 0x4c, 0x47, 0x5f, 0x47, 0x52, 0x45, 0x43, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];
// Domain separator - "CLG_DEC_SHARE"
pub global DS_CLG_DEC_SHARE: [u8; 64] = [
    0x43, 0x4c, 0x47, 0x5f, 0x44, 0x45, 0x43, 0x5f, 0x53, 0x48, 0x41, 0x52, 0x45, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

/// WRAPPERS

pub fn compute_commitments(
    payload: Vec<Field>,
    domain_separator: [u8; 64],
    io_pattern: [u32; 2],
) -> Vec<Field> {
    compute_safe(domain_separator, payload, io_pattern)
}

pub fn single_polynomial_payload<let N: u32, let BIT_POLY: u32>(
    payload: Vec<Field>,
    input: Polynomial<N>,
) -> Vec<Field> {
    flatten::<_, _, BIT_POLY>(payload, [input])
}

pub fn multiple_polynomial_payload<let N: u32, let L: u32, let BIT_POLY: u32>(
    payload: Vec<Field>,
    inputs: [Polynomial<N>; L],
) -> Vec<Field> {
    flatten::<_, _, BIT_POLY>(payload, inputs)
}

/// COMMITMENTS

pub fn compute_pk_bfv_commitment<let N: u32, let L: u32, let BIT_PK: u32>(
    pk0: [Polynomial<N>; L],
    pk1: [Polynomial<N>; L],
) -> Field {
    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);
    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);

    compute_commitments(payload, DS_PK_BFV, [0x80000000 | payload.len(), 1]).get(0)
}

pub fn compute_pk_trbfv_commitment<let N: u32, let L: u32, let BIT_PK: u32>(
    pk0: [Polynomial<N>; L],
    pk1: [Polynomial<N>; L],
) -> Field {
    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);
    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);

    compute_commitments(payload, DS_PK_TRBFV, [0x80000000 | payload.len(), 1]).get(0)
}

pub fn compute_secret_sk_commitment<let N: u32, let BIT_SK: u32>(sk: Polynomial<N>) -> Field {
    let mut payload = single_polynomial_payload::<N, BIT_SK>(Vec::new(), sk);
    compute_commitments(payload, DS_SECRET, [0x80000000 | payload.len(), 1]).get(0)
}

pub fn compute_secret_e_sm_commitment<let N: u32, let L: u32, let BIT_E_SM: u32>(
    e_sm: [Polynomial<N>; L],
) -> Field {
    let mut payload = multiple_polynomial_payload::<N, L, BIT_E_SM>(Vec::new(), e_sm);
    compute_commitments(payload, DS_SECRET, [0x80000000 | payload.len(), 1]).get(0)
}

pub fn compute_spm_commitment_from_message<let N: u32, let BIT_MSG: u32>(
    message: Polynomial<N>,
) -> Field {
    let mut payload = single_polynomial_payload::<N, BIT_MSG>(Vec::new(), message);
    compute_commitments(payload, DS_SPM, [0x80000000 | payload.len(), 1]).get(0)
}

pub fn compute_spm_commitment_from_shares<let N: u32, let L: u32, let N_PARTIES: u32>(
    y: [[[Field; N_PARTIES + 1]; L]; N],
    party_idx: u32,
    mod_idx: u32,
) -> Field {
    let mut payload = Vec::new();

    for coeff_idx in 0..N {
        payload.push(y[coeff_idx][mod_idx][party_idx + 1]);
    }

    // Include party_idx and mod_idx in the hash
    payload.push(party_idx as Field);
    payload.push(mod_idx as Field);

    compute_commitments(payload, DS_SPM, [0x80000000 | payload.len(), 1]).get(0)
}

pub fn compute_aggregated_shares_commitment<let N: u32, let L: u32, let BIT_MSG: u32>(
    agg_shares: [Polynomial<N>; L],
) -> Field {
    let mut payload = multiple_polynomial_payload::<N, L, BIT_MSG>(Vec::new(), agg_shares);
    compute_commitments(payload, DS_AGG_SHARES, [0x80000000 | payload.len(), 1]).get(0)
}

pub fn compute_pk_agg_commitment<let N: u32, let L: u32, let BIT_PK: u32>(
    pk0: [Polynomial<N>; L],
    pk1: [Polynomial<N>; L],
) -> Field {
    let mut payload = multiple_polynomial_payload::<N, L, BIT_PK>(Vec::new(), pk0);
    payload = multiple_polynomial_payload::<N, L, BIT_PK>(payload, pk1);

    compute_commitments(payload, DS_PK_AGG, [0x80000000 | payload.len(), 1]).get(0)
}

pub fn compute_aggregation_commitment(payload: Vec<Field>) -> Field {
    compute_safe(DS_AGGREGATION, payload, [0x80000000 | payload.len(), 1]).get(0)
}

pub fn compute_ciphertext_commitment<let N: u32, let L: u32, let BIT_CT: u32>(
    ct0: [Polynomial<N>; L],
    ct1: [Polynomial<N>; L],
) -> Field {
    let mut payload = multiple_polynomial_payload::<N, L, BIT_CT>(Vec::new(), ct0);
    payload = multiple_polynomial_payload::<N, L, BIT_CT>(payload, ct1);

    compute_commitments(payload, DS_CIPHERTEXT, [0x80000000 | payload.len(), 1]).get(0)
}

/// COMMITMENTS FOR CHALLENGES

pub fn compute_pk_trbfv_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {
    compute_commitments(
        payload,
        DS_CLG_PK_TRBFV,
        [0x80000000 | payload.len(), 2 * L],
    )
}

pub fn compute_bfv_enc_challenge<let L: u32>(payload: Vec<Field>) -> Vec<Field> {
    compute_commitments(payload, DS_CLG_ENC_BFV, [0x80000000 | payload.len(), 2 * L])
}

pub fn compute_greco_challenge_commitment<let N: u32, let L: u32, let BIT_PK: u32>(
    pk0is: [Polynomial<N>; L],
    pk1is: [Polynomial<N>; L],
    gammas_payload: Vec<Field>,
    pk_commitment: Field,
) -> Vec<Field> {
    assert(compute_pk_agg_commitment::<N, L, BIT_PK>(pk0is, pk1is) == pk_commitment);

    compute_commitments(
        gammas_payload,
        DS_CLG_GRECO,
        [0x80000000 | gammas_payload.len(), 2 * L],
    )
}

pub fn compute_dec_share_challenge<let L: u32>(payload: Vec<Field>) -> Field {
    compute_commitments(payload, DS_CLG_DEC_SHARE, [0x80000000 | payload.len(), 1]).get(0)
}
