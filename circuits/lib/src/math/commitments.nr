// SPDX-License-Identifier: LGPL-3.0-only
//
// This file is provided WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.

use crate::math::helpers::{compute_safe, flatten};
use crate::math::polynomial::Polynomial;

/// Prepares the payload for TRBFV & BFV public key commitment
/// Flattens pk0 and pk1 polynomial arrays into a single Vec<Field>
/// Used in C0, C1, C3.
pub fn prepare_pk_commitment_payload<let N: u32, let L: u32, let BIT_PK: u32>(
    pk0: [Polynomial<N>; L],
    pk1: [Polynomial<N>; L],
) -> Vec<Field> {
    let mut inputs = Vec::new();

    // Flatten pk0 polynomials
    inputs = flatten::<_, _, BIT_PK>(inputs, pk0);

    // Flatten pk1 polynomials
    inputs = flatten::<_, _, BIT_PK>(inputs, pk1);

    inputs
}

/// Flattens shares for a specific party and modulus into Vec<Field>
/// Returns N field elements: y[0][mod_idx][party_idx+1], ..., y[N-1][mod_idx][party_idx+1]
/// Used in C2.
pub fn prepare_shares_party_modulus_commitment_payload<let N: u32, let L: u32, let N_PARTIES: u32>(
    y: [[[Field; N_PARTIES + 1]; L]; N],
    party_idx: u32,
    mod_idx: u32,
) -> Vec<Field> {
    let mut inputs = Vec::new();

    for coeff_idx in 0..N {
        inputs.push(y[coeff_idx][mod_idx][party_idx + 1]);
    }

    // Include party_idx and mod_idx in the hash
    inputs.push(party_idx as Field);
    inputs.push(mod_idx as Field);

    inputs
}

/// Prepares the payload for message commitment (must match C2).
/// Used in C3.
pub fn prepare_message_commitment_payload<let N: u32>(message: Polynomial<N>) -> Vec<Field> {
    let mut inputs = Vec::new();

    for i in 0..N {
        inputs.push(message.coefficients[i]);
    }

    inputs
}

/// Prepares the payload for single polynomial commitment (must match C2).
/// Used in C1, C2, C4.
pub fn prepare_single_polynomial_commitment_payload<let N: u32, let BIT_POLY: u32>(
    poly: Polynomial<N>,
) -> Vec<Field> {
    flatten::<_, _, BIT_POLY>(Vec::new(), [poly])
}

/// Prepares the payload for aggregated shares commitment.
/// Used in C4.
pub fn prepare_aggregated_shares_commitment_payload<let N: u32, let L: u32, let BIT_MSG: u32>(
    aggregated: [Polynomial<N>; L],
) -> Vec<Field> {
    flatten::<_, _, BIT_MSG>(Vec::new(), aggregated)
}

/// Prepares the payload for aggregated shares from values commitment.
/// Used in C6.
pub fn prepare_aggregated_shares_from_values_commitment_payload<let N: u32, let L: u32>(
    values: [Polynomial<N>; L],
) -> Vec<Field> {
    let mut inputs = Vec::new();

    for basis_idx in 0..L {
        for coeff_idx in 0..N {
            inputs.push(values[basis_idx].coefficients[coeff_idx]);
        }
    }

    inputs
}

/// Computes commitment to the BFV public key
/// Used in C0, C3.
pub fn compute_pk_bfv_commitment(payload: Vec<Field>) -> Field {
    // Domain separator - "PVSS_pk_bfv"
    let domain_separator = [
        0x50, 0x56, 0x53, 0x53, 0x5f, 0x70, 0x6b, 0x5f, 0x62, 0x66, 0x76, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    compute_safe(
        domain_separator,
        payload,
        [0x80000000 | payload.len(), 0x00000001],
    )
        .get(0)
}

/// Computes commitment to the TRBFV public key
/// Used in C1.
pub fn compute_pk_trbfv_commitment(payload: Vec<Field>) -> Field {
    // Domain separator - "PVSS_pk_trbfv" in hex
    let domain_separator = [
        0x50, 0x56, 0x53, 0x53, 0x5f, 0x70, 0x6b, 0x5f, 0x74, 0x72, 0x62, 0x66, 0x76, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    compute_safe(
        domain_separator,
        payload,
        [0x80000000 | payload.len(), 0x00000001],
    )
        .get(0)
}

/// Computes commitment to the secret (either sk_trbfv or e_sm)
/// Used in C1, C2.
pub fn compute_secret_commitment(payload: Vec<Field>) -> Field {
    // Domain separator - "PVSS_secret" in hex
    let domain_separator = [
        0x50, 0x56, 0x53, 0x53, 0x5f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    compute_safe(
        domain_separator,
        payload,
        [0x80000000 | payload.len(), 0x00000001],
    )
        .get(0)
}

/// Computes share party-modulus commitment (either sk_shares or e_sm_shares)
/// Used in C2, C3 (message), C4 (single polynomial).
pub fn compute_shares_party_modulus_commitment(payload: Vec<Field>) -> Field {
    // Domain separator - "PVSS_sh_pm" (shares party-modulus)
    let domain_separator = [
        0x50, 0x56, 0x53, 0x53, 0x5f, 0x73, 0x68, 0x5f, 0x70, 0x6d, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    compute_safe(
        domain_separator,
        payload,
        [0x80000000 | payload.len(), 0x00000001],
    )
        .get(0)
}

/// Computes aggregated shares commitment (either sk_shares or e_sm_shares)
/// Used in C4.
pub fn compute_aggregated_shares_commitment(payload: Vec<Field>) -> Field {
    // Domain separator - "PVSS_agg_sh"
    let domain_separator = [
        0x50, 0x56, 0x53, 0x53, 0x5f, 0x61, 0x67, 0x67, 0x5f, 0x73, 0x68, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    compute_safe(
        domain_separator,
        payload,
        [0x80000000 | payload.len(), 0x00000001],
    )
        .get(0)
}

/// Computes decryption share challenge commitment
/// Used in C6.
pub fn compute_dec_share_challenge_commitment(payload: Vec<Field>) -> Field {
    // Domain separator for decryption share circuit - "DecShare" in hex
    let domain_separator = [
        0x44, 0x65, 0x63, 0x53, 0x68, 0x61, 0x72, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    // IO Pattern: ABSORB(input_size), SQUEEZE(1)
    let input_size = payload.len();
    let io_pattern = [0x80000000 | input_size, 0x00000001];

    compute_safe(domain_separator, payload, io_pattern).get(0)
}

/// Computes TRBFV pk challenge commitment
/// Used in C1.
pub fn compute_trbfv_pk_challenge_commitment<let L: u32>(payload: Vec<Field>) -> Vec<Field> {
    // Domain separator for trbfv_pk circuit - "trbfv_pk" in hex
    let domain_separator = [
        0x74, 0x72, 0x62, 0x66, 0x76, 0x5f, 0x70, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    // IO Pattern: ABSORB(input_size), SQUEEZE(2 * L)
    let input_size = payload.len();
    let io_pattern = [0x80000000 | input_size, 0x00000000 | (2 * L)];

    compute_safe(domain_separator, payload, io_pattern)
}

/// Computes Greco pk agg commitment
/// Used in Greco, C5.
pub fn compute_greco_pk_agg_commitment(payload: Vec<Field>) -> Field {
    // Domain separator - "Greco"
    let domain_separator = [
        0x47, 0x72, 0x65, 0x63, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    // IO Pattern: ABSORB(input_size), SQUEEZE(1)
    let input_size = payload.len();
    let io_pattern = [0x80000000 | input_size, 0x00000000 | 1];

    compute_safe(domain_separator, payload, io_pattern).get(0)
}

/// Computes Greco challenge commitment
/// Used in Greco.
pub fn compute_greco_challenge_commitment<let L: u32>(
    commitment_payload: Vec<Field>,
    gammas_payload: Vec<Field>,
    pk_commitment: Field,
) -> Vec<Field> {
    // Domain separator - "Greco"
    let domain_separator = [
        0x47, 0x72, 0x65, 0x63, 0x6f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    assert(compute_greco_pk_agg_commitment(commitment_payload) == pk_commitment);

    // IO Pattern: ABSORB(input_size), SQUEEZE(2*L)
    let input_size = gammas_payload.len();
    let io_pattern = [0x80000000 | input_size, 0x00000000 | (2 * L)];

    compute_safe(domain_separator, gammas_payload, io_pattern)
}

/// Computes BFV encryption challenge commitment
/// Used in C3.
pub fn compute_bfv_enc_challenge_commitment<let L: u32>(payload: Vec<Field>) -> Vec<Field> {
    // Domain separator - "EncBfv"
    let domain_separator = [
        0x45, 0x6e, 0x63, 0x42, 0x66, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    let input_size = payload.len();
    let io_pattern = [0x80000000 | input_size, 0x00000000 | (2 * L)];

    compute_safe(domain_separator, payload, io_pattern)
}

/// Computes aggregation commitment
/// Used in aggregation circuits.
pub fn compute_aggregation_commitment(payload: Vec<Field>) -> Field {
    // Domain separator - "Aggregation"
    let domain_separator = [
        0x41, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
    ];

    // IO Pattern: ABSORB(payload.len()), SQUEEZE(1)
    let io_pattern = [0x80000000 | payload.len(), 0x00000001];

    compute_safe(domain_separator, payload, io_pattern).get(0)
}
