// SPDX-License-Identifier: LGPL-3.0-only
//
// This file is provided WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.

use enclave_lib::math::commitments::compute_commitments;
use enclave_lib::math::commitments::multiple_polynomial_payload;
use enclave_lib::math::commitments::single_polynomial_payload;
use enclave_lib::math::polynomial::Polynomial;

// Domain separator - "CRISP_CT"
pub global DS_CRISP_CT: [u8; 64] = [
    0x43, 0x52, 0x49, 0x53, 0x50, 0x5f, 0x43, 0x54, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

// Domain separator - "CRISP_K1"
pub global DS_CRISP_K1: [u8; 64] = [
    0x43, 0x52, 0x49, 0x53, 0x50, 0x5f, 0x4b, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

pub fn compute_ct_commitment<let N: u32, let L: u32, let BIT_CT: u32>(
    ct0: [Polynomial<N>; L],
    ct1: [Polynomial<N>; L],
) -> Field {
    let mut payload = multiple_polynomial_payload::<N, L, BIT_CT>(Vec::new(), ct0);
    payload = multiple_polynomial_payload::<N, L, BIT_CT>(payload, ct1);

    compute_commitments(payload, DS_CRISP_CT, [0x80000000 | payload.len(), 1]).get(0)
}

pub fn compute_k1_commitment<let N: u32, let BIT_K1: u32>(k1: Polynomial<N>) -> Field {
    let mut payload = single_polynomial_payload::<N, BIT_K1>(Vec::new(), k1);
    compute_commitments(payload, DS_CRISP_K1, [0x80000000 | payload.len(), 1]).get(0)
}
