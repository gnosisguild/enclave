// SPDX-License-Identifier: LGPL-3.0-only
//
// This file is provided WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.

use e3_bfv_client::decode_bytes_to_vec_u64;
use eyre::Result;
use num_bigint::BigUint;

/// Maximum number of bits that can fit each vote option.
pub const MAX_VOTE_BITS: usize = 50;

/// Represents decoded vote counts from a tally
#[derive(Debug, Clone)]
pub struct VoteCounts {
    pub yes: BigUint,
    pub no: BigUint,
}

/// Decode an encoded tally into its decimal representation.
///
/// The plaintext output from FHE computation contains the result as bytes.
/// Votes are encoded with yes votes in the first half and no votes in the second half,
/// right-aligned with leading zeros.
///
/// # Arguments
///
/// * `tally_bytes` - The encoded tally as bytes (little-endian format of u64s)
///
/// # Returns
///
/// A `VoteCounts` struct containing the decoded yes and no vote counts
pub fn decode_tally(tally_bytes: &[u8], num_choices: usize) -> Result<Vec<BigUint>> {
    if num_choices == 0 {
        return Err(eyre::eyre!("Number of choices must be positive"));
    }

    // Decode bytes to u64 array (little-endian, 8 bytes per value)
    let values = decode_bytes_to_vec_u64(tally_bytes)?;

    let segment_size = values.len() / num_choices;
    let effective_size = segment_size.min(MAX_VOTE_BITS);

    let mut results = Vec::with_capacity(num_choices);

    for choice_idx in 0..num_choices {
        let segment_start = choice_idx * segment_size;
        let read_start = segment_start + segment_size - effective_size;
        let segment = &values[read_start..read_start + effective_size];

        let mut value = BigUint::from(0u64);
        for (i, &v) in segment.iter().enumerate() {
            let weight = BigUint::from(2u64).pow((segment.len() - 1 - i) as u32);
            value += BigUint::from(v) * weight;
        }

        results.push(value);
    }

    Ok(results)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_decode_tally_fhe_output() {
        // Expected: yes = 10000000000, no = 30000000000
        let tally_hex = "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000001000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000100000000000000010000000000000001000000000000000100000000000000010000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000300000000000000000000000000000003000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000030000000000000003000000000000000300000000000000030000000000000003000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

        let bytes = hex::decode(tally_hex.strip_prefix("0x").unwrap_or(tally_hex)).unwrap();
        let result = decode_tally(&bytes, 2).unwrap();

        assert_eq!(result[0], BigUint::from(10000000000u64));
        assert_eq!(result[1], BigUint::from(30000000000u64));
    }

    #[test]
    fn test_decode_tally_with_wrong_num_options() {
        // Expected: yes = 10000000000, no = 30000000000
        let tally_hex = "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000001000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000100000000000000010000000000000001000000000000000100000000000000010000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000300000000000000000000000000000003000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000030000000000000003000000000000000300000000000000030000000000000003000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

        let bytes = hex::decode(tally_hex.strip_prefix("0x").unwrap_or(tally_hex)).unwrap();
        let result = decode_tally(&bytes, 3).unwrap();

        assert!(result[0] != BigUint::from(10000000000u64));
        assert!(result[1] != BigUint::from(30000000000u64));
    }
}
