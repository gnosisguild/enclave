// SPDX-License-Identifier: LGPL-3.0-only
//
// This file is provided WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.

use e3_sdk::bfv_helpers::decode_bytes_to_vec_u64;
use eyre::Result;

/// Represents decoded vote counts from a tally
#[derive(Debug, Clone, Copy)]
pub struct VoteCounts {
    pub yes: u64,
    pub no: u64,
}

/// Decode an encoded tally into its decimal representation.
///
/// The plaintext output from FHE computation contains the result as bytes.
/// Votes are encoded with yes votes in the first half and no votes in the second half,
/// right-aligned with leading zeros.
///
/// # Arguments
///
/// * `tally_bytes` - The encoded tally as bytes (little-endian format of u64s)
///
/// # Returns
///
/// A `VoteCounts` struct containing the decoded yes and no vote counts
pub fn decode_tally(tally_bytes: &[u8]) -> Result<VoteCounts> {
    // Decode bytes to numbers array (little-endian, 8 bytes per value)
    let decoded = decode_bytes_to_vec_u64(tally_bytes)?;

    // Votes are right-aligned with leading zeros, so we can use the entire halves
    let half_d = decoded.len() / 2;
    let yes_binary = &decoded[0..half_d];
    let no_binary = &decoded[half_d..decoded.len()];

    // Convert yes votes (entire first half)
    let mut yes = 0u64;
    for (i, &value) in yes_binary.iter().enumerate() {
        let weight = 2u64.pow((yes_binary.len() - 1 - i) as u32);
        yes += value * weight;
    }

    // Convert no votes (entire second half)
    let mut no = 0u64;
    for (i, &value) in no_binary.iter().enumerate() {
        let weight = 2u64.pow((no_binary.len() - 1 - i) as u32);
        no += value * weight;
    }

    Ok(VoteCounts { yes, no })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_decode_tally_real_fhe_output() {
        // Real FHE computation output
        // Expected: yes = 10000000000, no = 30000000000
        let tally_hex = "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000001000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000100000000000000010000000000000001000000000000000100000000000000010000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000300000000000000000000000000000003000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000030000000000000003000000000000000300000000000000030000000000000003000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

        let bytes = hex::decode(tally_hex.strip_prefix("0x").unwrap_or(tally_hex)).unwrap();
        let result = decode_tally(&bytes).unwrap();

        assert_eq!(result.yes, 10000000000);
        assert_eq!(result.no, 30000000000);
    }
}
