// SPDX-License-Identifier: LGPL-3.0-only
//
// This file is provided WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY
// or FITNESS FOR A PARTICULAR PURPOSE.

use e3_sdk::bfv_helpers::decode_bytes_to_vec_u64;
use eyre::Result;
use num_bigint::BigUint;

/// Represents decoded vote counts from a tally
#[derive(Debug, Clone)]
pub struct VoteCounts {
    pub yes: BigUint,
    pub no: BigUint,
}

/// Decode an encoded tally into its decimal representation.
///
/// The plaintext output from FHE computation contains the result as bytes.
/// Votes are encoded with yes votes in the first half and no votes in the second half,
/// right-aligned with leading zeros.
///
/// # Arguments
///
/// * `tally_bytes` - The encoded tally as bytes (little-endian format of u64s)
///
/// # Returns
///
/// A `VoteCounts` struct containing the decoded yes and no vote counts
pub fn decode_tally(tally_bytes: &[u8]) -> Result<VoteCounts> {
    // Decode bytes to numbers array (little-endian, 8 bytes per value)
    let decoded = decode_bytes_to_vec_u64(tally_bytes)?;

    // Votes are right-aligned with leading zeros, so we can use the entire halves
    let half_d = decoded.len() / 2;
    let yes_binary = &decoded[0..half_d];
    let no_binary = &decoded[half_d..decoded.len()];

    // Convert yes votes (entire first half)
    let mut yes = BigUint::from(0u64);
    for (i, &value) in yes_binary.iter().enumerate() {
        let weight = BigUint::from(2u64).pow((yes_binary.len() - 1 - i) as u32);
        yes += BigUint::from(value) * weight;
    }

    // Convert no votes (entire second half)
    let mut no = BigUint::from(0u64);
    for (i, &value) in no_binary.iter().enumerate() {
        let weight = BigUint::from(2u64).pow((no_binary.len() - 1 - i) as u32);
        no += BigUint::from(value) * weight;
    }

    Ok(VoteCounts { yes, no })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_decode_tally_fhe_output() {
        // Expected: yes = 10000000000, no = 30000000000
        let tally_hex = "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000001000000000000000000000000000000010000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000100000000000000010000000000000001000000000000000100000000000000010000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000300000000000000000000000000000003000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000030000000000000003000000000000000300000000000000030000000000000003000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";

        let bytes = hex::decode(tally_hex.strip_prefix("0x").unwrap_or(tally_hex)).unwrap();
        let result = decode_tally(&bytes).unwrap();

        assert_eq!(result.yes, BigUint::from(10000000000u64));
        assert_eq!(result.no, BigUint::from(30000000000u64));
    }
}
