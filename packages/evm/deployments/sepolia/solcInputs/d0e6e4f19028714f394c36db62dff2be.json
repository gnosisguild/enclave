{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/Enclave.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.26;\n\nimport {\n    IEnclave,\n    E3,\n    IComputationModule,\n    IExecutionModule\n} from \"./interfaces/IEnclave.sol\";\nimport { ICyphernodeRegistry } from \"./interfaces/ICyphernodeRegistry.sol\";\nimport { IInputValidator } from \"./interfaces/IInputValidator.sol\";\nimport { IOutputVerifier } from \"./interfaces/IOutputVerifier.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract Enclave is IEnclave, OwnableUpgradeable {\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                 Storage Variables                      //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    ICyphernodeRegistry public cyphernodeRegistry; // address of the Cyphernode registry.\n    uint256 public maxDuration; // maximum duration of a computation in seconds.\n    uint256 public nexte3Id; // ID of the next E3.\n    uint256 public requests; // total number of requests made to Enclave.\n\n    // TODO: should computation and execution modules be explicitly allowed?\n    // My intuition is that an allowlist is required since they impose slashing conditions.\n    // But perhaps this is one place where node pools might be utilized, allowing nodes to\n    // opt in to being selected for specific computations, along with the corresponding slashing conditions.\n    // This would reduce the governance overhead for Enclave.\n\n    // Mapping of allowed computation modules.\n    mapping(IComputationModule computationModule => bool allowed)\n        public computationModules;\n\n    // Mapping of allowed execution modules.\n    mapping(IExecutionModule executionModule => bool allowed)\n        public executionModules;\n\n    // Mapping of E3s.\n    mapping(uint256 id => E3 e3) public e3s;\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                        Errors                          //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    error CommitteeSelectionFailed();\n    error ComputationModuleNotAllowed(IComputationModule computationModule);\n    error E3AlreadyActivated(uint256 e3Id);\n    error E3Expired();\n    error E3NotActivated(uint256 e3Id);\n    error E3NotReady();\n    error E3DoesNotExist(uint256 e3Id);\n    error ModuleAlreadyEnabled(address module);\n    error ModuleNotEnabled(address module);\n    error InputDeadlinePassed(uint256 e3Id, uint256 expiration);\n    error InputDeadlineNotPassed(uint256 e3Id, uint256 expiration);\n    error InvalidComputation();\n    error InvalidExecutionModuleSetup();\n    error InvalidCyphernodeRegistry(ICyphernodeRegistry cyphernodeRegistry);\n    error InvalidInput();\n    error InvalidDuration(uint256 duration);\n    error InvalidOutput(bytes output);\n    error InvalidStartWindow();\n    error InvalidThreshold(uint32[2] threshold);\n    error CiphertextOutputAlreadyPublished(uint256 e3Id);\n    error CiphertextOutputNotPublished(uint256 e3Id);\n    error PaymentRequired(uint256 value);\n    error PlaintextOutputAlreadyPublished(uint256 e3Id);\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                   Initialization                       //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    /// @param _owner The owner of this contract\n    /// @param _maxDuration The maximum duration of a computation in seconds\n    constructor(\n        address _owner,\n        ICyphernodeRegistry _cyphernodeRegistry,\n        uint256 _maxDuration\n    ) {\n        initialize(_owner, _cyphernodeRegistry, _maxDuration);\n    }\n\n    /// @param _owner The owner of this contract\n    /// @param _maxDuration The maximum duration of a computation in seconds\n    function initialize(\n        address _owner,\n        ICyphernodeRegistry _cyphernodeRegistry,\n        uint256 _maxDuration\n    ) public initializer {\n        __Ownable_init(msg.sender);\n        setMaxDuration(_maxDuration);\n        setCyphernodeRegistry(_cyphernodeRegistry);\n        if (_owner != owner()) transferOwnership(_owner);\n    }\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                  Core Entrypoints                      //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    function request(\n        address filter,\n        uint32[2] calldata threshold,\n        uint256[2] calldata startWindow,\n        uint256 duration,\n        IComputationModule computationModule,\n        bytes memory computationParams,\n        IExecutionModule executionModule,\n        bytes memory emParams\n    ) external payable returns (uint256 e3Id, E3 memory e3) {\n        // TODO: allow for other payment methods or only native tokens?\n        // TODO: should payment checks be somewhere else? Perhaps in the computation module or cyphernode registry?\n        require(msg.value > 0, PaymentRequired(msg.value));\n        require(\n            threshold[1] >= threshold[0] && threshold[0] > 0,\n            InvalidThreshold(threshold)\n        );\n        require(\n            // TODO: do we need a minimum start window to allow time for committee selection?\n            startWindow[1] >= startWindow[0] &&\n                startWindow[1] >= block.timestamp,\n            InvalidStartWindow()\n        );\n        require(\n            duration > 0 && duration <= maxDuration,\n            InvalidDuration(duration)\n        );\n        require(\n            computationModules[computationModule],\n            ComputationModuleNotAllowed(computationModule)\n        );\n        require(\n            executionModules[executionModule],\n            ModuleNotEnabled(address(executionModule))\n        );\n\n        // TODO: should IDs be incremental or produced deterministically?\n        e3Id = nexte3Id;\n        nexte3Id++;\n\n        IInputValidator inputValidator = computationModule.validate(\n            computationParams\n        );\n        require(address(inputValidator) != address(0), InvalidComputation());\n\n        // TODO: validate that the requested computation can be performed by the given execution module.\n        IOutputVerifier outputVerifier = executionModule.validate(emParams);\n        require(\n            address(outputVerifier) != address(0),\n            InvalidExecutionModuleSetup()\n        );\n\n        e3 = E3({\n            threshold: threshold,\n            startWindow: startWindow,\n            duration: duration,\n            expiration: 0,\n            computationModule: computationModule,\n            executionModule: executionModule,\n            inputValidator: inputValidator,\n            outputVerifier: outputVerifier,\n            committeePublicKey: hex\"\",\n            inputs: new bytes[](0),\n            ciphertextOutput: hex\"\",\n            plaintextOutput: hex\"\"\n        });\n        e3s[e3Id] = e3;\n\n        require(\n            cyphernodeRegistry.requestCommittee(e3Id, filter, threshold),\n            CommitteeSelectionFailed()\n        );\n\n        emit E3Requested(\n            e3Id,\n            e3s[e3Id],\n            filter,\n            computationModule,\n            executionModule\n        );\n    }\n\n    function activate(uint256 e3Id) external returns (bool success) {\n        // Note: we could load this into a storage pointer, and do the sets there\n        // Requires a mew internal _getter that returns storage\n        E3 memory e3 = getE3(e3Id);\n        require(e3.expiration == 0, E3AlreadyActivated(e3Id));\n        require(e3.startWindow[0] <= block.timestamp, E3NotReady());\n        // TODO: handle what happens to the payment if the start window has passed.\n        require(e3.startWindow[1] >= block.timestamp, E3Expired());\n\n        bytes memory publicKey = cyphernodeRegistry.committeePublicKey(e3Id);\n        // Note: This check feels weird\n        require(publicKey.length > 0, CommitteeSelectionFailed());\n\n        e3s[e3Id].expiration = block.timestamp + e3.duration;\n        e3s[e3Id].committeePublicKey = publicKey;\n\n        emit E3Activated(e3Id, e3.expiration, e3.committeePublicKey);\n\n        return true;\n    }\n\n    function publishInput(\n        uint256 e3Id,\n        bytes memory data\n    ) external returns (bool success) {\n        E3 memory e3 = getE3(e3Id);\n\n        // Note: if we make 0 a no expiration, this has to be refactored\n        require(e3.expiration > 0, E3NotActivated(e3Id));\n        // TODO: should we have an input window, including both a start and end timestamp?\n        require(\n            e3.expiration > block.timestamp,\n            InputDeadlinePassed(e3Id, e3.expiration)\n        );\n        bytes memory input;\n        (input, success) = e3.inputValidator.validate(msg.sender, data);\n        require(success, InvalidInput());\n        // TODO: probably better to accumulate inputs, rather than just dumping them in storage.\n        e3s[e3Id].inputs.push(input);\n        emit InputPublished(e3Id, input);\n    }\n\n    function publishCiphertextOutput(\n        uint256 e3Id,\n        bytes memory data\n    ) external returns (bool success) {\n        E3 memory e3 = getE3(e3Id);\n        // Note: if we make 0 a no expiration, this has to be refactored\n        require(e3.expiration > 0, E3NotActivated(e3Id));\n        require(\n            e3.expiration <= block.timestamp,\n            InputDeadlineNotPassed(e3Id, e3.expiration)\n        );\n        // TODO: should the output verifier be able to change its mind?\n        //i.e. should we be able to call this multiple times?\n        require(\n            e3.ciphertextOutput.length == 0,\n            CiphertextOutputAlreadyPublished(e3Id)\n        );\n        bytes memory output;\n        (output, success) = e3.outputVerifier.verify(e3Id, data);\n        require(success, InvalidOutput(output));\n        e3s[e3Id].ciphertextOutput = output;\n\n        emit CiphertextOutputPublished(e3Id, output);\n    }\n\n    function publishPlaintextOutput(\n        uint256 e3Id,\n        bytes memory data\n    ) external returns (bool success) {\n        E3 memory e3 = getE3(e3Id);\n        // Note: if we make 0 a no expiration, this has to be refactored\n        require(e3.expiration > 0, E3NotActivated(e3Id));\n        require(\n            e3.ciphertextOutput.length > 0,\n            CiphertextOutputNotPublished(e3Id)\n        );\n        require(\n            e3.plaintextOutput.length == 0,\n            PlaintextOutputAlreadyPublished(e3Id)\n        );\n        bytes memory output;\n        (output, success) = e3.computationModule.verify(e3Id, data);\n        require(success, InvalidOutput(output));\n        e3s[e3Id].plaintextOutput = output;\n\n        emit PlaintextOutputPublished(e3Id, output);\n    }\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                   Set Functions                        //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    function setMaxDuration(\n        uint256 _maxDuration\n    ) public onlyOwner returns (bool success) {\n        maxDuration = _maxDuration;\n        success = true;\n        emit MaxDurationSet(_maxDuration);\n    }\n\n    function setCyphernodeRegistry(\n        ICyphernodeRegistry _cyphernodeRegistry\n    ) public onlyOwner returns (bool success) {\n        require(\n            address(_cyphernodeRegistry) != address(0) &&\n                _cyphernodeRegistry != cyphernodeRegistry,\n            InvalidCyphernodeRegistry(_cyphernodeRegistry)\n        );\n        cyphernodeRegistry = _cyphernodeRegistry;\n        success = true;\n        emit CyphernodeRegistrySet(address(_cyphernodeRegistry));\n    }\n\n    function enableComputationModule(\n        IComputationModule computationModule\n    ) public onlyOwner returns (bool success) {\n        require(\n            !computationModules[computationModule],\n            ModuleAlreadyEnabled(address(computationModule))\n        );\n        computationModules[computationModule] = true;\n        success = true;\n        emit ComputationModuleEnabled(computationModule);\n    }\n\n    function enableExecutionModule(\n        IExecutionModule executionModule\n    ) public onlyOwner returns (bool success) {\n        require(\n            !executionModules[executionModule],\n            ModuleAlreadyEnabled(address(executionModule))\n        );\n        executionModules[executionModule] = true;\n        success = true;\n        emit ExecutionModuleEnabled(executionModule);\n    }\n\n    function disableComputationModule(\n        IComputationModule computationModule\n    ) public onlyOwner returns (bool success) {\n        require(\n            computationModules[computationModule],\n            ModuleNotEnabled(address(computationModule))\n        );\n        delete computationModules[computationModule];\n        success = true;\n        emit ComputationModuleDisabled(computationModule);\n    }\n\n    function disableExecutionModule(\n        IExecutionModule executionModule\n    ) public onlyOwner returns (bool success) {\n        require(\n            executionModules[executionModule],\n            ModuleNotEnabled(address(executionModule))\n        );\n        delete executionModules[executionModule];\n        success = true;\n        emit ExecutionModuleDisabled(executionModule);\n    }\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                   Get Functions                        //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    function getE3(uint256 e3Id) public view returns (E3 memory e3) {\n        e3 = e3s[e3Id];\n        require(\n            e3.computationModule != IComputationModule(address(0)),\n            E3DoesNotExist(e3Id)\n        );\n    }\n}\n"
    },
    "contracts/interfaces/IComputationModule.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.26;\n\nimport { IInputValidator } from \"./IInputValidator.sol\";\n\ninterface IComputationModule {\n    /// @notice This function should be called by the Enclave contract to validate the computation parameters.\n    /// @param params ABI encoded computation parameters.\n    /// @return inputValidator The input validator to be used for the computation.\n    function validate(\n        bytes calldata params\n    ) external returns (IInputValidator inputValidator);\n\n    /// @notice This function should be called by the Enclave contract to verify the decrypted output of an E3.\n    /// @param e3Id ID of the E3.\n    /// @param outputData ABI encoded output data to be verified.\n    /// @return output The output data to be published.\n    /// @return success Whether the output data is valid.\n    function verify(\n        uint256 e3Id,\n        bytes memory outputData\n    ) external returns (bytes memory output, bool success);\n}\n"
    },
    "contracts/interfaces/ICyphernodeRegistry.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.26;\n\ninterface ICyphernodeRegistry {\n    /// @notice This event MUST be emitted when a committee is selected for an E3.\n    /// @param e3Id ID of the E3 for which the committee was selected.\n    /// @param filter Address of the contract that will coordinate committee selection.\n    /// @param threshold The M/N threshold for the committee.\n    event CommitteeRequested(\n        uint256 indexed e3Id,\n        address filter,\n        uint32[2] threshold\n    );\n\n    /// @notice This event MUST be emitted when a committee is selected for an E3.\n    /// @param e3Id ID of the E3 for which the committee was selected.\n    /// @param publicKey Public key of the committee.\n    event CommitteePublished(uint256 indexed e3Id, bytes publicKey);\n\n    /// @notice This event MUST be emitted when `enclave` is set.\n    /// @param enclave Address of the enclave contract.\n    event EnclaveSet(address indexed enclave);\n\n    /// @notice This event MUST be emitted when a cyphernode is added to the registry.\n    event CyphernodeAdded(address indexed node);\n\n    /// @notice This event MUST be emitted when a cyphernode is removed from the registry.\n    event CyphernodeRemoved(address indexed node);\n\n    function isCyphernodeEligible(address cyphernode) external returns (bool);\n\n    /// @notice Initiates the committee selection process for a specified E3.\n    /// @dev This function MUST revert when not called by the Enclave contract.\n    /// @param e3Id ID of the E3 for which to select the committee.\n    /// @param filter The address of the filter responsible for the committee selection process.\n    /// @param threshold The M/N threshold for the committee.\n    /// @return success True if committee selection was successfully initiated.\n    function requestCommittee(\n        uint256 e3Id,\n        address filter,\n        uint32[2] calldata threshold\n    ) external returns (bool success);\n\n    /// @notice Publishes the public key resulting from the committee selection process.\n    /// @dev This function MUST revert if not called by the previously selected filter.\n    /// @param e3Id ID of the E3 for which to select the committee.\n    /// @param publicKey The public key generated by the selected committee.\n    function publishCommittee(\n        uint256 e3Id,\n        bytes calldata proof,\n        bytes calldata publicKey\n    ) external;\n\n    /// @notice This function should be called by the Enclave contract to get the public key of a committee.\n    /// @dev This function MUST revert if no committee has been requested for the given E3.\n    /// @dev This function MUST revert if the committee has not yet published a public key.\n    /// @param e3Id ID of the E3 for which to get the committee public key.\n    /// @return publicKey The public key of the committee.\n    function committeePublicKey(\n        uint256 e3Id\n    ) external view returns (bytes memory);\n}\n"
    },
    "contracts/interfaces/IE3.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.26;\n\nimport { IInputValidator } from \"./IInputValidator.sol\";\nimport { IExecutionModule } from \"./IExecutionModule.sol\";\nimport { IComputationModule } from \"./IComputationModule.sol\";\nimport { IOutputVerifier } from \"./IOutputVerifier.sol\";\n\n/// @title E3 struct\n/// @notice This struct represents an E3 computation.\n/// @param threshold M/N threshold for the committee.\n/// @param startWindow Start window for the computation: index zero is minimum, index 1 is the maxium.\n/// @param duration Duration of the E3.\n/// @param expiration Timestamp when committee duties expire.\n/// @param computationModule Address of the computation module contract.\n/// @param executionModule Address of the execution module contract.\n/// @param inputValidator Address of the input validator contract.\n/// @param outputVerifier Address of the output verifier contract.\n/// @param committeeId ID of the selected committee.\n/// @param ciphertextOutput Encrypted output data.\n/// @param plaintextOutput Decrypted output data.\nstruct E3 {\n    uint32[2] threshold;\n    uint256[2] startWindow;\n    uint256 duration;\n    uint256 expiration;\n    IComputationModule computationModule;\n    IExecutionModule executionModule;\n    IInputValidator inputValidator;\n    IOutputVerifier outputVerifier;\n    bytes committeePublicKey;\n    bytes[] inputs;\n    bytes ciphertextOutput;\n    bytes plaintextOutput;\n}\n"
    },
    "contracts/interfaces/IEnclave.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.26;\n\nimport { E3, IComputationModule, IExecutionModule } from \"./IE3.sol\";\n\ninterface IEnclave {\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                         Events                         //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    /// @notice This event MUST be emitted when an Encrypted Execution Environment (E3) is successfully requested.\n    /// @param e3Id ID of the E3.\n    /// @param e3 Details of the E3.\n    /// @param filter Address of the pool of nodes from which the Cypher Node committee was selected.\n    /// @param computationModule Address of the Computation module selected.\n    /// @param executionModule  Address of the execution module selected.\n    event E3Requested(\n        uint256 e3Id,\n        E3 e3,\n        address filter,\n        IComputationModule indexed computationModule,\n        IExecutionModule indexed executionModule\n    );\n\n    /// @notice This event MUST be emitted when an Encrypted Execution Environment (E3) is successfully activated.\n    /// @param e3Id ID of the E3.\n    /// @param expiration Timestamp when committee duties expire.\n    /// @param committeePublicKey Public key of the committee.\n    event E3Activated(\n        uint256 e3Id,\n        uint256 expiration,\n        bytes committeePublicKey\n    );\n\n    /// @notice This event MUST be emitted when an input to an Encrypted Execution Environment (E3) is\n    /// successfully published.\n    /// @param e3Id ID of the E3.\n    /// @param data ABI encoded input data.\n    event InputPublished(uint256 indexed e3Id, bytes data);\n\n    /// @notice This event MUST be emitted when the plaintext output of an Encrypted Execution Environment (E3)\n    /// is successfully published.\n    /// @param e3Id ID of the E3.\n    /// @param plaintextOutput ABI encoded plaintext output.\n    event PlaintextOutputPublished(uint256 indexed e3Id, bytes plaintextOutput);\n\n    /// @notice This event MUST be emitted when the ciphertext output of an Encrypted Execution Environment (E3)\n    /// is successfully published.\n    /// @param e3Id ID of the E3.\n    /// @param ciphertextOutput ABI encoded ciphertext output.\n    event CiphertextOutputPublished(\n        uint256 indexed e3Id,\n        bytes ciphertextOutput\n    );\n\n    /// @notice This event MUST be emitted any time the `maxDuration` is set.\n    /// @param maxDuration The maximum duration of a computation in seconds.\n    event MaxDurationSet(uint256 maxDuration);\n\n    /// @notice This event MUST be emitted any time the CyphernodeRegistry is set.\n    /// @param cyphernodeRegistry The address of the CyphernodeRegistry contract.\n    event CyphernodeRegistrySet(address cyphernodeRegistry);\n\n    /// @notice This event MUST be emitted any time a computation module is enabled.\n    /// @param computationModule The address of the computation module.\n    event ComputationModuleEnabled(IComputationModule computationModule);\n\n    /// @notice This event MUST be emitted any time a computation module is disabled.\n    /// @param computationModule The address of the computation module.\n    event ComputationModuleDisabled(IComputationModule computationModule);\n\n    /// @notice This event MUST be emitted any time an execution module is enabled.\n    /// @param executionModule The address of the execution module.\n    event ExecutionModuleEnabled(IExecutionModule executionModule);\n\n    /// @notice This event MUST be emitted any time an execution module is disabled.\n    /// @param executionModule The address of the execution module.\n    event ExecutionModuleDisabled(IExecutionModule executionModule);\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                  Core Entrypoints                      //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    /// @notice This function should be called to request a computation within an Encrypted Execution Environment (E3).\n    /// @dev This function MUST emit the E3Requested event.\n    /// @param filter IDs of the pool of nodes from which to select the committee.\n    /// @param threshold The M/N threshold for the committee.\n    /// @param duration The duration of the computation in seconds.\n    /// @param computationModule Address of the computation module.\n    /// @param computationParams ABI encoded computation parameters.\n    /// @param executionModule Address of the execution module.\n    /// @param emParams ABI encoded execution module parameters.\n    /// @return e3Id ID of the E3.\n    /// @return e3 The E3 struct.\n    function request(\n        address filter,\n        uint32[2] calldata threshold,\n        uint256[2] calldata startWindow,\n        uint256 duration,\n        IComputationModule computationModule,\n        bytes memory computationParams,\n        IExecutionModule executionModule,\n        bytes memory emParams\n    ) external payable returns (uint256 e3Id, E3 memory e3);\n\n    /// @notice This function should be called to activate an Encrypted Execution Environment (E3) once it has been\n    /// initialized and is ready for input.\n    /// @dev This function MUST emit the E3Activated event.\n    /// @dev This function MUST revert if the given E3 has not yet been requested.\n    /// @dev This function MUST revert if the selected node committee has not yet published a public key.\n    /// @param e3Id ID of the E3.\n    function activate(uint256 e3Id) external returns (bool success);\n\n    /// @notice This function should be called to publish input data for Encrypted Execution Environment (E3).\n    /// @dev This function MUST revert if the E3 is not yet activated.\n    /// @dev This function MUST emit the InputPublished event.\n    /// @param e3Id ID of the E3.\n    /// @param data ABI encoded input data to publish.\n    /// @return success True if the input was successfully published.\n    function publishInput(\n        uint256 e3Id,\n        bytes calldata data\n    ) external returns (bool success);\n\n    /// @notice This function should be called to publish output data for an Encrypted Execution Environment (E3).\n    /// @dev This function MUST emit the CiphertextOutputPublished event.\n    /// @param e3Id ID of the E3.\n    /// @param data ABI encoded output data to verify.\n    /// @return success True if the output was successfully published.\n    function publishCiphertextOutput(\n        uint256 e3Id,\n        bytes memory data\n    ) external returns (bool success);\n\n    /// @notice This function publishes the plaintext output of an Encrypted Execution Environment (E3).\n    /// @dev This function MUST revert if the output has not been published.\n    /// @dev This function MUST emit the PlaintextOutputPublished event.\n    /// @param e3Id ID of the E3.\n    /// @param data ABI encoded output data to decrypt.\n    /// @return success True if the output was successfully decrypted.\n    function publishPlaintextOutput(\n        uint256 e3Id,\n        bytes memory data\n    ) external returns (bool success);\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                   Set Functions                        //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    /// @notice This function should be called to set the maximum duration of requested computations.\n    /// @param _maxDuration The maximum duration of a computation in seconds.\n    /// @return success True if the max duration was successfully set.\n    function setMaxDuration(\n        uint256 _maxDuration\n    ) external returns (bool success);\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                   Get Functions                        //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    /// @notice This function should be called to retrieve the details of an Encrypted Execution Environment (E3).\n    /// @dev This function MUST revert if the E3 does not exist.\n    /// @param e3Id ID of the E3.\n    /// @return e3 The struct representing the requested E3.\n    function getE3(uint256 e3Id) external view returns (E3 memory e3);\n}\n"
    },
    "contracts/interfaces/IExecutionModule.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.26;\n\nimport { IOutputVerifier } from \"./IOutputVerifier.sol\";\n\ninterface IExecutionModule {\n    /// @notice This function should be called by the Enclave contract to validate the execution module parameters.\n    /// @param params ABI encoded execution module parameters.\n    function validate(\n        bytes calldata params\n    ) external returns (IOutputVerifier outputVerifier);\n}\n"
    },
    "contracts/interfaces/IInputValidator.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.26;\n\ninterface IInputValidator {\n    /// @notice This function should be called by the Enclave contract to validate the input parameters.\n    /// @param params ABI encoded input parameters.\n    /// @return input The input data to be published.\n    /// @return success Whether the input parameters are valid.\n    function validate(\n        address sender,\n        bytes memory params\n    ) external returns (bytes memory input, bool success);\n}\n"
    },
    "contracts/interfaces/IOutputVerifier.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.26;\n\ninterface IOutputVerifier {\n    /// @notice This function should be called by the Enclave contract to verify the output of a computation.\n    /// @param e3Id ID of the E3.\n    /// @param data ABI encoded output data to be verified.\n    /// @return output Ciphertext output of the given computation.\n    function verify(\n        uint256 e3Id,\n        bytes memory data\n    ) external view returns (bytes memory output, bool success);\n}\n"
    },
    "contracts/interfaces/IRegistryFilter.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.26;\n\ninterface IRegistryFilter {\n    function requestCommittee(\n        uint256 e3Id,\n        uint32[2] calldata threshold\n    ) external returns (bool success);\n}\n"
    },
    "contracts/registry/CyphernodeRegistryOwnable.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.26;\n\nimport { ICyphernodeRegistry } from \"../interfaces/ICyphernodeRegistry.sol\";\nimport { IRegistryFilter } from \"../interfaces/IRegistryFilter.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract CyphernodeRegistryOwnable is ICyphernodeRegistry, OwnableUpgradeable {\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                 Storage Variables                      //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    address public enclave;\n\n    mapping(address cyphernode => bool isEnabled) public isEnabled;\n\n    mapping(uint256 e3Id => IRegistryFilter filter) public requests;\n    mapping(uint256 e3Id => bytes publicKey) public publicKeys;\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                        Errors                          //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    error CommitteeAlreadyRequested();\n    error CommitteeAlreadyPublished();\n    error CommitteeDoesNotExist();\n    error CommitteeNotPublished();\n    error CyphernodeNotEnabled(address node);\n    error OnlyEnclave();\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                     Modifiers                          //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    modifier onlyEnclave() {\n        require(msg.sender == enclave, OnlyEnclave());\n        _;\n    }\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                   Initialization                       //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    constructor(address _owner, address _enclave) {\n        initialize(_owner, _enclave);\n    }\n\n    function initialize(address _owner, address _enclave) public initializer {\n        __Ownable_init(msg.sender);\n        setEnclave(_enclave);\n        transferOwnership(_owner);\n    }\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                  Core Entrypoints                      //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    function requestCommittee(\n        uint256 e3Id,\n        address filter,\n        uint32[2] calldata threshold\n    ) external onlyEnclave returns (bool success) {\n        require(\n            requests[e3Id] == IRegistryFilter(address(0)),\n            CommitteeAlreadyRequested()\n        );\n        requests[e3Id] = IRegistryFilter(filter);\n\n        IRegistryFilter(filter).requestCommittee(e3Id, threshold);\n        emit CommitteeRequested(e3Id, filter, threshold);\n        success = true;\n    }\n\n    function publishCommittee(\n        uint256 e3Id,\n        bytes calldata,\n        bytes calldata publicKey\n    ) external {\n        // only to be published by the filter\n        require(address(requests[e3Id]) == msg.sender, CommitteeDoesNotExist());\n\n        // for (uint256 i = 0; i < cyphernodes.length; i++) {\n        //     require(\n        //         isEnabled[cyphernodes[i]] == true,\n        //         CyphernodeNotEnabled(cyphernodes[i])\n        //     );\n        // }\n\n        publicKeys[e3Id] = publicKey;\n        emit CommitteePublished(e3Id, publicKey);\n    }\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                   Set Functions                        //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    function setEnclave(address _enclave) public onlyOwner {\n        enclave = _enclave;\n        emit EnclaveSet(_enclave);\n    }\n\n    function addCyphernode(address node) external onlyOwner {\n        isEnabled[node] = true;\n        emit CyphernodeAdded(node);\n    }\n\n    function removeCyphernode(address node) external onlyOwner {\n        isEnabled[node] = false;\n        emit CyphernodeRemoved(node);\n    }\n\n    function isCyphernodeEligible(address node) external view returns (bool) {\n        return isEnabled[node];\n    }\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                   Get Functions                        //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    function committeePublicKey(\n        uint256 e3Id\n    ) external view returns (bytes memory publicKey) {\n        publicKey = publicKeys[e3Id];\n        require(publicKey.length > 0, CommitteeNotPublished());\n    }\n}\n"
    },
    "contracts/registry/NaiveRegistryFilter.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.26;\n\nimport { ICyphernodeRegistry } from \"../interfaces/ICyphernodeRegistry.sol\";\nimport { IRegistryFilter } from \"../interfaces/IRegistryFilter.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract NaiveRegistryFilter is IRegistryFilter, OwnableUpgradeable {\n    struct Committee {\n        address[] nodes;\n        uint32[2] threshold;\n        bytes publicKey;\n    }\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                 Storage Variables                      //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    address public registry;\n\n    mapping(uint256 e3 => Committee committee) public committees;\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                        Errors                          //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    error CommitteeAlreadyExists();\n    error CommitteeAlreadyPublished();\n    error CommitteeDoesNotExist();\n    error CommitteeNotPublished();\n    error OnlyRegistry();\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                     Modifiers                          //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    modifier onlyRegistry() {\n        require(msg.sender == registry, OnlyRegistry());\n        _;\n    }\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                   Initialization                       //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    constructor(address _owner, address _enclave) {\n        initialize(_owner, _enclave);\n    }\n\n    function initialize(address _owner, address _registry) public initializer {\n        __Ownable_init(msg.sender);\n        setRegistry(_registry);\n        transferOwnership(_owner);\n    }\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                  Core Entrypoints                      //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    function requestCommittee(\n        uint256 e3Id,\n        uint32[2] calldata threshold\n    ) external onlyRegistry returns (bool success) {\n        Committee storage committee = committees[e3Id];\n        require(committee.threshold.length == 0, CommitteeAlreadyExists());\n        committee.threshold = threshold;\n        success = true;\n    }\n\n    function publishCommittee(\n        uint256 e3Id,\n        address[] memory nodes,\n        bytes memory publicKey\n    ) external onlyOwner {\n        Committee storage committee = committees[e3Id];\n        require(\n            keccak256(committee.publicKey) == keccak256(hex\"\"),\n            CommitteeAlreadyPublished()\n        );\n        committee.nodes = nodes;\n        committee.publicKey = publicKey;\n        ICyphernodeRegistry(registry).publishCommittee(\n            e3Id,\n            abi.encode(nodes),\n            publicKey\n        );\n    }\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                   Set Functions                        //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    function setRegistry(address _registry) public onlyOwner {\n        registry = _registry;\n    }\n}\n"
    },
    "contracts/test/MockComputationModule.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.26;\n\nimport {\n    IComputationModule,\n    IInputValidator\n} from \"../interfaces/IComputationModule.sol\";\n\ncontract MockComputationModule is IComputationModule {\n    error invalidParams(bytes params);\n\n    function validate(\n        bytes memory params\n    ) external pure returns (IInputValidator inputValidator) {\n        require(params.length == 32, \"invalid params\");\n        // solhint-disable no-inline-assembly\n        assembly {\n            inputValidator := mload(add(params, 32))\n        }\n    }\n\n    function verify(\n        uint256,\n        bytes memory data\n    ) external pure returns (bytes memory output, bool success) {\n        output = data;\n        if (output.length > 0) success = true;\n    }\n}\n"
    },
    "contracts/test/MockCyphernodeRegistry.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.26;\n\nimport { ICyphernodeRegistry } from \"../interfaces/ICyphernodeRegistry.sol\";\n\ncontract MockCyphernodeRegistry is ICyphernodeRegistry {\n    function requestCommittee(\n        uint256,\n        address filter,\n        uint32[2] calldata\n    ) external pure returns (bool success) {\n        if (filter == address(2)) {\n            success = false;\n        } else {\n            success = true;\n        }\n    }\n\n    function publishCommittee(\n        uint256,\n        bytes calldata,\n        bytes calldata\n    ) external {} // solhint-disable-line no-empty-blocks\n\n    function committeePublicKey(\n        uint256 e3Id\n    ) external pure returns (bytes memory) {\n        if (e3Id == type(uint256).max) {\n            return hex\"\";\n        } else {\n            return abi.encodePacked(keccak256(abi.encode(e3Id)));\n        }\n    }\n\n    function isCyphernodeEligible(address) external pure returns (bool) {\n        return false;\n    }\n}\n\ncontract MockCyphernodeRegistryEmptyKey is ICyphernodeRegistry {\n    function requestCommittee(\n        uint256,\n        address filter,\n        uint32[2] calldata\n    ) external pure returns (bool success) {\n        if (filter == address(2)) {\n            success = false;\n        } else {\n            success = true;\n        }\n    }\n\n    function publishCommittee(\n        uint256,\n        bytes calldata,\n        bytes calldata\n    ) external {} // solhint-disable-line no-empty-blocks\n\n    function committeePublicKey(uint256) external pure returns (bytes memory) {\n        return hex\"\";\n    }\n\n    function isCyphernodeEligible(address) external pure returns (bool) {\n        return false;\n    }\n}\n"
    },
    "contracts/test/MockExecutionModule.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.26;\n\nimport {\n    IExecutionModule,\n    IOutputVerifier\n} from \"../interfaces/IExecutionModule.sol\";\n\ncontract MockExecutionModule is IExecutionModule {\n    error invalidParams();\n\n    function validate(\n        bytes memory params\n    ) external pure returns (IOutputVerifier outputVerifier) {\n        require(params.length == 32, invalidParams());\n        // solhint-disable no-inline-assembly\n        assembly {\n            outputVerifier := mload(add(params, 32))\n        }\n        (outputVerifier) = abi.decode(params, (IOutputVerifier));\n    }\n}\n"
    },
    "contracts/test/MockInputValidator.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.26;\n\nimport { IInputValidator } from \"../interfaces/IInputValidator.sol\";\n\ncontract MockInputValidator is IInputValidator {\n    function validate(\n        address,\n        bytes memory params\n    ) external pure returns (bytes memory input, bool success) {\n        input = params;\n\n        if (input.length == 3) {\n            success = false;\n        } else {\n            success = true;\n        }\n    }\n}\n"
    },
    "contracts/test/MockOutputVerifier.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.26;\n\nimport { IOutputVerifier } from \"../interfaces/IOutputVerifier.sol\";\n\ncontract MockOutputVerifier is IOutputVerifier {\n    function verify(\n        uint256,\n        bytes memory data\n    ) external pure returns (bytes memory output, bool success) {\n        output = data;\n\n        if (output.length > 0) success = true;\n    }\n}\n"
    },
    "contracts/test/MockRegistryFilter.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.8.26;\n\nimport { IRegistryFilter } from \"../interfaces/IRegistryFilter.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ninterface IRegistry {\n    function publishCommittee(\n        uint256 e3Id,\n        address[] calldata cyphernodes,\n        bytes calldata publicKey\n    ) external;\n}\n\ncontract NaiveRegistryFilter is IRegistryFilter, OwnableUpgradeable {\n    struct Committee {\n        address[] nodes;\n        uint32[2] threshold;\n        bytes publicKey;\n    }\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                 Storage Variables                      //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    address public registry;\n\n    mapping(uint256 e3 => Committee committee) public committees;\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                        Errors                          //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    error CommitteeAlreadyExists();\n    error CommitteeAlreadyPublished();\n    error CommitteeDoesNotExist();\n    error CommitteeNotPublished();\n    error OnlyRegistry();\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                     Modifiers                          //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    modifier onlyRegistry() {\n        require(msg.sender == registry, OnlyRegistry());\n        _;\n    }\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                   Initialization                       //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    constructor(address _owner, address _enclave) {\n        initialize(_owner, _enclave);\n    }\n\n    function initialize(address _owner, address _registry) public initializer {\n        __Ownable_init(msg.sender);\n        setRegistry(_registry);\n        transferOwnership(_owner);\n    }\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                  Core Entrypoints                      //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    function requestCommittee(\n        uint256 e3Id,\n        uint32[2] calldata threshold\n    ) external onlyRegistry returns (bool success) {\n        Committee storage committee = committees[e3Id];\n        require(committee.threshold.length == 0, CommitteeAlreadyExists());\n        committee.threshold = threshold;\n        success = true;\n    }\n\n    function publishCommittee(\n        uint256 e3Id,\n        address[] memory nodes,\n        bytes memory publicKey\n    ) external onlyOwner {\n        Committee storage committee = committees[e3Id];\n        require(\n            keccak256(committee.publicKey) == keccak256(hex\"\"),\n            CommitteeAlreadyPublished()\n        );\n        committee.nodes = nodes;\n        committee.publicKey = publicKey;\n        IRegistry(registry).publishCommittee(e3Id, nodes, publicKey);\n    }\n\n    ////////////////////////////////////////////////////////////\n    //                                                        //\n    //                   Set Functions                        //\n    //                                                        //\n    ////////////////////////////////////////////////////////////\n\n    function setRegistry(address _registry) public onlyOwner {\n        registry = _registry;\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}